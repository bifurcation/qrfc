<!DOCTYPE html>
<html lang="en" class="RFC">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>RFC 9623: Implementing Interfaces to Transport Services</title>
<meta content="Anna Brunstrom" name="author">
<meta content="Tommy Pauly" name="author">
<meta content="Reese Enghardt" name="author">
<meta content="Philipp S. Tiesel" name="author">
<meta content="Michael Welzl" name="author">
<meta content="
       The Transport Services System enables applications to use transport protocols flexibly for network communication
and defines a protocol-independent Transport Services Application Programming Interface (API) that is based on an asynchronous,
event-driven interaction pattern. This document serves as a guide to implementing such a system. 
    " name="description">
<meta content="xml2rfc 3.25.0" name="generator">
<meta content="9623" name="rfc.number">
<!-- Generator version information:
  xml2rfc 3.25.0
    Python 3.9.15
    ConfigArgParse 1.5.3
    google-i18n-address 3.0.0
    intervaltree 3.1.0
    Jinja2 3.1.2
    lxml 5.3.0
    platformdirs 3.8.0
    pycountry 22.3.5
    pydyf 0.10.0
    PyYAML 6.0
    requests 2.28.0
    setuptools 44.1.1
    wcwidth 0.2.5
    weasyprint 62.3
-->
<link href="rfc9623.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">/*

  NOTE: Changes at the bottom of this file overrides some earlier settings.

  Once the style has stabilized and has been adopted as an official RFC style,
  this can be consolidated so that style settings occur only in one place, but
  for now the contents of this file consists first of the initial CSS work as
  provided to the RFC Formatter (xml2rfc) work, followed by itemized and
  commented changes found necessary during the development of the v3
  formatters.

*/

/* fonts */
@import url('https://fonts.googleapis.com/css?family=Noto+Sans'); /* Sans-serif */
@import url('https://fonts.googleapis.com/css?family=Noto+Serif'); /* Serif (print) */
@import url('https://fonts.googleapis.com/css?family=Roboto+Mono'); /* Monospace */

:root {
  --font-sans: 'Noto Sans', Arial, Helvetica, sans-serif;
  --font-serif: 'Noto Serif', 'Times', 'Times New Roman', serif;
  --font-mono: 'Roboto Mono', Courier, 'Courier New', monospace;
}

@viewport {
  zoom: 1.0;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}
/* general and mobile first */
html {
}
body {
  max-width: 90%;
  margin: 1.5em auto;
  color: #222;
  background-color: #fff;
  font-size: 14px;
  font-family: var(--font-sans);
  line-height: 1.6;
  scroll-behavior: smooth;
  overflow-wrap: break-word;
}
.ears {
  display: none;
}

/* headings */
#title, h1, h2, h3, h4, h5, h6 {
  margin: 1em 0 0.5em;
  font-weight: bold;
  line-height: 1.3;
}
#title {
  clear: both;
  border-bottom: 1px solid #ddd;
  margin: 0 0 0.5em 0;
  padding: 1em 0 0.5em;
}
.author {
  padding-bottom: 4px;
}
h1 {
  font-size: 26px;
  margin: 1em 0;
}
h2 {
  font-size: 22px;
  margin-top: -20px;  /* provide offset for in-page anchors */
  padding-top: 33px;
}
h3 {
  font-size: 18px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h4 {
  font-size: 16px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h5, h6 {
  font-size: 14px;
}
#n-copyright-notice {
  border-bottom: 1px solid #ddd;
  padding-bottom: 1em;
  margin-bottom: 1em;
}
/* general structure */
p {
  padding: 0;
  margin: 0 0 1em 0;
  text-align: left;
}
div, span {
  position: relative;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignRight.art-text pre {
  padding: 0;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
svg[font-family~="serif" i], svg [font-family~="serif" i] {
  font-family: var(--font-serif);
}
svg[font-family~="sans-serif" i], svg [font-family~="sans-serif" i] {
  font-family: var(--font-sans);
}
svg[font-family~="monospace" i], svg [font-family~="monospace" i] {
  font-family: var(--font-mono);
}
.alignCenter.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignCenter.art-text pre {
  padding: 0;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  display: table;
  border: none;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 1em 2em;
}
ol ol, ul ul, ol ul, ul ol {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
ul.ulBare, li.ulBare {
  margin-left: 0em !important;
}
ul.compact, .ulCompact,
ol.compact, .olCompact {
  line-height: 100%;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
}
dl > dt {
  float: left;
  margin-right: 1em;
}
/* 
dl.nohang > dt {
  float: none;
}
*/
dl > dd {
  margin-bottom: .8em;
  min-height: 1.3em;
}
dl.compact > dd, .dlCompact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}

/* links */
a {
  text-decoration: none;
}
a[href] {
  color: #22e; /* Arlen: WCAG 2019 */
}
a[href]:hover {
  background-color: #f2f2f2;
}
figcaption a[href],
a[href].selfRef {
  color: #222;
}
/* XXX probably not this:
a.selfRef:hover {
  background-color: transparent;
  cursor: default;
} */

/* Figures */
tt, code, pre {
  background-color: #f9f9f9;
  font-family: var(--font-mono);
}
pre {
  border: 1px solid #eee;
  margin: 0;
  padding: 1em;
}
img {
  max-width: 100%;
}
figure {
  margin: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption {
  font-style: italic;
  margin: 0 0 1em 0;
}
@media screen {
  pre {
    overflow-x: auto;
    max-width: 100%;
    max-width: calc(100% - 22px);
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 1.2em 2em;
}
blockquote {
  background-color: #f9f9f9;
  color: #111; /* Arlen: WCAG 2019 */
  border: 1px solid #ddd;
  border-radius: 3px;
  margin: 1em 0;
}
blockquote > *:last-child {
  margin-bottom: 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}
.xref {
  overflow-wrap: normal;
}

/* tables */
table {
  width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
  border: 1px solid #eee;
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 0.5em 0.75em;
}
th {
  text-align: left;
  background-color: #e9e9e9;
}
tr:nth-child(2n+1) > td {
  background-color: #f5f5f5;
}
table caption {
  font-style: italic;
  margin: 0;
  padding: 0;
  text-align: left;
}
table p {
  /* XXX to avoid bottom margin on table row signifiers. If paragraphs should
     be allowed within tables more generally, it would be far better to select on a class. */
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  color: #666; /* Arlen: AHDJ 2019 */
  text-decoration: none;
  visibility: hidden;
  user-select: none;
  -ms-user-select: none;
  -o-user-select:none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}
@media screen {
  aside:hover > a.pilcrow,
  p:hover > a.pilcrow,
  blockquote:hover > a.pilcrow,
  div:hover > a.pilcrow,
  li:hover > a.pilcrow,
  pre:hover > a.pilcrow {
    visibility: visible;
  }
  a.pilcrow:hover {
    background-color: transparent;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid #eee;
}
.bcp14 {
  font-variant: small-caps;
}

.role {
  font-variant: all-small-caps;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: 0.9em;
}
#identifiers dt {
  width: 3em;
  clear: left;
}
#identifiers dd {
  float: left;
  margin-bottom: 0;
}
/* Fix PDF info block run off issue */
@media print {
  #identifiers dd {
    float: none;
  }
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #666; /* Arlen: WCAG 2019 */
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc  {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
nav.toc ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
nav.toc li {
  line-height: 1.3em;
  margin: 0.75em 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 7em;
}
.references dd {
  margin-left: 8em;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.refSubseries {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
.index ul {
  margin: 0 0 0 1em;
  padding: 0;
  list-style: none;
}
.index ul ul {
  margin: 0;
}
.index li {
  margin: 0;
  text-indent: -2em;
  padding-left: 2em;
  padding-bottom: 5px;
}
.indexIndex {
  margin: 0.5em 0 1em;
}
.index a {
  font-weight: 700;
}
/* make the index two-column on all but the smallest screens */
@media (min-width: 600px) {
  .index ul {
    -moz-column-count: 2;
    -moz-column-gap: 20px;
  }
  .index ul ul {
    -moz-column-count: 1;
    -moz-column-gap: 0;
  }
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}

address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  font-family: var(--font-sans);
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}

/* temporary notes */
.rfcEditorRemove::before {
  position: absolute;
  top: 0.2em;
  right: 0.2em;
  padding: 0.2em;
  content: "The RFC Editor will remove this note";
  color: #9e2a00; /* Arlen: WCAG 2019 */
  background-color: #ffd; /* Arlen: WCAG 2019 */
}
.rfcEditorRemove {
  position: relative;
  padding-top: 1.8em;
  background-color: #ffd; /* Arlen: WCAG 2019 */
  border-radius: 3px;
}
.cref {
  background-color: #ffd; /* Arlen: WCAG 2019 */
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 1023px) {
  body {
    padding-top: 2em;
  }
  #title {
    padding: 1em 0;
  }
  h1 {
    font-size: 24px;
  }
  h2 {
    font-size: 20px;
    margin-top: -18px;  /* provide offset for in-page anchors */
    padding-top: 38px;
  }
  #identifiers dd {
    max-width: 60%;
  }
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 0;
    margin: 0;
    background-color: inherit;
    border-bottom: 1px solid #ccc;
  }
  #toc h2 {
    margin: -1px 0 0 0;
    padding: 4px 0 4px 6px;
    padding-right: 1em;
    min-width: 190px;
    font-size: 1.1em;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 6px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    padding: 0.5em 1em 1em;
    overflow: auto;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 1024px) {
  body {
    max-width: 724px;
    margin: 42px auto;
    padding-left: 1.5em;
    padding-right: 29em;
  }
  #toc {
    position: fixed;
    top: 42px;
    right: 42px;
    width: 25%;
    margin: 0;
    padding: 0 1em;
    z-index: 1;
  }
  #toc h2 {
    border-top: none;
    border-bottom: 1px solid #ddd;
    font-size: 1em;
    font-weight: normal;
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 0;
    overflow: auto;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {
    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre {
    page-break-inside: avoid;
  }
  figure {
    overflow: scroll;
  }
  .breakable pre {
    break-inside: auto;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  h2+*, h3+*, h4+*, h5+*, h6+* {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

/* This is commented out here, as the string-set: doesn't
   pass W3C validation currently */
/*
.ears thead .left {
  string-set: ears-top-left content();
}

.ears thead .center {
  string-set: ears-top-center content();
}

.ears thead .right {
  string-set: ears-top-right content();
}

.ears tfoot .left {
  string-set: ears-bottom-left content();
}

.ears tfoot .center {
  string-set: ears-bottom-center content();
}

.ears tfoot .right {
  string-set: ears-bottom-right content();
}
*/

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
  /* The following is commented out here, but set appropriately by in code, as
     the content depends on the document */
  /*
  @top-left {
    content: 'Internet-Draft';
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-left {
    content: string(ears-top-left);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-center {
    content: string(ears-top-center);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-right {
    content: string(ears-top-right);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @bottom-left {
    content: string(ears-bottom-left);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-center {
    content: string(ears-bottom-center);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-right {
      content: '[Page ' counter(page) ']';
      vertical-align: top;
      border-top: solid 1px #ccc;
  }
  */

}

/* Changes introduced to fix issues found during implementation */
/* Make sure links are clickable even if overlapped by following H* */
a {
  z-index: 2;
}
/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}


/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Leave room in document info to show Internet-Draft on one line */
#identifiers dt {
  width: 8em;
}

/* Don't waste quite as much whitespace between label and value in doc info */
#identifiers dd {
  margin-left: 1em;
}

/* Give floating toc a background color (needed when it's a div inside section */
#toc {
  background-color: white;
}

/* Make the collapsed ToC header render white on gray also when it's a link */
@media screen and (max-width: 1023px) {
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
}

/* Give the bottom of the ToC some whitespace */
@media screen and (min-width: 1024px) {
  #toc {
    padding: 0 0 1em 1em;
  }
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* prevent monospace from becoming overly large */
tt, code, pre {
  font-size: 95%;
}

/* Fix the height/width aspect for ascii art*/
.sourcecode pre,
.art-text pre {
  line-height: 1.12;
}


/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin-right: 0.5em;
}

/* Fix the dl styling to match the RFC 7992 attributes */
dl > dt,
dl.dlParallel > dt {
  float: left;
  margin-right: 1em;
}
dl.dlNewline > dt {
  float: none;
}

/* Provide styling for table cell text alignment */
table td.text-left,
table th.text-left {
  text-align: left;
}
table td.text-center,
table th.text-center {
  text-align: center;
}
table td.text-right,
table th.text-right {
  text-align: right;
}

/* Make the alternative author contact information look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 30em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Provide table alignment support.  We can't use the alignX classes above
   since they do unwanted things with caption and other styling. */
table.right {
 margin-left: auto;
 margin-right: 0;
}
table.center {
 margin-left: auto;
 margin-right: auto;
}
table.left {
 margin-left: 0;
 margin-right: auto;
}

/* Give the table caption label the same styling as the figcaption */
caption a[href] {
  color: #222;
}

@media print {
  .toplink {
    display: none;
  }

  /* avoid overwriting the top border line with the ToC header */
  #toc {
    padding-top: 1px;
  }

  /* Avoid page breaks inside dl and author address entries */
  .vcard {
    page-break-inside: avoid;
  }

}
/* Tweak the bcp14 keyword presentation */
.bcp14 {
  font-variant: small-caps;
  font-weight: bold;
  font-size: 0.9em;
}
/* Tweak the invisible space above H* in order not to overlay links in text above */
 h2 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 31px;
 }
 h3 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
 h4 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
/* Float artwork pilcrow to the right */
@media screen {
  .artwork a.pilcrow {
    display: block;
    line-height: 0.7;
    margin-top: 0.15em;
  }
}
/* Make pilcrows on dd visible */
@media screen {
  dd:hover > a.pilcrow {
    visibility: visible;
  }
}
/* Make the placement of figcaption match that of a table's caption
   by removing the figure's added bottom margin */
.alignLeft.art-text,
.alignCenter.art-text,
.alignRight.art-text {
   margin-bottom: 0;
}
.alignLeft,
.alignCenter,
.alignRight {
  margin: 1em 0 0 0;
}
/* In print, the pilcrow won't show on hover, so prevent it from taking up space,
   possibly even requiring a new line */
@media print {
  a.pilcrow {
    display: none;
  }
}
/* Styling for the external metadata */
div#external-metadata {
  background-color: #eee;
  padding: 0.5em;
  margin-bottom: 0.5em;
  display: none;
}
div#internal-metadata {
  padding: 0.5em;                       /* to match the external-metadata padding */
}
/* Styling for title RFC Number */
h1#rfcnum {
  clear: both;
  margin: 0 0 -1em;
  padding: 1em 0 0 0;
}
/* Make .olPercent look the same as <ol><li> */
dl.olPercent > dd {
  margin-bottom: 0.25em;
  min-height: initial;
}
/* Give aside some styling to set it apart */
aside {
  border-left: 1px solid #ddd;
  margin: 1em 0 1em 2em;
  padding: 0.2em 2em;
}
aside > dl,
aside > ol,
aside > ul,
aside > table,
aside > p {
  margin-bottom: 0.5em;
}
/* Additional page break settings */
@media print {
  figcaption, table caption {
    page-break-before: avoid;
  }
}
/* Font size adjustments for print */
@media print {
  body  { font-size: 10pt;      line-height: normal; max-width: 96%; }
  h1    { font-size: 1.72em;    padding-top: 1.5em; } /* 1*1.2*1.2*1.2 */
  h2    { font-size: 1.44em;    padding-top: 1.5em; } /* 1*1.2*1.2 */
  h3    { font-size: 1.2em;     padding-top: 1.5em; } /* 1*1.2 */
  h4    { font-size: 1em;       padding-top: 1.5em; }
  h5, h6 { font-size: 1em;      margin: initial; padding: 0.5em 0 0.3em; }
}
/* Sourcecode margin in print, when there's no pilcrow */
@media print {
  .artwork,
  .artwork > pre,
  .sourcecode {
    margin-bottom: 1em;
  }
}
/* Avoid narrow tables forcing too narrow table captions, which may render badly */
table {
  min-width: 20em;
}
/* ol type a */
ol.type-a { list-style-type: lower-alpha; }
ol.type-A { list-style-type: upper-alpha; }
ol.type-i { list-style-type: lower-roman; }
ol.type-I { list-style-type: upper-roman; }
/* Apply the print table and row borders in general, on request from the RPC,
and increase the contrast between border and odd row background slightly */
table {
  border: 1px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
}
tr {
  break-inside: avoid;
}
tr:nth-child(2n+1) > td {
  background-color: #f8f8f8;
}
/* Use style rules to govern display of the TOC. */
@media screen and (max-width: 1023px) {
  #toc nav { display: none; }
  #toc.active nav { display: block; }
}
/* Add support for keepWithNext */
.keepWithNext {
  break-after: avoid-page;
  break-after: avoid-page;
}
/* Add support for keepWithPrevious */
.keepWithPrevious {
  break-before: avoid-page;
}
/* Change the approach to avoiding breaks inside artwork etc. */
figure, pre, table, .artwork, .sourcecode  {
  break-before: auto;
  break-after: auto;
}
/* Avoid breaks between <dt> and <dd> */
dl {
  break-before: auto;
  break-inside: auto;
}
dt {
  break-before: auto;
  break-after: avoid-page;
}
dd {
  break-before: avoid-page;
  break-after: auto;
  orphans: 3;
  widows: 3
}
span.break, dd.break {
  margin-bottom: 0;
  min-height: 0;
  break-before: auto;
  break-inside: auto;
  break-after: auto;
}
/* Undo break-before ToC */
@media print {
  #toc {
    break-before: auto;
  }
}
/* Text in compact lists should not get extra bottom margin space,
   since that would makes the list not compact */
ul.compact p, .ulCompact p,
ol.compact p, .olCompact p {
 margin: 0;
}
/* But the list as a whole needs the extra space at the end */
section ul.compact,
section .ulCompact,
section ol.compact,
section .olCompact {
  margin-bottom: 1em;                    /* same as p not within ul.compact etc. */
}
/* The tt and code background above interferes with for instance table cell
   backgrounds.  Changed to something a bit more selective. */
tt, code {
  background-color: transparent;
}
p tt, p code, li tt, li code, dt tt, dt code {
  background-color: #f8f8f8;
}
/* Tweak the pre margin -- 0px doesn't come out well */
pre {
   margin-top: 0.5px;
}
/* Tweak the compact list text */
ul.compact, .ulCompact,
ol.compact, .olCompact,
dl.compact, .dlCompact {
  line-height: normal;
}
/* Don't add top margin for nested lists */
li > ul, li > ol, li > dl,
dd > ul, dd > ol, dd > dl,
dl > dd > dl {
  margin-top: initial;
}
/* Elements that should not be rendered on the same line as a <dt> */
/* This should match the element list in writer.text.TextWriter.render_dl() */
dd > div.artwork:first-child,
dd > aside:first-child,
dd > figure:first-child,
dd > ol:first-child,
dd > div.sourcecode:first-child,
dd > table:first-child,
dd > ul:first-child {
  clear: left;
}
/* fix for weird browser behaviour when <dd/> is empty */
dt+dd:empty::before{
  content: "\00a0";
}
/* Make paragraph spacing inside <li> smaller than in body text, to fit better within the list */
li > p {
  margin-bottom: 0.5em
}
/* Don't let p margin spill out from inside list items */
li > p:last-of-type:only-child {
  margin-bottom: 0;
}
</style>
<link href="rfc-local.css" rel="stylesheet" type="text/css">
<link href="https://datatracker.ietf.org/doc/draft-ietf-taps-impl-18" rel="prev">
  <link href="https://dx.doi.org/10.17487/rfc9623" rel="alternate">
  <link href="urn:issn:2070-1721" rel="alternate">
  </head>
<body class="xml2rfc">
<script src="https://www.rfc-editor.org/js/metadata.min.js"></script>
<table class="ears">
<thead><tr>
<td class="left">RFC 9623</td>
<td class="center">Transport Services Implementation</td>
<td class="right">January 2025</td>
</tr></thead>
<tfoot><tr>
<td class="left">Brunstrom, et al.</td>
<td class="center">Informational</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-stream">Stream:</dt>
<dd class="stream">Internet Engineering Task Force (IETF)</dd>
<dt class="label-rfc">RFC:</dt>
<dd class="rfc"><a href="https://www.rfc-editor.org/rfc/rfc9623" class="eref">9623</a></dd>
<dt class="label-category">Category:</dt>
<dd class="category">Informational</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2025-01" class="published">January 2025</time>
    </dd>
<dt class="label-issn">ISSN:</dt>
<dd class="issn">2070-1721</dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">A. Brunstrom, <span class="editor">Ed.</span>
</div>
<div class="org">Karlstad University</div>
</div>
<div class="author">
      <div class="author-name">T. Pauly, <span class="editor">Ed.</span>
</div>
<div class="org">Apple Inc.</div>
</div>
<div class="author">
      <div class="author-name">R. Enghardt</div>
<div class="org">Netflix</div>
</div>
<div class="author">
      <div class="author-name">P.S. Tiesel</div>
<div class="org">SAP SE</div>
</div>
<div class="author">
      <div class="author-name">M. Welzl</div>
<div class="org">University of Oslo</div>
</div>
</dd>
</dl>
</div>
<h1 id="rfcnum">RFC 9623</h1>
<h1 id="title">Implementing Interfaces to Transport Services</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">The Transport Services System enables applications to use transport protocols flexibly for network communication
and defines a protocol-independent Transport Services Application Programming Interface (API) that is based on an asynchronous,
event-driven interaction pattern. This document serves as a guide to implementing such a system.<a href="#section-abstract-1" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
            This document is not an Internet Standards Track specification; it is
            published for informational purposes.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by the
            Internet Engineering Steering Group (IESG).  Not all documents
            approved by the IESG are candidates for any level of Internet
            Standard; see Section 2 of RFC 7841.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <span><a href="https://www.rfc-editor.org/info/rfc9623">https://www.rfc-editor.org/info/rfc9623</a></span>.<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2025 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents">
<a href="#name-table-of-contents" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1" class="keepWithNext"><a href="#section-1" class="auto internal xref">1</a>.  <a href="#name-introduction" class="internal xref">Introduction</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1" class="keepWithNext"><a href="#section-2" class="auto internal xref">2</a>.  <a href="#name-implementing-connection-obj" class="internal xref">Implementing Connection Objects</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a href="#section-3" class="auto internal xref">3</a>.  <a href="#name-implementing-preestablishme" class="internal xref">Implementing Preestablishment</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1">
                <p id="section-toc.1-1.3.2.1.1" class="keepWithNext"><a href="#section-3.1" class="auto internal xref">3.1</a>.  <a href="#name-configuration-time-errors" class="internal xref">Configuration-Time Errors</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2">
                <p id="section-toc.1-1.3.2.2.1"><a href="#section-3.2" class="auto internal xref">3.2</a>.  <a href="#name-role-of-system-policy" class="internal xref">Role of System Policy</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="auto internal xref">4</a>.  <a href="#name-implementing-connection-est" class="internal xref">Implementing Connection Establishment</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1">
                <p id="section-toc.1-1.4.2.1.1"><a href="#section-4.1" class="auto internal xref">4.1</a>.  <a href="#name-structuring-candidates-as-a" class="internal xref">Structuring Candidates as a Tree</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1.2.1">
                    <p id="section-toc.1-1.4.2.1.2.1.1"><a href="#section-4.1.1" class="auto internal xref">4.1.1</a>.  <a href="#name-branch-types" class="internal xref">Branch Types</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1.2.2">
                    <p id="section-toc.1-1.4.2.1.2.2.1"><a href="#section-4.1.2" class="auto internal xref">4.1.2</a>.  <a href="#name-branching-order-of-operatio" class="internal xref">Branching Order-of-Operations</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1.2.3">
                    <p id="section-toc.1-1.4.2.1.2.3.1"><a href="#section-4.1.3" class="auto internal xref">4.1.3</a>.  <a href="#name-sorting-branches" class="internal xref">Sorting Branches</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2">
                <p id="section-toc.1-1.4.2.2.1"><a href="#section-4.2" class="auto internal xref">4.2</a>.  <a href="#name-candidate-gathering" class="internal xref">Candidate Gathering</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.1">
                    <p id="section-toc.1-1.4.2.2.2.1.1"><a href="#section-4.2.1" class="auto internal xref">4.2.1</a>.  <a href="#name-gathering-endpoint-candidat" class="internal xref">Gathering Endpoint Candidates</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3">
                <p id="section-toc.1-1.4.2.3.1"><a href="#section-4.3" class="auto internal xref">4.3</a>.  <a href="#name-candidate-racing" class="internal xref">Candidate Racing</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3.2.1">
                    <p id="section-toc.1-1.4.2.3.2.1.1"><a href="#section-4.3.1" class="auto internal xref">4.3.1</a>.  <a href="#name-simultaneous" class="internal xref">Simultaneous</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3.2.2">
                    <p id="section-toc.1-1.4.2.3.2.2.1"><a href="#section-4.3.2" class="auto internal xref">4.3.2</a>.  <a href="#name-staggered" class="internal xref">Staggered</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3.2.3">
                    <p id="section-toc.1-1.4.2.3.2.3.1"><a href="#section-4.3.3" class="auto internal xref">4.3.3</a>.  <a href="#name-failover" class="internal xref">Failover</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.4">
                <p id="section-toc.1-1.4.2.4.1"><a href="#section-4.4" class="auto internal xref">4.4</a>.  <a href="#name-completing-establishment" class="internal xref">Completing Establishment</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.4.2.1">
                    <p id="section-toc.1-1.4.2.4.2.1.1"><a href="#section-4.4.1" class="auto internal xref">4.4.1</a>.  <a href="#name-determining-successful-esta" class="internal xref">Determining Successful Establishment</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.5">
                <p id="section-toc.1-1.4.2.5.1"><a href="#section-4.5" class="auto internal xref">4.5</a>.  <a href="#name-establishing-multiplexed-co" class="internal xref">Establishing Multiplexed Connections</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.6">
                <p id="section-toc.1-1.4.2.6.1"><a href="#section-4.6" class="auto internal xref">4.6</a>.  <a href="#name-handling-connectionless-pro" class="internal xref">Handling Connectionless Protocols</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.7">
                <p id="section-toc.1-1.4.2.7.1"><a href="#section-4.7" class="auto internal xref">4.7</a>.  <a href="#name-implementing-listeners" class="internal xref">Implementing Listeners</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.7.2.1">
                    <p id="section-toc.1-1.4.2.7.2.1.1"><a href="#section-4.7.1" class="auto internal xref">4.7.1</a>.  <a href="#name-implementing-listeners-for-" class="internal xref">Implementing Listeners for Connected Protocols</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.7.2.2">
                    <p id="section-toc.1-1.4.2.7.2.2.1"><a href="#section-4.7.2" class="auto internal xref">4.7.2</a>.  <a href="#name-implementing-listeners-for-c" class="internal xref">Implementing Listeners for Connectionless Protocols</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.7.2.3">
                    <p id="section-toc.1-1.4.2.7.2.3.1"><a href="#section-4.7.3" class="auto internal xref">4.7.3</a>.  <a href="#name-implementing-listeners-for-m" class="internal xref">Implementing Listeners for Multiplexed Protocols</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="auto internal xref">5</a>.  <a href="#name-implementing-sending-and-re" class="internal xref">Implementing Sending and Receiving Data</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.1">
                <p id="section-toc.1-1.5.2.1.1"><a href="#section-5.1" class="auto internal xref">5.1</a>.  <a href="#name-sending-messages" class="internal xref">Sending Messages</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.1.2.1">
                    <p id="section-toc.1-1.5.2.1.2.1.1"><a href="#section-5.1.1" class="auto internal xref">5.1.1</a>.  <a href="#name-message-properties" class="internal xref">Message Properties</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.1.2.2">
                    <p id="section-toc.1-1.5.2.1.2.2.1"><a href="#section-5.1.2" class="auto internal xref">5.1.2</a>.  <a href="#name-send-completion" class="internal xref">Send Completion</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.1.2.3">
                    <p id="section-toc.1-1.5.2.1.2.3.1"><a href="#section-5.1.3" class="auto internal xref">5.1.3</a>.  <a href="#name-batching-sends" class="internal xref">Batching Sends</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.2">
                <p id="section-toc.1-1.5.2.2.1"><a href="#section-5.2" class="auto internal xref">5.2</a>.  <a href="#name-receiving-messages" class="internal xref">Receiving Messages</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.3">
                <p id="section-toc.1-1.5.2.3.1"><a href="#section-5.3" class="auto internal xref">5.3</a>.  <a href="#name-handling-of-data-for-fast-o" class="internal xref">Handling of Data for Fast-Open Protocols</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="auto internal xref">6</a>.  <a href="#name-implementing-message-framer" class="internal xref">Implementing Message Framers</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1">
                <p id="section-toc.1-1.6.2.1.1"><a href="#section-6.1" class="auto internal xref">6.1</a>.  <a href="#name-defining-message-framers" class="internal xref">Defining Message Framers</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.2">
                <p id="section-toc.1-1.6.2.2.1"><a href="#section-6.2" class="auto internal xref">6.2</a>.  <a href="#name-sender-side-message-framing" class="internal xref">Sender-Side Message Framing</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.3">
                <p id="section-toc.1-1.6.2.3.1"><a href="#section-6.3" class="auto internal xref">6.3</a>.  <a href="#name-receiver-side-message-frami" class="internal xref">Receiver-Side Message Framing</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="auto internal xref">7</a>.  <a href="#name-implementing-connection-man" class="internal xref">Implementing Connection Management</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.1">
                <p id="section-toc.1-1.7.2.1.1"><a href="#section-7.1" class="auto internal xref">7.1</a>.  <a href="#name-pooled-connection" class="internal xref">Pooled Connection</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2">
                <p id="section-toc.1-1.7.2.2.1"><a href="#section-7.2" class="auto internal xref">7.2</a>.  <a href="#name-handling-path-changes" class="internal xref">Handling Path Changes</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#section-8" class="auto internal xref">8</a>.  <a href="#name-implementing-connection-ter" class="internal xref">Implementing Connection Termination</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#section-9" class="auto internal xref">9</a>.  <a href="#name-cached-state" class="internal xref">Cached State</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.1">
                <p id="section-toc.1-1.9.2.1.1"><a href="#section-9.1" class="auto internal xref">9.1</a>.  <a href="#name-protocol-state-caches" class="internal xref">Protocol State Caches</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.2">
                <p id="section-toc.1-1.9.2.2.1"><a href="#section-9.2" class="auto internal xref">9.2</a>.  <a href="#name-performance-caches" class="internal xref">Performance Caches</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a href="#section-10" class="auto internal xref">10</a>. <a href="#name-specific-transport-protocol" class="internal xref">Specific Transport Protocol Considerations</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10.2.1">
                <p id="section-toc.1-1.10.2.1.1"><a href="#section-10.1" class="auto internal xref">10.1</a>.  <a href="#name-tcp" class="internal xref">TCP</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10.2.2">
                <p id="section-toc.1-1.10.2.2.1"><a href="#section-10.2" class="auto internal xref">10.2</a>.  <a href="#name-mptcp" class="internal xref">MPTCP</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10.2.3">
                <p id="section-toc.1-1.10.2.3.1"><a href="#section-10.3" class="auto internal xref">10.3</a>.  <a href="#name-udp" class="internal xref">UDP</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10.2.4">
                <p id="section-toc.1-1.10.2.4.1"><a href="#section-10.4" class="auto internal xref">10.4</a>.  <a href="#name-udp-lite" class="internal xref">UDP-Lite</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10.2.5">
                <p id="section-toc.1-1.10.2.5.1"><a href="#section-10.5" class="auto internal xref">10.5</a>.  <a href="#name-udp-multicast-receive" class="internal xref">UDP Multicast Receive</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10.2.6">
                <p id="section-toc.1-1.10.2.6.1"><a href="#section-10.6" class="auto internal xref">10.6</a>.  <a href="#name-sctp" class="internal xref">SCTP</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a href="#section-11" class="auto internal xref">11</a>. <a href="#name-iana-considerations" class="internal xref">IANA Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a href="#section-12" class="auto internal xref">12</a>. <a href="#name-security-considerations" class="internal xref">Security Considerations</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.1">
                <p id="section-toc.1-1.12.2.1.1"><a href="#section-12.1" class="auto internal xref">12.1</a>.  <a href="#name-considerations-for-candidat" class="internal xref">Considerations for Candidate Gathering</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.2">
                <p id="section-toc.1-1.12.2.2.1"><a href="#section-12.2" class="auto internal xref">12.2</a>.  <a href="#name-considerations-for-candidate" class="internal xref">Considerations for Candidate Racing</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13">
            <p id="section-toc.1-1.13.1"><a href="#section-13" class="auto internal xref">13</a>. <a href="#name-references" class="internal xref">References</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13.2.1">
                <p id="section-toc.1-1.13.2.1.1"><a href="#section-13.1" class="auto internal xref">13.1</a>.  <a href="#name-normative-references" class="internal xref">Normative References</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13.2.2">
                <p id="section-toc.1-1.13.2.2.1"><a href="#section-13.2" class="auto internal xref">13.2</a>.  <a href="#name-informative-references" class="internal xref">Informative References</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14">
            <p id="section-toc.1-1.14.1"><a href="#appendix-A" class="auto internal xref">Appendix A</a>.  <a href="#name-api-mapping-template" class="internal xref">API Mapping Template</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.15">
            <p id="section-toc.1-1.15.1"><a href="#appendix-B" class="auto internal xref">Appendix B</a>.  <a href="#name-reasons-for-errors" class="internal xref">Reasons for Errors</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.16">
            <p id="section-toc.1-1.16.1"><a href="#appendix-C" class="auto internal xref">Appendix C</a>.  <a href="#name-existing-implementations" class="internal xref">Existing Implementations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.17">
            <p id="section-toc.1-1.17.1"><a href="#appendix-D" class="auto internal xref"></a><a href="#name-acknowledgements" class="internal xref">Acknowledgements</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.18">
            <p id="section-toc.1-1.18.1"><a href="#appendix-E" class="auto internal xref"></a><a href="#name-authors-addresses" class="internal xref">Authors' Addresses</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<div id="introduction">
<section id="section-1">
      <h2 id="name-introduction">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">The Transport Services Architecture <span>[<a href="#RFC9621" class="cite xref">RFC9621</a>]</span> defines a system that allows applications to flexibly use transport networking protocols. The API that such a system exposes to applications is defined as the Transport Services API <span>[<a href="#RFC9622" class="cite xref">RFC9622</a>]</span>. This API is designed to be generic across multiple transport protocols and sets of protocol features.<a href="#section-1-1" class="pilcrow">¶</a></p>
<p id="section-1-2">This document serves as a guide to implementing a system that provides a Transport Services API. This guide offers suggestions to developers, but it is not prescriptive: implementations are free to take any desired form as long as the API specification defined in <span>[<a href="#RFC9622" class="cite xref">RFC9622</a>]</span> is honored. It is the job of an implementation of a Transport Services System to turn the requests of an application into decisions on how to establish connections and how to transfer data over those connections once established. The terminology used in this document is based on the terminology defined in the Transport Services Architecture <span>[<a href="#RFC9621" class="cite xref">RFC9621</a>]</span>.<a href="#section-1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="implementing-connection-objects">
<section id="section-2">
      <h2 id="name-implementing-connection-obj">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-implementing-connection-obj" class="section-name selfRef">Implementing Connection Objects</a>
      </h2>
<p id="section-2-1">The Connection objects that are exposed to applications for Transport Services are:<a href="#section-2-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-2-2.1">
          <p id="section-2-2.1.1">the Preconnection, the bundle of Properties that describes the application constraints on, and preferences for, the transport;<a href="#section-2-2.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-2.2">
          <p id="section-2-2.2.1">the Connection, the basic object that represents a flow of data as Messages in either direction between the Local and Remote Endpoints;<a href="#section-2-2.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-2.3">
          <p id="section-2-2.3.1">and the Listener, a passive waiting object that delivers new Connections.<a href="#section-2-2.3.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-2-3">Preconnection objects should be implemented as bundles of Properties that an application can both read and write. A Preconnection object influences a Connection only at one point in time: when the Connection is created. Connection objects represent the interface between the application and the implementation to manage transport state and conduct data transfer. During the process of establishment (<a href="#conn-establish" class="auto internal xref">Section 4</a>), the Connection will not necessarily be immediately bound to a transport protocol instance, since multiple candidate Protocol Stacks might be raced.<a href="#section-2-3" class="pilcrow">¶</a></p>
<p id="section-2-4">Once a Preconnection has been used to create an outbound Connection or a Listener, the implementation should ensure that the copy of the Properties held by the Connection or Listener cannot be mutated by the application making changes to the original Preconnection object. This may involve the implementation performing a deep-copy, copying the object with all the objects that it references.<a href="#section-2-4" class="pilcrow">¶</a></p>
<p id="section-2-5">Once the Connection is established, the Transport Services Implementation maps actions and events to the details of the chosen Protocol Stack. For example, the same Connection object may ultimately represent a single transport protocol instance (e.g., a TCP connection, a TLS session over TCP, a UDP flow with fully specified Local and Remote Endpoint Identifiers, a DTLS session, a Stream Control Transmission Protocol (SCTP) stream, a QUIC stream, or an HTTP/2 stream).
The Connection Properties held by a Connection or Listener are independent of other Connections that are not part of the same Connection Group.<a href="#section-2-5" class="pilcrow">¶</a></p>
<p id="section-2-6">Connection establishment is only a local operation for connectionless protocols, which serves to simplify the local send/receive functions and to filter the traffic for the specified addresses and ports <span>[<a href="#RFC8085" class="cite xref">RFC8085</a>]</span> (for example, using UDP or UDP-Lite transport without a connection handshake procedure).<a href="#section-2-6" class="pilcrow">¶</a></p>
<p id="section-2-7">Once <code>Initiate</code> has been called, the Selection Properties and Endpoint information of the created Connection are immutable (i.e., an application is not able to later modify the Properties of a Connection by manipulating the original Preconnection object).
Listener objects are created with a Preconnection, at which point their configuration should be considered immutable by the implementation. The process of listening is described in <a href="#listen" class="auto internal xref">Section 4.7</a>.<a href="#section-2-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="implementing-pre-establishment">
<section id="section-3">
      <h2 id="name-implementing-preestablishme">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-implementing-preestablishme" class="section-name selfRef">Implementing Preestablishment</a>
      </h2>
<p id="section-3-1">The preestablishment phase allows applications to specify Properties for the Connections that they are about to make or to query the API about potential Connections they could make.<a href="#section-3-1" class="pilcrow">¶</a></p>
<p id="section-3-2">During preestablishment, the application specifies one or more Endpoints to be used for communication as well as protocol preferences and constraints via Selection Properties and, if desired, also Connection Properties. <span><a href="https://rfc-editor.org/rfc/rfc9622#section-4" class="relref">Section 4</a> of [<a href="#RFC9622" class="cite xref">RFC9622</a>]</span> states that Connection Properties should preferably be configured during preestablishment because they can serve as input to decisions that are made by the implementation (e.g., the capacity profile can guide usage of a protocol offering scavenger-type congestion control).<a href="#section-3-2" class="pilcrow">¶</a></p>
<p id="section-3-3">The implementation stores these Properties as a part of the Preconnection object for use during Connection establishment. For Selection Properties that are not provided by the application, the implementation uses the default values specified in the Transport Services API (<span>[<a href="#RFC9622" class="cite xref">RFC9622</a>]</span>).<a href="#section-3-3" class="pilcrow">¶</a></p>
<div id="configuration-time-errors">
<section id="section-3.1">
        <h3 id="name-configuration-time-errors">
<a href="#section-3.1" class="section-number selfRef">3.1. </a><a href="#name-configuration-time-errors" class="section-name selfRef">Configuration-Time Errors</a>
        </h3>
<p id="section-3.1-1">The Transport Services System should have a list of supported protocols available, each of which has transport features reflecting the capabilities of the protocol. Once an application specifies its Transport Properties, the Transport Services System matches the required and prohibited Properties against the transport features of the available protocols (see <span><a href="https://rfc-editor.org/rfc/rfc9622#section-6.2" class="relref">Section 6.2</a> of [<a href="#RFC9622" class="cite xref">RFC9622</a>]</span> for the definition of Property Preferences).<a href="#section-3.1-1" class="pilcrow">¶</a></p>
<p id="section-3.1-2">In the following cases, failure should be detected during preestablishment:<a href="#section-3.1-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.1-3.1">
            <p id="section-3.1-3.1.1">A request by an application for Properties that cannot be satisfied by any of the available protocols. For example, if an application requires <code>perMsgReliability</code>, but no such feature is available in any protocol on the host running the Transport Services System, this should result in an error.<a href="#section-3.1-3.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-3.1-3.2">
            <p id="section-3.1-3.2.1">A request by an application for Properties that are in conflict with each other, such as specifying required and prohibited Properties that cannot be satisfied by any protocol. For example, if an application prohibits <code>reliability</code> but then requires <code>perMsgReliability</code>, this mismatch should result in an error.<a href="#section-3.1-3.2.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-3.1-4">To avoid allocating resources that are not needed, it is important that configuration-time errors fail as early as possible.<a href="#section-3.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="role-of-system-policy">
<section id="section-3.2">
        <h3 id="name-role-of-system-policy">
<a href="#section-3.2" class="section-number selfRef">3.2. </a><a href="#name-role-of-system-policy" class="section-name selfRef">Role of System Policy</a>
        </h3>
<p id="section-3.2-1">The Properties specified during preestablishment have a close relationship to System Policy. The implementation is responsible for combining and reconciling several different sources of preferences when establishing Connections. These include, but are not limited to:<a href="#section-3.2-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-3.2-2">
<li id="section-3.2-2.1">
            <p id="section-3.2-2.1.1">Application preferences, i.e., preferences specified during preestablishment via Selection Properties.<a href="#section-3.2-2.1.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-3.2-2.2">
            <p id="section-3.2-2.2.1">Dynamic System Policy, i.e., policy compiled from internally and externally acquired information about available network interfaces, supported transport protocols, and current/previous Connections. Examples of ways to externally retrieve policy-support information are through OS-specific statistics/measurement tools and tools that reside on middleboxes and routers.<a href="#section-3.2-2.2.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-3.2-2.3">
            <p id="section-3.2-2.3.1">Default implementation policy, i.e., predefined policy by the OS or application.<a href="#section-3.2-2.3.1" class="pilcrow">¶</a></p>
</li>
        </ol>
<p id="section-3.2-3">In general, any protocol or path used for a Connection must conform to all three sources of constraints. A violation that occurs at any of the policy layers should cause a protocol or path to be considered ineligible for use. If such a violation prevents a Connection from being established, this should be communicated to the application, e.g., via the <code>EstablishmentError</code> event. For an example of application preferences leading to constraints, an application may prohibit the use of metered network interfaces for a given Connection to avoid user cost. Similarly, the System Policy at a given time may prohibit the use of such a metered network interface from the application's process. Lastly, the implementation itself may default to disallowing certain network interfaces unless explicitly requested by the application.<a href="#section-3.2-3" class="pilcrow">¶</a></p>
<p id="section-3.2-4">It is expected that the database of system policies and the method of looking up these policies will vary across various platforms. An implementation should attempt to look up the relevant policies for the system in a dynamic way to make sure it reflects an accurate version of the System Policy, since the system's policy regarding the application's traffic may change over time due to user or administrative changes.<a href="#section-3.2-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="conn-establish">
<section id="section-4">
      <h2 id="name-implementing-connection-est">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-implementing-connection-est" class="section-name selfRef">Implementing Connection Establishment</a>
      </h2>
<p id="section-4-1">The process of establishing a network connection begins when an application expresses intent to communicate with a Remote Endpoint by calling <code>Initiate</code>, at which point the Preconnection object contains all constraints or requirements the application has configured. The establishment process can be considered complete once there is at least one Protocol Stack that has completed any required setup to the point that it can transmit and receive the application's data.<a href="#section-4-1" class="pilcrow">¶</a></p>
<p id="section-4-2">Connection establishment is divided into two top-level steps:<a href="#section-4-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4-3.1">Candidate Gathering (defined in <span><a href="https://rfc-editor.org/rfc/rfc9621#section-4.2.1" class="relref">Section 4.2.1</a> of [<a href="#RFC9621" class="cite xref">RFC9621</a>]</span>) to identify the paths, protocols, and endpoints to use (see <a href="#gathering" class="auto internal xref">Section 4.2</a>) and<a href="#section-4-3.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-4-3.2">Candidate Racing (defined in <span><a href="https://rfc-editor.org/rfc/rfc9621#section-4.2.2" class="relref">Section 4.2.2</a> of [<a href="#RFC9621" class="cite xref">RFC9621</a>]</span>), in which the necessary protocol handshakes are conducted so that the Transport Services System can select which set to use (see <a href="#racing" class="auto internal xref">Section 4.3</a>).<a href="#section-4-3.2" class="pilcrow">¶</a>
</li>
      </ul>
<p id="section-4-4">Candidate Racing involves attempting multiple options for Connection establishment and choosing the first option to succeed as the Protocol Stack to use for the Connection.  These attempts are usually staggered, with each next option
   starting after a delay; however, they can also be performed in
   parallel or after failures occur.<a href="#section-4-4" class="pilcrow">¶</a></p>
<p id="section-4-5">For ease of illustration, this document structures the candidates for racing as a tree (see <a href="#tree-structure" class="auto internal xref">Section 4.1</a>).
      This is not meant to restrict implementations from structuring racing candidates differently.<a href="#section-4-5" class="pilcrow">¶</a></p>
<p id="section-4-6">The simplest example of this process might involve identifying the single IP address to which the implementation wishes to connect, using the system's current default path (i.e., using the default interface), and starting a TCP handshake to establish a stream to the specified IP address. However, each step may also differ depending on the requirements of the connection:<a href="#section-4-6" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4-7.1">if the Endpoint Identifier is a hostname and port, then there may be multiple resolved addresses that are available;<a href="#section-4-7.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-4-7.2">there may also be multiple paths available (in this case using an interface other than the default system interface); and<a href="#section-4-7.2" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-4-7.3">some protocols may not need any transport handshake to be considered "established" (such as UDP), while other connections may utilize layered protocol handshakes, such as TLS over TCP.<a href="#section-4-7.3" class="pilcrow">¶</a>
</li>
      </ul>
<p id="section-4-8">Whenever an implementation has multiple options for Connection establishment, it can view the set of all individual Connection establishment options as a single aggregate Connection establishment. The aggregate set conceptually includes every valid combination of endpoints, paths, and protocols. As an example, consider an implementation that initiates a TCP connection to a hostname + port Endpoint Identifier and that has two valid interfaces available (Wi-Fi and LTE). The hostname resolves to a single IPv4 address on the Wi-Fi network,
to the same IPv4 address on the LTE network, and to a single IPv6
address. The aggregate set of Connection establishment options can be viewed as follows, with the Endpoint Identifier abbreviated as "EId":<a href="#section-4-8" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4-9">
<pre>
Aggregate [EId: example.com:443] [Interface: Any]   [Protocol: TCP]
|-&gt; [EId: [3fff:23::1]:443]      [Interface: Wi-Fi] [Protocol: TCP]
|-&gt; [EId: 192.0.2.1:443]         [Interface: LTE]   [Protocol: TCP]
|-&gt; [EId: [3fff:42::1]:443]      [Interface: LTE]   [Protocol: TCP]
</pre><a href="#section-4-9" class="pilcrow">¶</a>
</div>
<p id="section-4-10">Any one of these subentries on the aggregate connection attempt would satisfy the original application intent. The concern of this section is the algorithm defining which of these options to try, when to try them, and in what order.<a href="#section-4-10" class="pilcrow">¶</a></p>
<p id="section-4-11">During Candidate Gathering (<a href="#gathering" class="auto internal xref">Section 4.2</a>), an implementation prunes and sorts branches according
to the Selection Property Preferences (<span><a href="https://rfc-editor.org/rfc/rfc9622#section-6.2" class="relref">Section 6.2</a> of [<a href="#RFC9622" class="cite xref">RFC9622</a>]</span>).
First, it excludes all protocols and paths that match a prohibited Property or do not
match all required Properties. Then, it will sort branches according to preferred
Properties, avoided Properties, and, possibly, other criteria.<a href="#section-4-11" class="pilcrow">¶</a></p>
<div id="tree-structure">
<section id="section-4.1">
        <h3 id="name-structuring-candidates-as-a">
<a href="#section-4.1" class="section-number selfRef">4.1. </a><a href="#name-structuring-candidates-as-a" class="section-name selfRef">Structuring Candidates as a Tree</a>
        </h3>
<p id="section-4.1-1">As noted above, the consideration of multiple candidates in a gathering and racing process can be conceptually structured as a tree; this terminological convention is used throughout this document.<a href="#section-4.1-1" class="pilcrow">¶</a></p>
<p id="section-4.1-2">Each leaf node of the tree represents a single coherent connection attempt with an endpoint, a network path, and a set of protocols that can directly negotiate and send data on the network. Each node in the tree that is not a leaf represents a connection attempt that is either underspecified or includes multiple distinct options. For example, when connecting on an IP network, a connection attempt to a hostname and port is underspecified because the connection attempt requires a resolved IP address as its Remote Endpoint Identifier. In this case, the node represented by the connection attempt to the hostname is a parent node with child nodes for each IP address. Similarly, an implementation that is allowed to connect using multiple interfaces will have a parent node of the tree for the decision between the network paths with a branch for each interface.<a href="#section-4.1-2" class="pilcrow">¶</a></p>
<p id="section-4.1-3">The example aggregate connection attempt above can be drawn as a tree by grouping the addresses resolved on the same interface into branches:<a href="#section-4.1-3" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.1-4">
<pre>
                            ||
              +============================+
               www.example.com:443/any path
              +============================+
                //                     \\
+=========================+      +=======================+
 www.example.com:443/Wi-Fi        www.example.com:443/LTE
+=========================+      +=======================+
            ||                      //               \\
+======================+  +=================+  +====================+
 [3fff:23::1]:443/Wi-Fi    192.0.2.1:443/LTE    [3fff:42::1]:443/LTE
+======================+  +=================+  +====================+
</pre><a href="#section-4.1-4" class="pilcrow">¶</a>
</div>
<p id="section-4.1-5">The rest of this section will use a notation scheme to represent this tree. The root node (or parent node) of the tree will be represented by a single integer, such as "1". ("1" is used assuming that this is the first connection made by the system; future connections created by the application would allocate numbers in an increasing manner.) Each child of that node will have an integer that identifies it, from 1 to the number of children. That child node will be uniquely identified by concatenating its integer to its parent's identifier with a dot character ("<code>.</code>") in between, such as "1.1" and "1.2". Each node will be summarized by a tuple of three elements: endpoint, path (labeled here by interface), and protocol. In Protocol Stacks, the layers are separated by a slash character ("<code>/</code>") and ordered with the protocol closest to the application first. The above example can now be written more succinctly as:<a href="#section-4.1-5" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.1-6">
<pre>
1 [www.example.com:443, any path, TCP]
  1.1 [www.example.com:443, Wi-Fi, TCP]
    1.1.1 [[2001:db8:23::1]:443, Wi-Fi, TCP]
  1.2 [www.example.com:443, LTE, TCP]
    1.2.1 [192.0.2.1:443, LTE, TCP]
    1.2.2 [[2001:db8.42::1]:443, LTE, TCP]
</pre><a href="#section-4.1-6" class="pilcrow">¶</a>
</div>
<p id="section-4.1-7">When an implementation is asked to establish a single connection, only one of the leaf nodes in the candidate set is needed to transfer data. Thus, once a single leaf node becomes ready to use, the Connection establishment tree is considered ready. One way to implement this is by having every leaf node update the state of its parent node when it becomes ready until the root node of the tree is ready, which then notifies the application that the Connection as a whole is ready to use.<a href="#section-4.1-7" class="pilcrow">¶</a></p>
<p id="section-4.1-8">A Connection establishment tree may consist of only a single node, such as a connection attempt to an IP address over a single interface with a single protocol.<a href="#section-4.1-8" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.1-9">
<pre>
1 [[2001:db8:23::1]:443, Wi-Fi, TCP]
</pre><a href="#section-4.1-9" class="pilcrow">¶</a>
</div>
<p id="section-4.1-10">A root node may also only have one child (or leaf) node, such as a when a hostname resolves to only a single IP address.<a href="#section-4.1-10" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.1-11">
<pre>
1 [www.example.com:443, Wi-Fi, TCP]
  1.1 [[2001:db8:23::1]:443, Wi-Fi, TCP]
</pre><a href="#section-4.1-11" class="pilcrow">¶</a>
</div>
<div id="branch-types">
<section id="section-4.1.1">
          <h4 id="name-branch-types">
<a href="#section-4.1.1" class="section-number selfRef">4.1.1. </a><a href="#name-branch-types" class="section-name selfRef">Branch Types</a>
          </h4>
<p id="section-4.1.1-1"> There are three types of branching from a parent node into one or
  more child nodes: Derived Endpoints, network paths, and protocol options.
  Any parent node of the tree must use only one type
  of branching.<a href="#section-4.1.1-1" class="pilcrow">¶</a></p>
<div id="derived-endpoints">
<section id="section-4.1.1.1">
            <h5 id="name-derived-endpoints">
<a href="#section-4.1.1.1" class="section-number selfRef">4.1.1.1. </a><a href="#name-derived-endpoints" class="section-name selfRef">Derived Endpoints</a>
            </h5>
<p id="section-4.1.1.1-1">If a connection originally targets a single Endpoint Identifier, there may be multiple endpoint candidates of different types that can be derived from the original. This creates an ordered list of the derived endpoint candidates according to application preference, System Policy, and expected performance.<a href="#section-4.1.1.1-1" class="pilcrow">¶</a></p>
<p id="section-4.1.1.1-2">DNS hostname-to-address resolution is the most common method of endpoint derivation. When trying to connect to a hostname Endpoint Identifier on an IP network, the implementation should send all applicable DNS queries. Commonly, this will include both A (IPv4) and AAAA (IPv6) records if both address families are supported on the local interface. This can also include SRV records <span>[<a href="#RFC2782" class="cite xref">RFC2782</a>]</span>, SVCB and HTTPS records <span>[<a href="#RFC9460" class="cite xref">RFC9460</a>]</span>, or other future record types. The algorithm for ordering and racing these addresses should follow the recommendations in Happy Eyeballs <span>[<a href="#RFC8305" class="cite xref">RFC8305</a>]</span>.<a href="#section-4.1.1.1-2" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.1.1.1-3">
<pre>
1 [www.example.com:443, Wi-Fi, TCP]
  1.1 [[2001:db8::1]:443, Wi-Fi, TCP]
  1.2 [192.0.2.1:443, Wi-Fi, TCP]
  1.3 [[2001:db8::2]:443, Wi-Fi, TCP]
  1.4 [[2001:db8::3]:443, Wi-Fi, TCP]
</pre><a href="#section-4.1.1.1-3" class="pilcrow">¶</a>
</div>
<p id="section-4.1.1.1-4">DNS-Based Service Discovery <span>[<a href="#RFC6763" class="cite xref">RFC6763</a>]</span> can also provide an endpoint derivation step. When trying to connect to a named service, the client may discover one or more hostname and port pairs on the local network using multicast DNS <span>[<a href="#RFC6762" class="cite xref">RFC6762</a>]</span>. These hostnames should each be treated as a branch that can be attempted independently from other hostnames. Each of these hostnames might resolve to one or more addresses, which would create multiple layers of branching.<a href="#section-4.1.1.1-4" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.1.1.1-5">
<pre>
1 [term-printer._ipp._tcp.meeting.example.com, Wi-Fi, TCP]
  1.1 [term-printer.meeting.example.com:631, Wi-Fi, TCP]
    1.1.1 [31.133.160.18:631, Wi-Fi, TCP]
</pre><a href="#section-4.1.1.1-5" class="pilcrow">¶</a>
</div>
<p id="section-4.1.1.1-6">Applications can influence which derived Endpoints are allowed and preferred via Selection Properties set on the Preconnection. For example, setting a preference for <code>useTemporaryLocalAddress</code> would prefer the use of IPv6 over IPv4, and requiring <code>useTemporaryLocalAddress</code> would eliminate IPv4 options since IPv4 does not support temporary addresses.<a href="#section-4.1.1.1-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="network-paths">
<section id="section-4.1.1.2">
            <h5 id="name-network-paths">
<a href="#section-4.1.1.2" class="section-number selfRef">4.1.1.2. </a><a href="#name-network-paths" class="section-name selfRef">Network Paths</a>
            </h5>
<p id="section-4.1.1.2-1">If a client has multiple network paths available to it, e.g., a mobile client with interfaces for both Wi-Fi and Cellular connectivity, it can attempt a connection over any of the paths. This represents a branch point in the Connection establishment. Similar to a derived endpoint, the paths should be ranked based on preference, policy, and performance. Attempts should be started on one path (e.g., a specific interface) and then successively on other paths (or interfaces) after delays based on the expected path RTT or other available metrics.<a href="#section-4.1.1.2-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.1.1.2-2">
<pre>
1 [192.0.2.1:443, any path, TCP]
  1.1 [192.0.2.1:443, Wi-Fi, TCP]
  1.2 [192.0.2.1:443, LTE, TCP]
</pre><a href="#section-4.1.1.2-2" class="pilcrow">¶</a>
</div>
<p id="section-4.1.1.2-3">The same approach applies to any situation in which the client is aware of multiple links or views of the network. A single interface may be shared by
multiple network paths, each with a coherent set of addresses, routes, DNS server, and more. A path may also represent a virtual interface service such as a Virtual Private Network (VPN).<a href="#section-4.1.1.2-3" class="pilcrow">¶</a></p>
<p id="section-4.1.1.2-4">The list of available paths should be constrained by any requirements the application sets as well as by the System Policy.<a href="#section-4.1.1.2-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="protocol-options">
<section id="section-4.1.1.3">
            <h5 id="name-protocol-options">
<a href="#section-4.1.1.3" class="section-number selfRef">4.1.1.3. </a><a href="#name-protocol-options" class="section-name selfRef">Protocol Options</a>
            </h5>
<p id="section-4.1.1.3-1">Differences in possible protocol compositions and options can also provide a branching point in Connection establishment. This allows clients to be resilient to situations in which a certain protocol is not functioning on a server or network.<a href="#section-4.1.1.3-1" class="pilcrow">¶</a></p>
<p id="section-4.1.1.3-2">This approach is commonly used for connections with optional proxy server configurations. A single connection might have several options available: an HTTP-based proxy, a SOCKS-based proxy, or no proxy. As above, these options should be ranked based on preference, System Policy, and performance, and should be attempted in succession.<a href="#section-4.1.1.3-2" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.1.1.3-3">
<pre>
1 [www.example.com:443, any path, HTTP/TCP]
  1.1 [192.0.2.8:443, any path, HTTP/HTTP Proxy/TCP]
  1.2 [192.0.2.7:10234, any path, HTTP/SOCKS/TCP]
  1.3 [www.example.com:443, any path, HTTP/TCP]
    1.3.1 [192.0.2.1:443, any path, HTTP/TCP]
</pre><a href="#section-4.1.1.3-3" class="pilcrow">¶</a>
</div>
<p id="section-4.1.1.3-4">This approach also allows a client to attempt different sets of application and transport protocols that, when available, could provide preferable features. For example, the protocol options could involve QUIC <span>[<a href="#RFC9000" class="cite xref">RFC9000</a>]</span> over UDP on one branch and HTTP/2 <span>[<a href="#RFC9113" class="cite xref">RFC9113</a>]</span> over TLS over TCP on the other:<a href="#section-4.1.1.3-4" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.1.1.3-5">
<pre>
1 [www.example.com:443, any path, HTTP]
  1.1 [www.example.com:443, any path, HTTP3/QUIC/UDP]
    1.1.1 [192.0.2.1:443, any path, HTTP3/QUIC/UDP]
  1.2 [www.example.com:443, any path, HTTP2/TLS/TCP]
    1.2.1 [192.0.2.1:443, any path, HTTP2/TLS/TCP]
</pre><a href="#section-4.1.1.3-5" class="pilcrow">¶</a>
</div>
<p id="section-4.1.1.3-6">Another example is racing SCTP with TCP:<a href="#section-4.1.1.3-6" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.1.1.3-7">
<pre>
1 [www.example.com:4740, any path, reliable-inorder-stream]
  1.1 [www.example.com:4740, any path, SCTP]
    1.1.1 [192.0.2.1:4740, any path, SCTP]
  1.2 [www.example.com:4740, any path, TCP]
    1.2.1 [192.0.2.1:4740, any path, TCP]
</pre><a href="#section-4.1.1.3-7" class="pilcrow">¶</a>
</div>
<p id="section-4.1.1.3-8">Implementations that support racing protocols and protocol options should maintain a history of which protocols and protocol options were successfully established on a per-network and per-endpoint basis (see <a href="#performance-caches" class="auto internal xref">Section 9.2</a>). This information can influence future racing decisions to prioritize or prune branches.<a href="#section-4.1.1.3-8" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="branching-order-of-operations">
<section id="section-4.1.2">
          <h4 id="name-branching-order-of-operatio">
<a href="#section-4.1.2" class="section-number selfRef">4.1.2. </a><a href="#name-branching-order-of-operatio" class="section-name selfRef">Branching Order-of-Operations</a>
          </h4>
<p id="section-4.1.2-1">Branch types ought to occur in a specific order relative to one another to avoid creating leaf nodes with invalid or incompatible settings. In the example above, it would be invalid to branch for derived endpoints (the DNS results for www.example.com) before branching between interface paths since there are situations when the results will be different across networks due to private names or different supported IP versions. Implementations need to be careful to branch in a consistent order that results in usable leaf nodes whenever there are multiple branch types that could be used from a single node.<a href="#section-4.1.2-1" class="pilcrow">¶</a></p>
<p id="section-4.1.2-2">This document recommends the following order of operations for branching:<a href="#section-4.1.2-2" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.2-3">
<li id="section-4.1.2-3.1">
              <p id="section-4.1.2-3.1.1">Network paths<a href="#section-4.1.2-3.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.2-3.2">
              <p id="section-4.1.2-3.2.1">Protocol options<a href="#section-4.1.2-3.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.2-3.3">
              <p id="section-4.1.2-3.3.1">Derived Endpoints<a href="#section-4.1.2-3.3.1" class="pilcrow">¶</a></p>
</li>
          </ol>
<p id="section-4.1.2-4">where a lower number indicates higher precedence and, therefore, higher placement in the tree. Branching between paths is the first in the list because results across multiple interfaces are likely not related to one another: endpoint resolution may return different results, especially when using locally resolved host and service names and the protocols that are supported and preferred may differ across interfaces. Thus, if multiple paths are attempted, the overall Connection establishment process can be seen as a race between the available paths or interfaces.<a href="#section-4.1.2-4" class="pilcrow">¶</a></p>
<p id="section-4.1.2-5">Protocol options are next checked in order. Whether or not a set of protocols, or protocol-specific options, can successfully connect is generally not dependent on which specific IP address is used. Furthermore, the Protocol Stacks being attempted may influence or altogether change the Endpoint Identifiers being used. Adding a proxy to a connection's branch will change the Endpoint Identifier to the proxy's IP address or hostname. Choosing an alternate protocol may also modify the ports that should be selected.<a href="#section-4.1.2-5" class="pilcrow">¶</a></p>
<p id="section-4.1.2-6">Branching for derived endpoints is the final step and may have multiple layers of derivation or resolution, such as DNS service resolution and DNS hostname resolution.<a href="#section-4.1.2-6" class="pilcrow">¶</a></p>
<p id="section-4.1.2-7">For example, if the application has indicated both a preference for Wi-Fi over LTE and for a feature only available in SCTP, branches will first be sorted according to path selection, with Wi-Fi attempted as the first path. Then, branches with SCTP will be attempted within their subtree according to the Properties influencing protocol selection. However, if the implementation has current cache information that SCTP is not available on the path over Wi-Fi, there would be no SCTP node in the Wi-Fi subtree. Here, the path over Wi-Fi will be attempted first, and, if connection establishment succeeds, TCP will be used. Thus, the Selection Property preferring Wi-Fi takes precedence over the Property that led to a preference for SCTP.<a href="#section-4.1.2-7" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.1.2-8">
<pre>
1. [www.example.com:80, any path, reliable-inorder-stream]
1.1 [192.0.2.1:443, Wi-Fi, reliable-inorder-stream]
1.1.1 [192.0.2.1:443, Wi-Fi, TCP]
1.2 [192.0.3.1:443, LTE, reliable-inorder-stream]
1.2.1 [192.0.3.1:443, LTE, SCTP]
1.2.2 [192.0.3.1:443, LTE, TCP]
</pre><a href="#section-4.1.2-8" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="branch-sorting">
<section id="section-4.1.3">
          <h4 id="name-sorting-branches">
<a href="#section-4.1.3" class="section-number selfRef">4.1.3. </a><a href="#name-sorting-branches" class="section-name selfRef">Sorting Branches</a>
          </h4>
<p id="section-4.1.3-1">Implementations should sort the branches of the tree of connection options in order of their preference rank from most preferred to least preferred as
specified by Selection Properties <span>[<a href="#RFC9622" class="cite xref">RFC9622</a>]</span>.
Leaf nodes on branches with higher rankings represent connection attempts that will be raced first.<a href="#section-4.1.3-1" class="pilcrow">¶</a></p>
<p id="section-4.1.3-2">In addition to the Properties provided by the application, an implementation may include additional criteria such as cached performance estimates (see <a href="#performance-caches" class="auto internal xref">Section 9.2</a>) or System Policy (see <a href="#role-of-system-policy" class="auto internal xref">Section 3.2</a>) in the ranking.
Two examples of how Selection and Connection Properties may be used to sort branches are provided below:<a href="#section-4.1.3-2" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlNewline" id="section-4.1.3-3">
            <dt id="section-4.1.3-3.1">"Interface Instance or Type" (Property name <code>interface</code>):</dt>
            <dd style="margin-left: 1.5em" id="section-4.1.3-3.2">If the application specifies an interface type to be preferred or avoided, implementations should accordingly rank the paths.
If the application specifies an interface type to be required or prohibited, an implementation is expected to exclude the nonconforming paths.<a href="#section-4.1.3-3.2" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-4.1.3-3.3">"Capacity Profile" (Property name <code>connCapacityProfile</code>):</dt>
            <dd style="margin-left: 1.5em" id="section-4.1.3-3.4">
              <p id="section-4.1.3-3.4.1">An implementation can use the capacity profile to prefer paths that match an application's expected traffic profile. This match will use cached performance estimates; see <a href="#performance-caches" class="auto internal xref">Section 9.2</a>. Some examples of path preferences based on capacity profiles include:<a href="#section-4.1.3-3.4.1" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-4.1.3-3.4.2">
                <dt id="section-4.1.3-3.4.2.1"><code>Low Latency/Interactive:</code></dt>
                <dd style="margin-left: 1.5em" id="section-4.1.3-3.4.2.2">Prefer paths with the lowest expected Round-Trip Time (RTT), based on observed RTT estimates;<a href="#section-4.1.3-3.4.2.2" class="pilcrow">¶</a>
</dd>
                <dd class="break"></dd>
<dt id="section-4.1.3-3.4.2.3"><code>Low Latency/Non-Interactive:</code></dt>
                <dd style="margin-left: 1.5em" id="section-4.1.3-3.4.2.4">Prefer paths with a low expected Round-Trip Time (RTT) and possible delay variation;<a href="#section-4.1.3-3.4.2.4" class="pilcrow">¶</a>
</dd>
                <dd class="break"></dd>
<dt id="section-4.1.3-3.4.2.5"><code>Constant-Rate Streaming:</code></dt>
                <dd style="margin-left: 1.5em" id="section-4.1.3-3.4.2.6">Prefer paths that are expected to satisfy the requested stream send or receive bitrate based on the observed maximum throughput;<a href="#section-4.1.3-3.4.2.6" class="pilcrow">¶</a>
</dd>
                <dd class="break"></dd>
<dt id="section-4.1.3-3.4.2.7"><code>Capacity-Seeking:</code></dt>
                <dd style="margin-left: 1.5em" id="section-4.1.3-3.4.2.8">Prefer adapting to paths to determine the highest available capacity based on the observed maximum throughput.<a href="#section-4.1.3-3.4.2.8" class="pilcrow">¶</a>
</dd>
              <dd class="break"></dd>
</dl>
</dd>
          <dd class="break"></dd>
</dl>
<p id="section-4.1.3-4">As another example, branch sorting can also be influenced by bounds on the send or receive rate (Selection Properties <code>minSendRate</code> / <code>minRecvRate</code> / <code>maxSendRate</code> / <code>maxRecvRate</code>): if the application indicates a bound on the expected send or receive bitrate, an implementation may prefer a path that can likely provide the desired bandwidth, based on cached maximum throughput (see <a href="#performance-caches" class="auto internal xref">Section 9.2</a>). The application may know the send or receive bitrate from metadata in adaptive HTTP streaming, such as MPEG-DASH.<a href="#section-4.1.3-4" class="pilcrow">¶</a></p>
<p id="section-4.1.3-5">Implementations process the Properties (<span><a href="https://rfc-editor.org/rfc/rfc9622#section-6.2" class="relref">Section 6.2</a> of [<a href="#RFC9622" class="cite xref">RFC9622</a>]</span>) in the following order: <code>Prohibit</code>, <code>Require</code>, <code>Prefer</code>, <code>Avoid</code>.
If Selection Properties contain any prohibited Properties, the implementation should first purge branches containing nodes with these Properties. For required Properties, it should only keep branches that satisfy these requirements. Finally, it should order the branches according to the preferred Properties and use any avoided Properties as a tiebreaker.
When ordering branches, an implementation can give more weight to Properties that the application has explicitly set rather than to the Properties that are set by default.<a href="#section-4.1.3-5" class="pilcrow">¶</a></p>
<p id="section-4.1.3-6">The available protocols and paths on a specific system and in a specific context can change; therefore, the result of sorting and the outcome of racing may vary, even when using the same Selection and Connection Properties. However, an implementation ought to provide a consistent outcome to applications, e.g., by preferring protocols and paths that are already used by existing Connections that specified similar Properties.<a href="#section-4.1.3-6" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="gathering">
<section id="section-4.2">
        <h3 id="name-candidate-gathering">
<a href="#section-4.2" class="section-number selfRef">4.2. </a><a href="#name-candidate-gathering" class="section-name selfRef">Candidate Gathering</a>
        </h3>
<p id="section-4.2-1">The step of gathering candidates involves identifying which paths, protocols, and endpoints may be used for a given Connection. This list is determined by the requirements, prohibitions, preferences, and avoidances of the application as specified in the Selection Properties.<a href="#section-4.2-1" class="pilcrow">¶</a></p>
<div id="gathering-endpoint-candidates">
<section id="section-4.2.1">
          <h4 id="name-gathering-endpoint-candidat">
<a href="#section-4.2.1" class="section-number selfRef">4.2.1. </a><a href="#name-gathering-endpoint-candidat" class="section-name selfRef">Gathering Endpoint Candidates</a>
          </h4>
<p id="section-4.2.1-1">Both Local and Remote Endpoint Candidates must be discovered during Connection establishment.  To support Interactive Connectivity Establishment (ICE) <span>[<a href="#RFC8445" class="cite xref">RFC8445</a>]</span>, or similar protocols that involve out-of-band indirect signaling to exchange candidates with the Remote Endpoint, it is important to query the set of candidate Local Endpoints and provide the Protocol Stack with a set of candidate Remote Endpoints before the Local Endpoint attempts to establish connections.<a href="#section-4.2.1-1" class="pilcrow">¶</a></p>
<div id="local-endpoint-candidates">
<section id="section-4.2.1.1">
            <h5 id="name-local-endpoint-candidates">
<a href="#section-4.2.1.1" class="section-number selfRef">4.2.1.1. </a><a href="#name-local-endpoint-candidates" class="section-name selfRef">Local Endpoint Candidates</a>
            </h5>
<p id="section-4.2.1.1-1">The set of possible Local Endpoints is gathered.  In a simple case, this merely enumerates the local interfaces and protocols and allocates ephemeral source ports.  For example, a system that has Wi-Fi and Ethernet and supports IPv4 and IPv6 might gather four candidate Local Endpoints (IPv4 on Ethernet, IPv6 on Ethernet, IPv4 on Wi-Fi, and IPv6 on Wi-Fi) that can form the source for a transient.<a href="#section-4.2.1.1-1" class="pilcrow">¶</a></p>
<p id="section-4.2.1.1-2">If NAT traversal is required, the process of gathering Local Endpoints becomes broadly equivalent to the ICE Candidate Gathering phase (see <span><a href="https://rfc-editor.org/rfc/rfc8445#section-5.1.1" class="relref">Section 5.1.1</a> of [<a href="#RFC8445" class="cite xref">RFC8445</a>]</span>).  The endpoint determines its server-reflexive Local Endpoints (i.e., the translated address of a Local Endpoint, on the other side of a NAT, e.g., via a STUN server <span>[<a href="#RFC8489" class="cite xref">RFC8489</a>]</span>) and relayed Local Endpoints (e.g., via a TURN server <span>[<a href="#RFC8656" class="cite xref">RFC8656</a>]</span> or other relay) for each interface and network protocol.  These are added to the set of candidate Local Endpoint Identifiers for this connection.<a href="#section-4.2.1.1-2" class="pilcrow">¶</a></p>
<p id="section-4.2.1.1-3">Gathering Local Endpoints is primarily a local operation, although it might involve exchanges with a STUN server to derive server-reflexive Local Endpoints or with a TURN server or other relay to derive relayed Local Endpoints.  However, it does not involve communication with the Remote Endpoint.<a href="#section-4.2.1.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="remote-endpoint-candidates">
<section id="section-4.2.1.2">
            <h5 id="name-remote-endpoint-candidates">
<a href="#section-4.2.1.2" class="section-number selfRef">4.2.1.2. </a><a href="#name-remote-endpoint-candidates" class="section-name selfRef">Remote Endpoint Candidates</a>
            </h5>
<p id="section-4.2.1.2-1">The Remote Endpoint Identifier is typically a name that needs to be resolved into a set of possible addresses that can be used for communication.  Resolving the Remote Endpoint is the process of recursively performing such name lookups, until fully resolved, to return the set of candidates for the Remote Endpoint of this Connection.<a href="#section-4.2.1.2-1" class="pilcrow">¶</a></p>
<p id="section-4.2.1.2-2">How this resolution is done will depend on the type of the Remote Endpoint and can also be specific to each Local Endpoint.  A common case is when the Remote Endpoint Identifier is a DNS name, in which case, it is resolved to give a set of IPv4 and IPv6 addresses representing that name.  Some types of Remote Endpoint Identifiers might require more complex resolution.  Resolving the Remote Endpoint for a peer-to-peer connection might involve communication with a rendezvous server.  The server, in turn, contacts the peer to gain consent to communicate and retrieve its set of candidate Local Endpoints. These Endpoints are returned and form the candidate remote addresses for contacting that peer.<a href="#section-4.2.1.2-2" class="pilcrow">¶</a></p>
<p id="section-4.2.1.2-3">Resolving the Remote Endpoint is not a local operation.  It will involve a directory service and can require communication
between the Remote Endpoint and a rendezvous server as well as the
exchange of peer addresses.  This can expose some or all of the candidate Local Endpoints to the Remote Endpoint.<a href="#section-4.2.1.2-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="racing">
<section id="section-4.3">
        <h3 id="name-candidate-racing">
<a href="#section-4.3" class="section-number selfRef">4.3. </a><a href="#name-candidate-racing" class="section-name selfRef">Candidate Racing</a>
        </h3>
<p id="section-4.3-1">The primary goal of the Candidate Racing process is to successfully negotiate a Protocol Stack to an Endpoint over an interface to connect a single leaf node of the tree with as little delay and as few unnecessary connection attempts as possible. Optimizing these two factors improves the user experience, while minimizing network load.<a href="#section-4.3-1" class="pilcrow">¶</a></p>
<p id="section-4.3-2">This section covers the dynamic aspect of Connection establishment. The tree described above is a useful conceptual and architectural model. However, an implementation is unable to know all of the nodes that will be used until steps like name resolution have occurred; many of the possible branches ultimately might not be attempted.<a href="#section-4.3-2" class="pilcrow">¶</a></p>
<p id="section-4.3-3">There are three different approaches to racing the attempts for different nodes of the Connection establishment tree:<a href="#section-4.3-3" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.3-4">
<li id="section-4.3-4.1">
            <p id="section-4.3-4.1.1">Simultaneous<a href="#section-4.3-4.1.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.3-4.2">
            <p id="section-4.3-4.2.1">Staggered<a href="#section-4.3-4.2.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.3-4.3">
            <p id="section-4.3-4.3.1">Failover<a href="#section-4.3-4.3.1" class="pilcrow">¶</a></p>
</li>
        </ol>
<p id="section-4.3-5">Each approach is appropriate in different use cases and branch types. However, to avoid consuming unnecessary network resources, implementations should not use simultaneous racing as a default approach.<a href="#section-4.3-5" class="pilcrow">¶</a></p>
<p id="section-4.3-6">The timing algorithms for racing should remain independent across branches of the tree. Any timer or racing logic is isolated to a given parent node and is not ordered precisely with regard to children of other nodes.<a href="#section-4.3-6" class="pilcrow">¶</a></p>
<div id="simultaneous">
<section id="section-4.3.1">
          <h4 id="name-simultaneous">
<a href="#section-4.3.1" class="section-number selfRef">4.3.1. </a><a href="#name-simultaneous" class="section-name selfRef">Simultaneous</a>
          </h4>
<p id="section-4.3.1-1">Simultaneous racing is when multiple alternate branches are started without waiting for any one branch to make progress before starting the next alternative. This means the attempts are effectively simultaneous. Simultaneous racing should be avoided by implementations since it consumes extra network resources and establishes state that might not be used.<a href="#section-4.3.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="staggered">
<section id="section-4.3.2">
          <h4 id="name-staggered">
<a href="#section-4.3.2" class="section-number selfRef">4.3.2. </a><a href="#name-staggered" class="section-name selfRef">Staggered</a>
          </h4>
<p id="section-4.3.2-1">Staggered racing can be used whenever a single node of the tree has multiple child nodes. Based on the order determined when building the tree, the first child node will be initiated immediately, followed by the next child node after some delay. Once that second child node is initiated, the third child node (if present) will begin after another delay, and so on until all child nodes have been initiated or one of the child nodes successfully completes its negotiation.<a href="#section-4.3.2-1" class="pilcrow">¶</a></p>
<p id="section-4.3.2-2">Staggered racing attempts can proceed in parallel. Implementations should not terminate an earlier child connection attempt upon starting a secondary child.<a href="#section-4.3.2-2" class="pilcrow">¶</a></p>
<p id="section-4.3.2-3">If a child node fails to establish connectivity (as in <a href="#determining-successful-establishment" class="auto internal xref">Section 4.4.1</a>) before the delay time has expired for the next child, the next child should be started immediately.<a href="#section-4.3.2-3" class="pilcrow">¶</a></p>
<p id="section-4.3.2-4">Staggered racing between IP addresses for a generic Connection should follow the Happy Eyeballs algorithm described in <span>[<a href="#RFC8305" class="cite xref">RFC8305</a>]</span>. Guidance for racing when performing ICE can be found in <span>[<a href="#RFC8421" class="cite xref">RFC8421</a>]</span>.<a href="#section-4.3.2-4" class="pilcrow">¶</a></p>
<p id="section-4.3.2-5">Generally, the delay before starting a given child node ought to be based on the length of time the previously started child node is expected to take before it succeeds or makes progress in connection establishment. Algorithms like Happy Eyeballs choose a delay based on how long the transport connection handshake is expected to take. When performing staggered races in multiple branch types (such as racing between network interfaces and then racing between IP addresses), a longer delay may be chosen for some branch types. For example, when racing between network interfaces, the delay should also take into account the amount of time it takes to prepare the network interface (such as radio association) and name resolution over that interface in addition to the delay that would be added for a single transport connection handshake.<a href="#section-4.3.2-5" class="pilcrow">¶</a></p>
<p id="section-4.3.2-6">Since the staggered delay can be chosen based on dynamic information, such as predicted RTT, implementations should define upper and lower bounds for delay times. These bounds are implementation specific and may differ based on which branch type is being used.<a href="#section-4.3.2-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="failover">
<section id="section-4.3.3">
          <h4 id="name-failover">
<a href="#section-4.3.3" class="section-number selfRef">4.3.3. </a><a href="#name-failover" class="section-name selfRef">Failover</a>
          </h4>
<p id="section-4.3.3-1">If an implementation or application has a strong preference for one branch over another, the branching node may choose to wait until one child has failed before starting the next. Failure of a leaf node is determined by its protocol negotiation failing or timing out; failure of a parent branching node is determined by all of its children failing.<a href="#section-4.3.3-1" class="pilcrow">¶</a></p>
<p id="section-4.3.3-2">An example in which failover is recommended is a race between a preferred Protocol Stack that uses a proxy and an alternate Protocol Stack that bypasses the proxy. Failover is useful if the proxy is down or misconfigured, but any more aggressive type of racing may end up unnecessarily avoiding a proxy that was preferred by policy.<a href="#section-4.3.3-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="completing-establishment">
<section id="section-4.4">
        <h3 id="name-completing-establishment">
<a href="#section-4.4" class="section-number selfRef">4.4. </a><a href="#name-completing-establishment" class="section-name selfRef">Completing Establishment</a>
        </h3>
<p id="section-4.4-1">The process of Connection establishment completes when one leaf node of the tree has successfully completed negotiation with the Remote Endpoint or when all nodes of the tree have failed to connect. The first leaf node to complete its connection is then used by the application to send and receive data. This is signaled to the application using the <code>Ready</code> event in the API (<span><a href="https://rfc-editor.org/rfc/rfc9622#section-7.1" class="relref">Section 7.1</a> of [<a href="#RFC9622" class="cite xref">RFC9622</a>]</span>).<a href="#section-4.4-1" class="pilcrow">¶</a></p>
<p id="section-4.4-2">Successes and failures of a given attempt should be reported up to parent nodes (toward the root of the tree). For example, in the following case, if 1.1.1 fails to connect, it reports the failure to 1.1. Since 1.1 has no other child nodes, it also has failed and reports that failure to 1. Because 1.2 has not yet failed, 1 is not considered to have failed. Since 1.2 has not yet started, it is started and the process continues. Similarly, if 1.1.1 successfully connects, then it marks 1.1 as connected, which propagates to the root node 1. At this point, the Connection as a whole is considered to be successfully connected and ready to process application data.<a href="#section-4.4-2" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.4-3">
<pre>
1 [www.example.com:443, Any, TCP]
  1.1 [www.example.com:443, Wi-Fi, TCP]
    1.1.1 [192.0.2.1:443, Wi-Fi, TCP]
  1.2 [www.example.com:443, LTE, TCP]
...
</pre><a href="#section-4.4-3" class="pilcrow">¶</a>
</div>
<p id="section-4.4-4">If a leaf node has successfully completed its connection, all other attempts should be made ineligible for use by the application for the original request.
New connection attempts that involve transmitting data on the network ought not to be started after another leaf node has already successfully completed because the Connection as a whole has now been established.
An implementation could choose to let certain handshakes and negotiations complete to gather metrics that influence future connections.
Keeping additional connections is generally not recommended because those attempts were slower to connect and may exhibit less desirable properties.<a href="#section-4.4-4" class="pilcrow">¶</a></p>
<div id="determining-successful-establishment">
<section id="section-4.4.1">
          <h4 id="name-determining-successful-esta">
<a href="#section-4.4.1" class="section-number selfRef">4.4.1. </a><a href="#name-determining-successful-esta" class="section-name selfRef">Determining Successful Establishment</a>
          </h4>
<p id="section-4.4.1-1">On a per-protocol basis, implementations may select different criteria by which a leaf node is considered to be successfully connected. If the only protocol being used is a transport protocol with a clear handshake, like TCP, then the obvious choice is to declare that node "connected" when the three-way handshake completes. If the only protocol being used is a connectionless protocol, like UDP, the implementation may consider the node fully "connected" the moment it determines a route is present, before sending any packets on the network, see further in <a href="#connectionless-racing" class="auto internal xref">Section 4.6</a>.<a href="#section-4.4.1-1" class="pilcrow">¶</a></p>
<p id="section-4.4.1-2">   Depending on the protocols involved, there is no guarantee that the
   Remote Endpoint will be notified when the <code>Initiate</code> action is called
   without any Messages being sent at the same time.  Therefore, a
   passive Endpoint's application may not receive a <code>ConnectionReceived</code>
   event until it receives the first Message on the new Connection.<a href="#section-4.4.1-2" class="pilcrow">¶</a></p>
<p id="section-4.4.1-3">For Protocol Stacks with multiple handshakes, the decision becomes more nuanced. If the Protocol Stack involves both TLS and TCP, an implementation could determine that a leaf node is connected after the TCP handshake is complete, or it can wait for the TLS handshake to complete as well. The benefit of declaring completion when the TCP handshake finishes, and thus stopping the race for other branches of the tree, is reduced burden on the network and Remote Endpoints from further connection attempts that are likely to be abandoned. On the other hand, by waiting until the TLS handshake is complete, an implementation avoids the scenario in which a TCP handshake completes quickly, but TLS negotiation is either very slow or fails altogether in particular network conditions or to a particular endpoint. To avoid the issue of TLS possibly failing, the implementation should not generate a <code>Ready</code> event for the Connection until the TLS handshake is complete.<a href="#section-4.4.1-3" class="pilcrow">¶</a></p>
<p id="section-4.4.1-4">If all of the leaf nodes fail to connect during racing, i.e., none of the configurations that satisfy all requirements given in the Transport Properties actually work over the available paths, then the Transport Services System should report an <code>EstablishmentError</code> to the application. An <code>EstablishmentError</code> event should also be generated if the Transport Services System finds no usable candidates to race.<a href="#section-4.4.1-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="establish-mux">
<section id="section-4.5">
        <h3 id="name-establishing-multiplexed-co">
<a href="#section-4.5" class="section-number selfRef">4.5. </a><a href="#name-establishing-multiplexed-co" class="section-name selfRef">Establishing Multiplexed Connections</a>
        </h3>
<p id="section-4.5-1">Multiplexing several Connections over a single underlying transport connection requires that the multiplexed Connections belong to the same Connection Group (as is indicated by the application using the <code>Clone</code> action). When the underlying transport connection supports multistreaming, the Transport Services System can map each Connection in the Connection Group to a different stream of this connection.<a href="#section-4.5-1" class="pilcrow">¶</a></p>
<p id="section-4.5-2">For such streams, there is often no explicit connection
establishment procedure for the new stream prior to sending data on it (e.g., with SCTP). In this case, the same
considerations apply to determining stream establishment as apply to establishing a UDP connection, as
discussed in <a href="#determining-successful-establishment" class="auto internal xref">Section 4.4.1</a>.
This means that there might not
be any "establishment" message (like a TCP SYN).<a href="#section-4.5-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="connectionless-racing">
<section id="section-4.6">
        <h3 id="name-handling-connectionless-pro">
<a href="#section-4.6" class="section-number selfRef">4.6. </a><a href="#name-handling-connectionless-pro" class="section-name selfRef">Handling Connectionless Protocols</a>
        </h3>
<p id="section-4.6-1">While protocols that use an explicit handshake to validate a connection to a peer can be used for racing multiple establishment attempts in parallel, connectionless protocols such as raw UDP do not offer a way to validate the presence of a peer or the usability of a Connection without application feedback. An implementation should consider such a Protocol Stack to be established as soon as the Transport Services System has selected a path on which to send data.<a href="#section-4.6-1" class="pilcrow">¶</a></p>
<p id="section-4.6-2">However, this can cause a problem if a specific peer is not reachable over the network using the connectionless protocol or data cannot be exchanged with the peer for any other reason. To handle the lack of an explicit handshake in the underlying protocol, an application can use a Message Framer (<a href="#message-framers" class="auto internal xref">Section 6</a>) on top of a connectionless protocol to only mark a specific connection attempt as ready when some data has been received or after some application-level handshake has been performed by the Message Framer.<a href="#section-4.6-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="listen">
<section id="section-4.7">
        <h3 id="name-implementing-listeners">
<a href="#section-4.7" class="section-number selfRef">4.7. </a><a href="#name-implementing-listeners" class="section-name selfRef">Implementing Listeners</a>
        </h3>
<p id="section-4.7-1">When an implementation is asked to <code>Listen</code>, it registers with the system to wait for incoming traffic to the Local Endpoint. If no Local Endpoint Identifier is specified, the implementation should use an ephemeral port.<a href="#section-4.7-1" class="pilcrow">¶</a></p>
<p id="section-4.7-2">If the Selection Properties do not require a single network interface or path but allow the use of multiple paths, the Listener object should register for incoming traffic on all of the network interfaces or paths that conform to the Properties. The set of available paths can change over time, so the implementation should monitor network path changes and change the registration of the Listener across all usable paths as appropriate. When using multiple paths, the Listener is generally expected to use the same port for listening on each.<a href="#section-4.7-2" class="pilcrow">¶</a></p>
<p id="section-4.7-3">If the Selection Properties allow multiple protocols to be used for listening and the implementation supports it, the Listener object should support receiving inbound connections for each eligible protocol on each eligible path.<a href="#section-4.7-3" class="pilcrow">¶</a></p>
<div id="implementing-listeners-for-connected-protocols">
<section id="section-4.7.1">
          <h4 id="name-implementing-listeners-for-">
<a href="#section-4.7.1" class="section-number selfRef">4.7.1. </a><a href="#name-implementing-listeners-for-" class="section-name selfRef">Implementing Listeners for Connected Protocols</a>
          </h4>
<p id="section-4.7.1-1">Connected protocols such as TCP and TLS-over-TCP have a strong mapping between the Local and Remote Endpoint Identifiers (four-tuple) and their protocol connection state. These map to Connection objects. Whenever a new inbound handshake is being started, the Listener should generate a new Connection object and pass it to the application.<a href="#section-4.7.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="implementing-listeners-for-connectionless-protocols">
<section id="section-4.7.2">
          <h4 id="name-implementing-listeners-for-c">
<a href="#section-4.7.2" class="section-number selfRef">4.7.2. </a><a href="#name-implementing-listeners-for-c" class="section-name selfRef">Implementing Listeners for Connectionless Protocols</a>
          </h4>
<p id="section-4.7.2-1">Connectionless protocols such as UDP and UDP-Lite generally do not provide the same mechanisms that connected protocols do to offer Connection objects.  Implementations should wait for incoming packets for connectionless protocols on a listening port and should perform four-tuple matching of packets to existing Connection objects if possible. If a matching Connection object does not exist, an incoming packet from a connectionless protocol should cause a new Connection object to be created.<a href="#section-4.7.2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="implementing-listeners-for-multiplexed-protocols">
<section id="section-4.7.3">
          <h4 id="name-implementing-listeners-for-m">
<a href="#section-4.7.3" class="section-number selfRef">4.7.3. </a><a href="#name-implementing-listeners-for-m" class="section-name selfRef">Implementing Listeners for Multiplexed Protocols</a>
          </h4>
<p id="section-4.7.3-1">Protocols that provide multiplexing of streams can listen for entirely new connections as well as for new subconnections (streams of an already-existing connection). A new stream arrival on an existing connection is presented to the application as a new Connection. This new Connection is grouped with all other Connections that are multiplexed via the same protocol.<a href="#section-4.7.3-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="implementing-sending-and-receiving-data">
<section id="section-5">
      <h2 id="name-implementing-sending-and-re">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-implementing-sending-and-re" class="section-name selfRef">Implementing Sending and Receiving Data</a>
      </h2>
<p id="section-5-1">The most basic mapping for sending a Message is an abstraction of datagrams, in which the transport protocol naturally deals in discrete packets (such as UDP). Each Message here corresponds to a single datagram.<a href="#section-5-1" class="pilcrow">¶</a></p>
<p id="section-5-2">For protocols that expose byte-streams (such as TCP), the only delineation provided by the protocol is the end of the stream in a given direction. Each Message in this case corresponds to the entire stream of bytes in a direction. These Messages may be quite long, in which case they can be sent in multiple parts.<a href="#section-5-2" class="pilcrow">¶</a></p>
<p id="section-5-3">Protocols that provide framing (such as length-value protocols, or protocols that use delimiters like HTTP/1.1) may support Message sizes that do not fit within a single datagram. Each Message for framing protocols corresponds to a single frame, which may be sent either as a complete Message in the underlying protocol or in multiple parts.<a href="#section-5-3" class="pilcrow">¶</a></p>
<p id="section-5-4">Messages themselves generally consist of bytes passed in the <code>messageData</code> parameter intended to be processed at an application layer. However, Message objects presented through the API
can carry associated Message Properties passed through the <code>messageContext</code> parameter.
When these are Protocol-specific Properties, they can include metadata that exists separately from a byte
encoding. For example, these Properties can include name-value pairs of information, like HTTP header fields. In such cases, Messages might be "empty"
insofar as they contain zero bytes in the <code>messageData</code> parameter, but they can still include data in the <code>messageContext</code> that is interpreted by the Protocol Stack.<a href="#section-5-4" class="pilcrow">¶</a></p>
<div id="sending-messages">
<section id="section-5.1">
        <h3 id="name-sending-messages">
<a href="#section-5.1" class="section-number selfRef">5.1. </a><a href="#name-sending-messages" class="section-name selfRef">Sending Messages</a>
        </h3>
<p id="section-5.1-1">The effect of the application sending a Message is determined by the top-level protocol in the established Protocol Stack. That is, if the top-level protocol provides an abstraction of framed Messages over a connection, the receiving application will be able to obtain multiple Messages on that connection, even if the framing protocol is built on a byte-stream protocol like TCP.<a href="#section-5.1-1" class="pilcrow">¶</a></p>
<div id="msg-properties">
<section id="section-5.1.1">
          <h4 id="name-message-properties">
<a href="#section-5.1.1" class="section-number selfRef">5.1.1. </a><a href="#name-message-properties" class="section-name selfRef">Message Properties</a>
          </h4>
<p id="section-5.1.1-1">The API allows various Properties to be associated with each Message, which should be implemented as discussed below.<a href="#section-5.1.1-1" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-5.1.1-2">
            <dt id="section-5.1.1-2.1">
<code>msgLifetime</code>:</dt>
            <dd style="margin-left: 1.5em" id="section-5.1.1-2.2">This should be implemented by removing the Message from the queue of pending Messages after the Lifetime has expired. A queue of pending Messages within the Transport Services Implementation that have yet to be handed to the Protocol Stack can always support this Property, but once a Message has been sent into the send buffer of a protocol, only certain protocols may support removing it from their send buffer. For example, a Transport Services Implementation cannot remove bytes from a TCP send buffer, while it can remove data from an SCTP send buffer using the partial reliability extension <span>[<a href="#RFC8303" class="cite xref">RFC8303</a>]</span>. When there is no standing queue of Messages within the system, and the Protocol Stack does not support the removal of a Message from the stack's send buffer, this Property may be ignored.<a href="#section-5.1.1-2.2" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-5.1.1-2.3">
<code>msgPriority</code>:</dt>
            <dd style="margin-left: 1.5em" id="section-5.1.1-2.4">This represents the ability to prioritize a Message over other Messages. This can be implemented by the Transport Services System by reordering Messages that have yet to be handed to the Protocol Stack or by giving relative priority hints to protocols that support priorities per Message. For example, an implementation of HTTP/2 could choose to send Messages of different priority on streams of different priority.<a href="#section-5.1.1-2.4" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-5.1.1-2.5">
<code>msgOrdered</code>:</dt>
            <dd style="margin-left: 1.5em" id="section-5.1.1-2.6">When this is false, it disables the requirement of in-order delivery for protocols that support configurable ordering. When the Protocol Stack does not support configurable ordering, this Property may be ignored.<a href="#section-5.1.1-2.6" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-5.1.1-2.7">
<code>safelyReplayable</code>:</dt>
            <dd style="margin-left: 1.5em" id="section-5.1.1-2.8">When this is true, it means that the Message can be used by a transport mechanism that might deliver it multiple times -- e.g., as a result of racing multiple transports or as part of TCP Fast Open (TFO). Also, protocols that do not protect against duplicated Messages, such as UDP (when used directly, without a protocol layered atop), can only be used with Messages that are safely replayable. When a Transport Services System is permitted to replay Messages, replay protection could be provided by the application.<a href="#section-5.1.1-2.8" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-5.1.1-2.9">
<code>final</code>:</dt>
            <dd style="margin-left: 1.5em" id="section-5.1.1-2.10">When this is <code>true</code>, it means that the sender will not send any further Messages. The Connection need not be closed (if the Protocol Stack supports half-closed operations, like TCP). Any Messages sent after a Message marked <code>Final</code> will result in a <code>SendError</code>.<a href="#section-5.1.1-2.10" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-5.1.1-2.11">
<code>msgChecksumLen</code>:</dt>
            <dd style="margin-left: 1.5em" id="section-5.1.1-2.12">When this is set to any value other than <code>Full Coverage</code>, it sets the minimum protection in protocols that allow limiting the checksum length (e.g., UDP-Lite). If the Protocol Stack does not support checksum length limitation, this Property may be ignored.<a href="#section-5.1.1-2.12" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-5.1.1-2.13">
<code>msgReliable</code>:</dt>
            <dd style="margin-left: 1.5em" id="section-5.1.1-2.14">When true, this Property specifies that the Message must be reliably transmitted. When false, and if unreliable transmission is supported by the underlying protocol, then the Message should be unreliably transmitted. If the underlying
protocol does not support unreliable transmission, the Message should be reliably transmitted.<a href="#section-5.1.1-2.14" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-5.1.1-2.15">
<code>msgCapacityProfile</code>:</dt>
            <dd style="margin-left: 1.5em" id="section-5.1.1-2.16">When true, this expresses a wish to override the
Generic Connection Property <code>connCapacityProfile</code> for this Message. Depending on the
value, this can, for example, be implemented by changing the Differentiated Services Code Point  (DSCP) value of the
associated packet (note that the guidelines in <span><a href="https://rfc-editor.org/rfc/rfc7657#section-6" class="relref">Section 6</a> of [<a href="#RFC7657" class="cite xref">RFC7657</a>]</span> apply; for example,
the DSCP value should not be changed for different packets within a reliable
transport protocol session or DCCP connection).<a href="#section-5.1.1-2.16" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-5.1.1-2.17">
<code>noFragmentation</code>:</dt>
            <dd style="margin-left: 1.5em" id="section-5.1.1-2.18">Setting this avoids network-layer fragmentation. Messages exceeding the transport's current estimate of its maximum packet size (the <code>singularTransmissionMsgMaxLen</code> Connection Property) can result in transport segmentation when permitted or generate an error. When used with transports running over IPv4, the Don't Fragment (DF) bit should be set to avoid on-path IP fragmentation <span>[<a href="#RFC8304" class="cite xref">RFC8304</a>]</span>.<a href="#section-5.1.1-2.18" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-5.1.1-2.19">
<code>noSegmentation</code>:</dt>
            <dd style="margin-left: 1.5em" id="section-5.1.1-2.20">When set, this Property limits the Message size to the transport's current estimate of its maximum packet size (the <code>singularTransmissionMsgMaxLen</code> Connection Property). Messages larger than this size generate an error. Setting this avoids transport-layer segmentation and network-layer fragmentation. When used with transports running over IPv4, the DF bit should be set to avoid on-path IP fragmentation (<span>[<a href="#RFC8304" class="cite xref">RFC8304</a>]</span>).<a href="#section-5.1.1-2.20" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
</dl>
</section>
</div>
<div id="send-completion">
<section id="section-5.1.2">
          <h4 id="name-send-completion">
<a href="#section-5.1.2" class="section-number selfRef">5.1.2. </a><a href="#name-send-completion" class="section-name selfRef">Send Completion</a>
          </h4>
<p id="section-5.1.2-1">The application should be notified (using a <code>Sent</code>, <code>Expired</code>, or <code>SendError</code> event) whenever a Message or partial Message has been consumed by the Protocol Stack or has failed to send. The time at which a Message is considered to have been consumed by the Protocol Stack may vary depending on the protocol. For example, for a basic datagram protocol like UDP, this may correspond to the time when the packet is sent into the interface driver. For a protocol that buffers data in queues, like TCP, this may correspond to when the data has entered the send buffer. The time at which a Message failed to send is when the Transport Services Implementation (including the Protocol Stack) has experienced a failure related to sending; this can depend on protocol-specific timeouts.<a href="#section-5.1.2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="batching-sends">
<section id="section-5.1.3">
          <h4 id="name-batching-sends">
<a href="#section-5.1.3" class="section-number selfRef">5.1.3. </a><a href="#name-batching-sends" class="section-name selfRef">Batching Sends</a>
          </h4>
<p id="section-5.1.3-1">Sending multiple Messages can incur high overhead if each needs to be enqueued separately (e.g., each Message might involve a context switch between the
application and the Transport Services System). To avoid this, the application can indicate a batch of <code>Send</code> actions through the API. When this is used,
the implementation can defer the processing of Messages until the batch is complete.<a href="#section-5.1.3-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="receiving-messages">
<section id="section-5.2">
        <h3 id="name-receiving-messages">
<a href="#section-5.2" class="section-number selfRef">5.2. </a><a href="#name-receiving-messages" class="section-name selfRef">Receiving Messages</a>
        </h3>
<p id="section-5.2-1">Similar to sending, receiving a Message is determined by the top-level protocol in the established Protocol Stack. The main difference with receiving is that the size and boundaries of the Message are not known beforehand. The application can communicate the parameters for the Message in its <code>Receive</code> action, which can help the Transport Services Implementation know how much data to deliver and when. For example, if the application only wants to receive a complete Message, the implementation should wait until an entire Message (datagram, stream, or frame) is read before delivering any Message content to the application. This requires the implementation to understand where Messages end, either via a supplied Message Framer or because the top-level protocol in the established Protocol Stack preserves Message boundaries. The application can also control the flow of received data by specifying the minimum and maximum number of bytes of Message content it wants to receive at one time.<a href="#section-5.2-1" class="pilcrow">¶</a></p>
<p id="section-5.2-2">If a Connection finishes before a requested <code>Receive</code> action can be satisfied, the Transport Services System should deliver any outstanding partial Message content; if none is available, the system should indicate that there will be no additional received Messages.<a href="#section-5.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="fastopen">
<section id="section-5.3">
        <h3 id="name-handling-of-data-for-fast-o">
<a href="#section-5.3" class="section-number selfRef">5.3. </a><a href="#name-handling-of-data-for-fast-o" class="section-name selfRef">Handling of Data for Fast-Open Protocols</a>
        </h3>
<p id="section-5.3-1">Several protocols allow sending higher-level protocol or application data during their protocol establishment, such as TFO <span>[<a href="#RFC7413" class="cite xref">RFC7413</a>]</span> and TLS 1.3 <span>[<a href="#RFC8446" class="cite xref">RFC8446</a>]</span>. This approach is referred to as sending Zero-RTT (0-RTT) data. This is a desirable feature, but it poses challenges to an implementation that uses racing during Connection establishment.<a href="#section-5.3-1" class="pilcrow">¶</a></p>
<p id="section-5.3-2">The application can express its preference for sending Messages as 0-RTT data by using the <code>zeroRttMsg</code> Selection Property on the Preconnection. Then, the application can provide the Message to send as 0-RTT data via the <code>InitiateWithSend</code> action. In order to be sent as 0-RTT data, the Message needs to be marked with the <code>safelyReplayable</code> Property. In general, 0-RTT data may be replayed (for example, if a TCP SYN contains data, and the SYN is retransmitted, the data will be retransmitted as well but may be considered a new connection instead of a retransmission). When racing connections, different leaf nodes have the opportunity to send the same data independently. If data is truly safely replayable, this is permissible.<a href="#section-5.3-2" class="pilcrow">¶</a></p>
<p id="section-5.3-3">Once the application has provided its 0-RTT data, a Transport Services Implementation should keep a copy of this data and provide it to each new leaf node that is started and for which a protocol instance supporting 0-RTT is being used. Note that the amount of data that can actually be sent as 0-RTT data varies by protocol, so any given Protocol Stack might only consume part of the saved data prior to becoming established. The implementation needs to keep track of how much data a particular Protocol Stack has consumed and ensure that any pending 0-RTT-eligible data from the application is handled before subsequent Messages.<a href="#section-5.3-3" class="pilcrow">¶</a></p>
<p id="section-5.3-4">It is also possible for Protocol Stacks within a particular leaf node to use a 0-RTT handshake in a lower-level protocol without any safely replayable application data if a higher-level protocol in the stack has idempotent handshake data to send. For example, TFO could use a Client Hello from TLS as its 0-RTT data without any data being provided by the application.<a href="#section-5.3-4" class="pilcrow">¶</a></p>
<p id="section-5.3-5">0-RTT handshakes often rely on previous state, such as TFO cookies, previously established TLS tickets, or out-of-band distributed pre-shared keys (PSKs). Implementations should be aware of security concerns around using these tokens across multiple addresses or paths when racing. In the case of TLS, any given ticket or PSK should only be used on one leaf node, since servers will likely reject duplicate tickets in order to prevent replays (see <span><a href="https://rfc-editor.org/rfc/rfc8446#section-8.1" class="relref">Section 8.1</a> of [<a href="#RFC8446" class="cite xref">RFC8446</a>]</span>). If implementations have multiple tickets available from a previous connection, each leaf node attempt can use a different ticket. In effect, each leaf node will send the same early application data, but the data will be encoded (encrypted) differently on the wire.<a href="#section-5.3-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="message-framers">
<section id="section-6">
      <h2 id="name-implementing-message-framer">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-implementing-message-framer" class="section-name selfRef">Implementing Message Framers</a>
      </h2>
<p id="section-6-1">Message Framers are functions that define
simple transformations between application Message data and raw transport
protocol data. Generally, a Message Framer implements a simple
application protocol that can be provided either by the Transport Services
implementation or by the application. It is optional for Transport Services Implementations to provide Message Framers: the API specification <span>[<a href="#RFC9622" class="cite xref">RFC9622</a>]</span> does not prescribe any particular Message Framers to be implemented.
A Framer can encapsulate or encode outbound Messages,
decapsulate or decode inbound data into Messages, and implement parts of
protocols that do not directly map to application Messages (such as
protocol handshakes or preludes before Message exchange).<a href="#section-6-1" class="pilcrow">¶</a></p>
<p id="section-6-2">While many protocols can be represented as Message Framers, for the
purposes of the Transport Services API, these are ways for applications
or application frameworks to define their own Message parsing to be
included within a Connection's Protocol Stack. As an example, TLS
is a protocol that is by default built into the Transport Services
API, even though it could also serve the purpose of framing data over TCP.<a href="#section-6-2" class="pilcrow">¶</a></p>
<p id="section-6-3">Most Message Framers fall into one of two categories:<a href="#section-6-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6-4.1">
          <p id="section-6-4.1.1">Header-prefixed record formats, such as a basic Type-Length-Value (TLV) structure<a href="#section-6-4.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-6-4.2">
          <p id="section-6-4.2.1">Delimiter-separated formats, such as HTTP/1.1<a href="#section-6-4.2.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-6-5">Common Message Framers can be provided by a Transport Services Implementation,
but an implementation ought to allow custom Message Framers to be defined by
the application or some other piece of software. This section describes one
possible API for defining Message Framers as an example.<a href="#section-6-5" class="pilcrow">¶</a></p>
<div id="defining-message-framers">
<section id="section-6.1">
        <h3 id="name-defining-message-framers">
<a href="#section-6.1" class="section-number selfRef">6.1. </a><a href="#name-defining-message-framers" class="section-name selfRef">Defining Message Framers</a>
        </h3>
<p id="section-6.1-1">A Message Framer is primarily defined by the code that handles events
for a Framer implementation, specifically how it handles inbound and outbound data
parsing. The function that implements custom framing logic will be referred to
as the "Framer implementation", which may be provided by a Transport Services
Implementation or the application itself. The Message Framer holds a reference to the object
or function within the main Connection implementation that delivers events
to the custom Framer implementation whenever data is ready to be parsed or framed.<a href="#section-6.1-1" class="pilcrow">¶</a></p>
<p id="section-6.1-2">The API examples in this section use the notation conventions for the Transport
Services API defined in <span><a href="https://rfc-editor.org/rfc/rfc9622#section-1.1" class="relref">Section 1.1</a> of [<a href="#RFC9622" class="cite xref">RFC9622</a>]</span>.<a href="#section-6.1-2" class="pilcrow">¶</a></p>
<p id="section-6.1-3">The Transport Services Implementation needs to ensure that all of the
events and actions taken on a Message Framer are synchronized to ensure
consistent behavior. For example, some of the actions defined below (such as
<code>PrependFramer</code> and <code>StartPassthrough</code>) modify how data flows in a Protocol
Stack and require synchronization with sending and parsing data in the
 Message Framer.<a href="#section-6.1-3" class="pilcrow">¶</a></p>
<p id="section-6.1-4">When a Connection establishment attempt begins, an event can be delivered to
notify the Framer implementation that a new Connection is being created.
Similarly, a <code>Stop</code> event can be delivered when a Connection is being torn down.
The Framer implementation can use the Connection object to look up specific
Properties of the Connection or the network being used that may influence how
to frame Messages.<a href="#section-6.1-4" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-6.1-5">
<pre>
MessageFramer -&gt; Start&lt;connection&gt;
MessageFramer -&gt; Stop&lt;connection&gt;
</pre><a href="#section-6.1-5" class="pilcrow">¶</a>
</div>
<p id="section-6.1-6">When a Message Framer generates a <code>Start</code> event, the Framer implementation
has the opportunity to start writing some data prior to the Connection delivering
its <code>Ready</code> event. This allows the implementation to communicate control data to the
Remote Endpoint that can be used to parse Messages.<a href="#section-6.1-6" class="pilcrow">¶</a></p>
<p id="section-6.1-7">Once the Framer implementation has completed its setup or handshake, it can indicate to
the application that it is ready for handling data with this call.<a href="#section-6.1-7" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-6.1-8">
<pre>
MessageFramer.MakeConnectionReady(connection)
</pre><a href="#section-6.1-8" class="pilcrow">¶</a>
</div>
<p id="section-6.1-9">Similarly, when a Message Framer generates a <code>Stop</code> event, the Framer implementation has the opportunity to write some final data or clear up its local state before the <code>Closed</code> event is delivered to the application. The Framer implementation can indicate that it has finished with this call.<a href="#section-6.1-9" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-6.1-10">
<pre>
MessageFramer.MakeConnectionClosed(connection)
</pre><a href="#section-6.1-10" class="pilcrow">¶</a>
</div>
<p id="section-6.1-11">If the implementation encounters a fatal error at any time, it can also cause the Connection
to fail and provide an error.<a href="#section-6.1-11" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-6.1-12">
<pre>
MessageFramer.FailConnection(connection, error)
</pre><a href="#section-6.1-12" class="pilcrow">¶</a>
</div>
<p id="section-6.1-13">Should the Framer implementation deem the candidate selected during racing unsuitable, it can signal this to the Transport Services API by failing the Connection prior to marking it as ready.
If there are no other candidates available, the Connection will fail. Otherwise, the Connection will select a different candidate and the Message Framer will generate a new <code>Start</code> event.<a href="#section-6.1-13" class="pilcrow">¶</a></p>
<p id="section-6.1-14">Before an implementation marks a Message Framer as ready, it can also dynamically
add a protocol or Framer above it in the stack. This allows protocols that need to add TLS conditionally,
like STARTTLS <span>[<a href="#RFC3207" class="cite xref">RFC3207</a>]</span>, to modify the Protocol Stack based on a handshake result.<a href="#section-6.1-14" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-6.1-15">
<pre>
otherFramer := NewMessageFramer()
MessageFramer.PrependFramer(connection, otherFramer)
</pre><a href="#section-6.1-15" class="pilcrow">¶</a>
</div>
<p id="section-6.1-16">A Message Framer might also choose to go into a passthrough mode once an initial exchange or handshake has been completed, such as the STARTTLS case mentioned above.
This can also be useful for proxy protocols like SOCKS <span>[<a href="#RFC1928" class="cite xref">RFC1928</a>]</span> or HTTP CONNECT <span>[<a href="#RFC9110" class="cite xref">RFC9110</a>]</span>. In such cases, a Message Framer implementation can initially intercept
Messages being sent and received and subsequently indicate that no further processing is needed.<a href="#section-6.1-16" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-6.1-17">
<pre>
MessageFramer.StartPassthrough()
</pre><a href="#section-6.1-17" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="send-framing">
<section id="section-6.2">
        <h3 id="name-sender-side-message-framing">
<a href="#section-6.2" class="section-number selfRef">6.2. </a><a href="#name-sender-side-message-framing" class="section-name selfRef">Sender-Side Message Framing</a>
        </h3>
<p id="section-6.2-1">Message Framers generate an event whenever a Connection sends a new Message. The parameters to the event
align with the <code>Send</code> action in the API (<span><a href="https://rfc-editor.org/rfc/rfc9622#section-9.2" class="relref">Section 9.2</a> of [<a href="#RFC9622" class="cite xref">RFC9622</a>]</span>).<a href="#section-6.2-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-6.2-2">
<pre>
                        MessageFramer
                              |
                              V
NewSentMessage&lt;connection, messageData, messageContext, endOfMessage&gt;
</pre><a href="#section-6.2-2" class="pilcrow">¶</a>
</div>
<p id="section-6.2-3">Upon receiving this event, a Framer implementation is responsible for
performing any necessary transformations and sending the resulting data back to the Message Framer, which, in turn, will send it to the next protocol.
To improve performance, implementations should ensure that there is a way to pass the original data
through without copying.<a href="#section-6.2-3" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-6.2-4">
<pre>
MessageFramer.Send(connection, messageData)
</pre><a href="#section-6.2-4" class="pilcrow">¶</a>
</div>
<p id="section-6.2-5">To provide an example, a simple protocol that adds the length of the Message data as a header would receive
the <code>NewSentMessage</code> event, create a data representation of the length of the Message
data, and then send a block of data that is the concatenation of the length header and the original
Message data.<a href="#section-6.2-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="receive-framing">
<section id="section-6.3">
        <h3 id="name-receiver-side-message-frami">
<a href="#section-6.3" class="section-number selfRef">6.3. </a><a href="#name-receiver-side-message-frami" class="section-name selfRef">Receiver-Side Message Framing</a>
        </h3>
<p id="section-6.3-1">In order to parse a received flow of data into Messages, the Message Framer
notifies the Framer implementation whenever new data is available to parse.<a href="#section-6.3-1" class="pilcrow">¶</a></p>
<p id="section-6.3-2">The parameters to the events and calls for receiving data with a Framer
align with the <code>Receive</code> action in the API (<span><a href="https://rfc-editor.org/rfc/rfc9622#section-9.3" class="relref">Section 9.3</a> of [<a href="#RFC9622" class="cite xref">RFC9622</a>]</span>).<a href="#section-6.3-2" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-6.3-3">
<pre>
MessageFramer -&gt; HandleReceivedData&lt;connection&gt;
</pre><a href="#section-6.3-3" class="pilcrow">¶</a>
</div>
<p id="section-6.3-4">Upon receiving this event, the Framer implementation can inspect the inbound data. The
data is parsed from a particular cursor representing the unprocessed data. The
application requests a specific amount of data it needs to have available in order to parse.
If the data is not available, the parse fails.<a href="#section-6.3-4" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-6.3-5">
<pre>
MessageFramer.Parse(connection, minimumIncompleteLength, maximumLength)
                                 |
                                 V
             (messageData, messageContext, endOfMessage)
</pre><a href="#section-6.3-5" class="pilcrow">¶</a>
</div>
<p id="section-6.3-6">The Framer implementation can directly advance the receive cursor once it has
parsed data to effectively discard data (for example, discard a header
once the content has been parsed).<a href="#section-6.3-6" class="pilcrow">¶</a></p>
<p id="section-6.3-7">To deliver a Message to the application, the Framer implementation can either directly
deliver data that it has allocated or deliver a range of data directly from the underlying
transport and simultaneously advance the receive cursor.<a href="#section-6.3-7" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-6.3-8">
<pre>
MessageFramer.AdvanceReceiveCursor(connection, length)
MessageFramer.DeliverAndAdvanceReceiveCursor(connection, messageContext,
                                             length, endOfMessage)
MessageFramer.Deliver(connection, messageContext, messageData,
                      endOfMessage)
</pre><a href="#section-6.3-8" class="pilcrow">¶</a>
</div>
<p id="section-6.3-9">Note that <code>MessageFramer.DeliverAndAdvanceReceiveCursor</code> allows the Framer implementation
to earmark bytes as part of a Message even before they are received by the transport. This allows the delivery
of very large Messages without requiring the implementation to directly inspect all of the bytes.<a href="#section-6.3-9" class="pilcrow">¶</a></p>
<p id="section-6.3-10">To provide an example, a simple protocol that parses the length of the Message data as a header value would
receive the <code>HandleReceivedData</code> event and call <code>Parse</code> with a minimum and maximum
set to the length of the header field. Once the parse succeeded, it would call
<code>AdvanceReceiveCursor</code> with the length of the header field and then call
<code>DeliverAndAdvanceReceiveCursor</code> with the length of the body that was parsed from
the header, marking the new Message as complete.<a href="#section-6.3-10" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="implementing-connection-management">
<section id="section-7">
      <h2 id="name-implementing-connection-man">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-implementing-connection-man" class="section-name selfRef">Implementing Connection Management</a>
      </h2>
<p id="section-7-1">Once a Connection is established, the Transport Services API allows applications to interact with the Connection by modifying or inspecting
Connection Properties. A Connection can also generate error events in the form of <code>SoftError</code> events.<a href="#section-7-1" class="pilcrow">¶</a></p>
<p id="section-7-2">The set of Connection Properties that are supported for setting and getting on a Connection are described in <span>[<a href="#RFC9622" class="cite xref">RFC9622</a>]</span>. For
any Properties that are generic and, thus, could apply to all protocols being used by a Connection, the Transport Services Implementation should store the Properties
in storage common to all protocols and notify the Protocol Stack as a whole whenever the Properties have been modified by the application. <span>[<a href="#RFC8303" class="cite xref">RFC8303</a>]</span> and <span>[<a href="#RFC8304" class="cite xref">RFC8304</a>]</span> offer guidance on how to do this for TCP, Multipath TCP (MPTCP), SCTP, UDP, and UDP-Lite; see <a href="#specific-protocol-considerations" class="auto internal xref">Section 10</a> for a description of a backtracking method to find the relevant protocol primitives using these documents.
      For Protocol-specific Properties, such as the User Timeout that applies to TCP, the Transport Services Implementation only needs to update the relevant protocol instance.<a href="#section-7-2" class="pilcrow">¶</a></p>
<p id="section-7-3">Some Connection Properties might apply to multiple protocols within a Protocol Stack. Depending on the specific Property,
it might be appropriate to apply the Property across multiple protocols simultaneously or only apply it to one protocol.
In general, the Transport Services Implementation should allow the protocol closest to the application to interpret
Connection Properties and, potentially, modify the set of Connection Properties passed down to the next protocol in the
stack. For example, if the application has requested to use keep-alives with the <code>keepAlive</code> Property, and the Protocol
Stack contains both HTTP/2 and TCP, the HTTP/2 protocol can choose to enable its own keep-alives to satisfy the application
request and disable TCP-level keep-alives. For cases where the application needs to have fine-grained per-protocol control,
the Transport Services Implementation can expose Protocol-specific Properties.<a href="#section-7-3" class="pilcrow">¶</a></p>
<p id="section-7-4">If an error is encountered in setting a Property (for example, if the application tries to set a TCP-specific Property on a Connection that is
not using TCP), the action must fail gracefully. The application must be informed of the error but the Connection itself must not be terminated.<a href="#section-7-4" class="pilcrow">¶</a></p>
<p id="section-7-5">When protocol instances in the Protocol Stack report generic or protocol-specific
errors, the API will deliver them to the application as <code>SoftError</code> events. These allow the application to be informed of ICMP errors and other similar events.<a href="#section-7-5" class="pilcrow">¶</a></p>
<div id="pooled-connections">
<section id="section-7.1">
        <h3 id="name-pooled-connection">
<a href="#section-7.1" class="section-number selfRef">7.1. </a><a href="#name-pooled-connection" class="section-name selfRef">Pooled Connection</a>
        </h3>
<p id="section-7.1-1">For applications that do not need in-order delivery of Messages, the Transport Services Implementation may distribute Messages of a single Connection across several underlying transport connections or multiple streams of multistreaming connections between endpoints, as long as all of these satisfy the Selection Properties.
The Transport Services Implementation will then hide this connection management and only expose a single Connection object, which we call a Pooled Connection. This is in contrast to Connection Groups, which explicitly expose combined treatment of Connections, giving the application control over multiplexing, for example.<a href="#section-7.1-1" class="pilcrow">¶</a></p>
<p id="section-7.1-2">Pooled Connections can be useful when the application using the Transport Services System implements a protocol such as HTTP, which employs request/response pairs and does not require in-order delivery of responses.
This enables implementations of Transport Services Systems to realize transparent connection coalescing and connection migration and to perform per-Message endpoint and path selection by choosing among multiple underlying connections.<a href="#section-7.1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="handling-path-changes">
<section id="section-7.2">
        <h3 id="name-handling-path-changes">
<a href="#section-7.2" class="section-number selfRef">7.2. </a><a href="#name-handling-path-changes" class="section-name selfRef">Handling Path Changes</a>
        </h3>
<p id="section-7.2-1">When a path change occurs, e.g., when the IP address of an interface changes or a new interface becomes available, the Transport Services Implementation is responsible for notifying the protocol instance of the change. The path change may interrupt connectivity on a path for an active Connection or provide an opportunity for a transport that supports multipath or migration to adapt to the new paths. Note that, in the model of the Transport Services API, migration is considered a part of multipath connectivity; it is just a limiting policy on multipath usage. If the <code>multipath</code> Selection Property is set to <code>Disabled</code>, migration is disallowed.<a href="#section-7.2-1" class="pilcrow">¶</a></p>
<p id="section-7.2-2">For protocols that do not support multipath or migration, the protocol instances should be informed of the path change but should not be forcibly disconnected if the previously used path becomes unavailable. There are many common usage scenarios that can lead to a path becoming temporarily unavailable and then recovering before the transport protocol reaches a timeout error. These are particularly common using mobile devices. Examples include:<a href="#section-7.2-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.2-3.1">an Ethernet cable becoming unplugged and then plugged back in;<a href="#section-7.2-3.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-7.2-3.2">a device losing a Wi-Fi signal while a user is in an elevator and reattaching when the user leaves the elevator; and<a href="#section-7.2-3.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-7.2-3.3">a user losing the radio signal while riding a train through a tunnel.<a href="#section-7.2-3.3" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-7.2-4">If the device is able to rejoin a network with the same IP address, a stateful transport connection can generally resume. Thus, while it is useful for a protocol instance to be aware of a temporary loss of connectivity, the Transport Services Implementation should not aggressively close Connections in these scenarios.<a href="#section-7.2-4" class="pilcrow">¶</a></p>
<p id="section-7.2-5">If the Protocol Stack includes a transport protocol that supports multipath connectivity, the Transport Services Implementation should also inform the protocol instance about potentially new paths that become permissible based on the <code>multipath</code> Selection Property and the <code>multipathPolicy</code> Connection Property choices made by the application.
A protocol can then establish new subflows over new paths while an
  active path is still available or
  after a break has been detected, and it should attempt to tear down
  subflows over paths that are no longer used. The Connection Property <code>multipathPolicy</code> of the Transport Services API
allows an application to indicate when and how different paths should be used. However, detailed handling of these policies is implementation specific.
For example, if the <code>multipath</code> Selection Property is set to <code>Active</code>, the decision about when to create a new path or to announce a new path or set of paths to the Remote Endpoint, e.g., in the form of additional IP addresses, is implementation specific.
If the Protocol Stack includes a transport protocol that does not support multipath but does support migrating between paths, the update to the set of available paths can trigger the connection to be migrated.<a href="#section-7.2-5" class="pilcrow">¶</a></p>
<p id="section-7.2-6">In the case of a Pooled Connection (<a href="#pooled-connections" class="auto internal xref">Section 7.1</a>), the Transport Services Implementation may add connections over new paths to the pool if permissible based on the <code>multipathPolicy</code> and Selection Properties.
If a previously used path becomes unavailable, the Transport Services System may disconnect all connections that require this path, but it should not disconnect the Pooled Connection object exposed to the application.
The strategy to do so is implementation specific, but it should be consistent with the behavior of multipath transports.<a href="#section-7.2-6" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="implementing-connection-termination">
<section id="section-8">
      <h2 id="name-implementing-connection-ter">
<a href="#section-8" class="section-number selfRef">8. </a><a href="#name-implementing-connection-ter" class="section-name selfRef">Implementing Connection Termination</a>
      </h2>
<p id="section-8-1">For <code>Close</code> (which leads to a <code>Closed</code> event) and <code>Abort</code> (which leads to a <code>ConnectionError</code> event),
the application might find it useful to be informed when a peer closes or aborts a
Connection. Whether this is possible depends on the underlying protocol, and no guarantees
can be given. When an underlying transport connection supports multistreaming (such as SCTP), the Transport Services System can use a stream reset procedure to cause a Finish event upon a <code>Close</code> action from the peer <span>[<a href="#NEAT-flow-mapping" class="cite xref">NEAT-flow-mapping</a>]</span>.<a href="#section-8-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="cached-state">
<section id="section-9">
      <h2 id="name-cached-state">
<a href="#section-9" class="section-number selfRef">9. </a><a href="#name-cached-state" class="section-name selfRef">Cached State</a>
      </h2>
<p id="section-9-1">Beyond a single Connection's lifetime, it is useful for an implementation to keep state and history. This cached
state can help improve future Connection establishment due to reusing results and credentials and favoring paths and protocols that performed well in the past.<a href="#section-9-1" class="pilcrow">¶</a></p>
<p id="section-9-2">Cached state may be associated with different endpoints for the same Connection, depending on the protocol generating the cached content.
For example, session tickets for TLS are associated with specific endpoints; thus, they should be cached based on a connection's
hostname Endpoint Identifier (if applicable). However, performance characteristics of a path are more likely tied to the IP address
and subnet being used.<a href="#section-9-2" class="pilcrow">¶</a></p>
<div id="protocol-state-caches">
<section id="section-9.1">
        <h3 id="name-protocol-state-caches">
<a href="#section-9.1" class="section-number selfRef">9.1. </a><a href="#name-protocol-state-caches" class="section-name selfRef">Protocol State Caches</a>
        </h3>
<p id="section-9.1-1">Some protocols will have long-term state to be cached in association with endpoints. This state often has some time after which
it is expired, so the implementation should allow each protocol to specify an expiration for cached content.<a href="#section-9.1-1" class="pilcrow">¶</a></p>
<p id="section-9.1-2">Examples of cached protocol state include:<a href="#section-9.1-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-9.1-3.1">
            <p id="section-9.1-3.1.1">The DNS protocol can cache resolved addresses (such as those retrieved from A and AAAA queries) associated with a Time To Live (TTL) to
be used for future hostname resolutions without requiring asking the DNS resolver again.<a href="#section-9.1-3.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-9.1-3.2">
            <p id="section-9.1-3.2.1">TLS caches session state and tickets based on a hostname, which can be used for resuming sessions with a server.<a href="#section-9.1-3.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-9.1-3.3">
            <p id="section-9.1-3.3.1">TCP can cache cookies for use in TFO.<a href="#section-9.1-3.3.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-9.1-4">Cached protocol state is primarily used during Connection establishment for a single Protocol Stack, but it may be used to influence an
implementation's preference between several Candidate Protocol Stacks. For example, if two IP address Endpoint Identifiers are otherwise
equally preferred, an implementation may choose to attempt a connection to an address for which it has a TFO cookie.<a href="#section-9.1-4" class="pilcrow">¶</a></p>
<p id="section-9.1-5">Applications can use the Transport Services API to request that a Connection Group maintain a separate cache for
protocol state. Connections in the group will not use Cached State
from Connections outside the group, and Connections outside the group will not
use state cached from Connections inside the group. This may be necessary, for
example, if application-layer identifiers rotate and clients wish to avoid
linkability via trackable TLS tickets or TFO cookies.<a href="#section-9.1-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="performance-caches">
<section id="section-9.2">
        <h3 id="name-performance-caches">
<a href="#section-9.2" class="section-number selfRef">9.2. </a><a href="#name-performance-caches" class="section-name selfRef">Performance Caches</a>
        </h3>
<p id="section-9.2-1">In addition to protocol state, protocol instances should provide data into a performance-oriented cache to help guide future protocol and path selection. Some performance information can be gathered generically across several protocols to allow predictive comparisons between protocols on given paths:<a href="#section-9.2-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-9.2-2.1">
            <p id="section-9.2-2.1.1">Observed RTT<a href="#section-9.2-2.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-9.2-2.2">
            <p id="section-9.2-2.2.1">Connection establishment latency<a href="#section-9.2-2.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-9.2-2.3">
            <p id="section-9.2-2.3.1">Connection establishment success rate<a href="#section-9.2-2.3.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-9.2-3">These items can be cached on a per-address and per-subnet granularity and averaged between different values. The information should be cached on a per-network basis since it is expected that different network attachments will have different performance characteristics. Besides protocol instances, other system entities may also provide data into performance-oriented caches. This could for instance be signal strength information reported by radio modems like Wi-Fi and mobile broadband or information about the battery level of the device. Furthermore, the system may cache the observed maximum throughput on a path as an estimate of the available bandwidth.<a href="#section-9.2-3" class="pilcrow">¶</a></p>
<p id="section-9.2-4">An implementation should use this information, when possible, to influence preference between Candidate Paths, endpoints, and protocol options. Eligible options that historically had significantly better performance than others should be selected first when gathering candidates (see <a href="#gathering" class="auto internal xref">Section 4.2</a>) to ensure better performance for the application.<a href="#section-9.2-4" class="pilcrow">¶</a></p>
<p id="section-9.2-5">The reasonable lifetime for cached performance values will vary depending on the nature of the value. Certain information, like the connection establishment success rate to a Remote Endpoint using a given Protocol Stack, can be stored for a long period of time (hours or longer) since it is expected that the capabilities of the Remote Endpoint are not changing very quickly. On the other hand, the RTT observed by TCP over a particular network path may vary over a relatively short time interval. For such values, the implementation should remove them from the cache more quickly or treat older values with less confidence/weight.<a href="#section-9.2-5" class="pilcrow">¶</a></p>
<p id="section-9.2-6"><span>[<a href="#RFC9040" class="cite xref">RFC9040</a>]</span> provides guidance about sharing of TCP Control Block information between connections on initialization.<a href="#section-9.2-6" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="specific-protocol-considerations">
<section id="section-10">
      <h2 id="name-specific-transport-protocol">
<a href="#section-10" class="section-number selfRef">10. </a><a href="#name-specific-transport-protocol" class="section-name selfRef">Specific Transport Protocol Considerations</a>
      </h2>
<p id="section-10-1">Each protocol that is supported by a Transport Services Implementation should have a well-defined API mapping.
API mappings for a protocol are important for Connections in which a given protocol is the "top" of the Protocol Stack.
For example, the mapping of the <code>Send</code> action for TCP applies to Connections in which the application directly sends over TCP.<a href="#section-10-1" class="pilcrow">¶</a></p>
<p id="section-10-2">Each protocol has a notion of "Connectedness". Possible definitions of
Connectedness for various types of protocols are:<a href="#section-10-2" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-10-3">
        <dt id="section-10-3.1">Connectionless:</dt>
        <dd style="margin-left: 1.5em" id="section-10-3.2">Connectionless protocols do not establish explicit state between endpoints and do not perform a handshake during connection establishment.<a href="#section-10-3.2" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-10-3.3">Connected:</dt>
        <dd style="margin-left: 1.5em" id="section-10-3.4">Connected (also called "connection-oriented") protocols establish state between endpoints and perform a handshake during connection establishment. The handshake may be 0-RTT to send data or resume a session, but bidirectional traffic is required to confirm Connectedness.<a href="#section-10-3.4" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-10-3.5">Multiplexing connected:</dt>
        <dd style="margin-left: 1.5em" id="section-10-3.6">Multiplexing connected protocols share properties with connected protocols but also explicitly support opening multiple application-level flows. This means that they can support cloning new Connection objects without a new explicit handshake.<a href="#section-10-3.6" class="pilcrow">¶</a>
</dd>
      <dd class="break"></dd>
</dl>
<p id="section-10-4">Protocols also have a notion of "Data Unit". Possible values for Data Unit are:<a href="#section-10-4" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-10-5">
        <dt id="section-10-5.1">Byte-stream:</dt>
        <dd style="margin-left: 1.5em" id="section-10-5.2">Byte-stream protocols do not define any message boundaries of their own apart from the end of a stream in each direction.<a href="#section-10-5.2" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-10-5.3">Datagram:</dt>
        <dd style="margin-left: 1.5em" id="section-10-5.4">Datagram protocols define message boundaries at the same level of transmission, such that only complete (not partial) messages are supported.<a href="#section-10-5.4" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-10-5.5">Message:</dt>
        <dd style="margin-left: 1.5em" id="section-10-5.6">Message protocols support message boundaries that can be sent and received either as complete or partial messages. Maximum message lengths can be defined, and messages can be partially reliable.<a href="#section-10-5.6" class="pilcrow">¶</a>
</dd>
      <dd class="break"></dd>
</dl>
<p id="section-10-6">Below, terms in capitals with a dot character (".") (e.g., "CONNECT.SCTP") refer to the primitives with the same name in <span><a href="https://rfc-editor.org/rfc/rfc8303#section-4" class="relref">Section 4</a> of [<a href="#RFC8303" class="cite xref">RFC8303</a>]</span>. For further implementation details, the description of these primitives in <span>[<a href="#RFC8303" class="cite xref">RFC8303</a>]</span> points to <span><a href="https://rfc-editor.org/rfc/rfc8303#section-3" class="relref">Section 3</a> of [<a href="#RFC8303" class="cite xref">RFC8303</a>]</span> and <span><a href="https://rfc-editor.org/rfc/rfc8304#section-3" class="relref">Section 3</a> of [<a href="#RFC8304" class="cite xref">RFC8304</a>]</span>, which refers back to the relevant specifications for each protocol. This applies to all elements of <span>[<a href="#RFC8923" class="cite xref">RFC8923</a>]</span> (see <span><a href="https://rfc-editor.org/rfc/rfc9622#appendix-C" class="relref">Appendix C</a> of [<a href="#RFC9622" class="cite xref">RFC9622</a>]</span>): they are listed in <span><a href="https://rfc-editor.org/rfc/rfc8923#appendix-A" class="relref">Appendix A</a> of [<a href="#RFC8923" class="cite xref">RFC8923</a>]</span> with an implementation hint in the same style, pointing back to <span><a href="https://rfc-editor.org/rfc/rfc8303#section-4" class="relref">Section 4</a> of [<a href="#RFC8303" class="cite xref">RFC8303</a>]</span>.<a href="#section-10-6" class="pilcrow">¶</a></p>
<p id="section-10-7">This document presents the protocol mappings defined in <span>[<a href="#RFC8923" class="cite xref">RFC8923</a>]</span>. Other protocol mappings can be provided as separate documents, following the mapping template in <a href="#appendix-mapping-template" class="auto internal xref">Appendix A</a>.<a href="#section-10-7" class="pilcrow">¶</a></p>
<div id="tcp">
<section id="section-10.1">
        <h3 id="name-tcp">
<a href="#section-10.1" class="section-number selfRef">10.1. </a><a href="#name-tcp" class="section-name selfRef">TCP</a>
        </h3>
<span class="break"></span><dl class="dlParallel" id="section-10.1-1">
          <dt id="section-10.1-1.1">Connectedness:</dt>
          <dd style="margin-left: 1.5em" id="section-10.1-1.2">Connected<a href="#section-10.1-1.2" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-10.1-1.3">Data Unit:</dt>
          <dd style="margin-left: 1.5em" id="section-10.1-1.4">Byte-stream<a href="#section-10.1-1.4" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-10.1-1.5">Connection Object:</dt>
          <dd style="margin-left: 1.5em" id="section-10.1-1.6">
            <p id="section-10.1-1.6.1">TCP connections between two hosts map directly to Connection objects.<a href="#section-10.1-1.6.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.1-1.7">
<code>Initiate</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.1-1.8">
            <p id="section-10.1-1.8.1">CONNECT.TCP. Calling <code>Initiate</code> on a TCP connection causes it to reserve a local port and send a SYN to the Remote Endpoint.<a href="#section-10.1-1.8.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.1-1.9">
<code>InitiateWithSend</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.1-1.10">
            <p id="section-10.1-1.10.1">CONNECT.TCP with parameter <code>user message</code>. Early safely replayable data is sent on a TCP connection in the SYN, as TFO data.<a href="#section-10.1-1.10.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.1-1.11">
<code>Ready</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.1-1.12">
            <p id="section-10.1-1.12.1">A TCP connection is ready once the three-way handshake is complete.<a href="#section-10.1-1.12.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.1-1.13">
<code>EstablishmentError</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.1-1.14">
            <p id="section-10.1-1.14.1">Failure of CONNECT.TCP. TCP can throw various errors during connection setup. Specifically, it is important to handle a RST being sent by the peer during the handshake.<a href="#section-10.1-1.14.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.1-1.15">
<code>ConnectionError</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.1-1.16">
            <p id="section-10.1-1.16.1">Once established, TCP throws errors whenever the connection is disconnected, such as due to receiving a RST from the peer.<a href="#section-10.1-1.16.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.1-1.17">
<code>Listen</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.1-1.18">
            <p id="section-10.1-1.18.1">LISTEN.TCP. Calling <code>Listen</code> for TCP binds a local port and prepares it to receive inbound SYN packets from peers.<a href="#section-10.1-1.18.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.1-1.19">
<code>ConnectionReceived</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.1-1.20">
            <p id="section-10.1-1.20.1">TCP Listeners will deliver new connections once they have replied to an inbound SYN with a SYN-ACK.<a href="#section-10.1-1.20.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.1-1.21">
<code>Clone</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.1-1.22">
            <p id="section-10.1-1.22.1">Calling <code>Clone</code> on a TCP connection creates a new TCP connection with equivalent parameters. The two associated Connection objects, and Connections generated via later calls to <code>Clone</code> on an Established Connection, form a Connection Group. To realize entanglement for these Connections, with the exception of <code>connPriority</code>, changing a Connection Property on one of them must affect the Connection Properties of the others too. No guarantees of honoring the <code>connPriority</code> Connection Property are given; thus, it is safe for an implementation of a Transport Services System to ignore this Property. When it is reasonable to assume that Connections traverse the same path (e.g., when they share the same encapsulation), support for it can also experimentally be implemented using a congestion control coupling mechanism (for example, see <span>[<a href="#TCP-COUPLING" class="cite xref">TCP-COUPLING</a>]</span> or <span>[<a href="#RFC3124" class="cite xref">RFC3124</a>]</span>).<a href="#section-10.1-1.22.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.1-1.23">
<code>Send</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.1-1.24">
            <p id="section-10.1-1.24.1">SEND.TCP. On its own, TCP does not preserve Message boundaries. Calling <code>Send</code> on a TCP connection lays out the bytes on the TCP send stream without any other delineation. Any Message marked as <code>Final</code> will cause TCP to send a FIN once the Message has been completely written, by calling CLOSE.TCP immediately upon successful termination of SEND.TCP. Note that transmitting a Message marked as <code>Final</code> should not cause the <code>Closed</code> event to be delivered to the application as it will still be possible to receive data until the peer closes or aborts the TCP connection.<a href="#section-10.1-1.24.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.1-1.25">
<code>Receive</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.1-1.26">
            <p id="section-10.1-1.26.1">With RECEIVE.TCP, TCP delivers a stream of bytes without any Message delineation. All data delivered in the <code>Received</code> or <code>ReceivedPartial</code> event will be part of a single stream-wide Message that is marked <code>Final</code> (unless a Message Framer is used). The value of the <code>endOfMessage</code> Property will be delivered when the TCP connection has received a FIN (CLOSE-EVENT.TCP) from the peer. Note that reception of a FIN should not cause the <code>Closed</code> event to be delivered to the application, as it will still be possible for the application to send data.<a href="#section-10.1-1.26.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.1-1.27">
<code>Close</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.1-1.28">
            <p id="section-10.1-1.28.1">Calling <code>Close</code> on a TCP connection indicates that the TCP connection should be gracefully closed (CLOSE.TCP) by sending a FIN to the peer. It will then still be possible to receive data until the peer closes or aborts the TCP connection. The <code>Closed</code> event will be issued upon reception of a FIN.<a href="#section-10.1-1.28.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.1-1.29">
<code>Abort</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.1-1.30">
            <p id="section-10.1-1.30.1">Calling <code>Abort</code> on a TCP connection indicates that the TCP connection should be immediately closed by sending a RST to the peer (ABORT.TCP).<a href="#section-10.1-1.30.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.1-1.31">
<code>CloseGroup</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.1-1.32">
            <p id="section-10.1-1.32.1">Calling <code>CloseGroup</code> on a TCP connection (CLOSE.TCP) is identical to calling <code>Close</code> on its Connection object and on all Connections in the same ConnectionGroup.<a href="#section-10.1-1.32.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.1-1.33">
<code>AbortGroup</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.1-1.34">
            <p id="section-10.1-1.34.1">Calling <code>AbortGroup</code> on a TCP connection (ABORT.TCP) is identical to calling <code>Abort</code> on its Connection object and on all Connections in the same ConnectionGroup.<a href="#section-10.1-1.34.1" class="pilcrow">¶</a></p>
</dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
<div id="mptcp">
<section id="section-10.2">
        <h3 id="name-mptcp">
<a href="#section-10.2" class="section-number selfRef">10.2. </a><a href="#name-mptcp" class="section-name selfRef">MPTCP</a>
        </h3>
<span class="break"></span><dl class="dlParallel" id="section-10.2-1">
          <dt id="section-10.2-1.1">Connectedness:</dt>
          <dd style="margin-left: 1.5em" id="section-10.2-1.2">Connected<a href="#section-10.2-1.2" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-10.2-1.3">Data Unit:</dt>
          <dd style="margin-left: 1.5em" id="section-10.2-1.4">Byte-stream<a href="#section-10.2-1.4" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
<p id="section-10.2-2">The Transport Services API mappings for MPTCP are identical to TCP. MPTCP adds support for multipath Properties,
such as <code>multipath</code> and <code>multipathPolicy</code>, and actions for managing paths, such as <code>AddRemote</code> and <code>RemoveRemote</code>.<a href="#section-10.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="udp">
<section id="section-10.3">
        <h3 id="name-udp">
<a href="#section-10.3" class="section-number selfRef">10.3. </a><a href="#name-udp" class="section-name selfRef">UDP</a>
        </h3>
<span class="break"></span><dl class="dlParallel" id="section-10.3-1">
          <dt id="section-10.3-1.1">Connectedness:</dt>
          <dd style="margin-left: 1.5em" id="section-10.3-1.2">Connectionless<a href="#section-10.3-1.2" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-10.3-1.3">Data Unit:</dt>
          <dd style="margin-left: 1.5em" id="section-10.3-1.4">Datagram<a href="#section-10.3-1.4" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-10.3-1.5">Connection Object:</dt>
          <dd style="margin-left: 1.5em" id="section-10.3-1.6">
            <p id="section-10.3-1.6.1">UDP connections represent a pair of specific IP addresses and ports on two hosts.<a href="#section-10.3-1.6.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.3-1.7">
<code>Initiate</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.3-1.8">
            <p id="section-10.3-1.8.1">CONNECT.UDP. Calling <code>Initiate</code> on a UDP connection causes it to reserve a local port but does not generate any traffic.<a href="#section-10.3-1.8.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.3-1.9">
<code>InitiateWithSend</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.3-1.10">
            <p id="section-10.3-1.10.1">Early data on a UDP connection does not have any special meaning. The data is sent whenever the connection is <code>Ready</code>.<a href="#section-10.3-1.10.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.3-1.11">
<code>Ready</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.3-1.12">
            <p id="section-10.3-1.12.1">A UDP connection is ready once the system has reserved a local port and has a path to send to the Remote Endpoint.<a href="#section-10.3-1.12.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.3-1.13">
<code>EstablishmentError</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.3-1.14">
            <p id="section-10.3-1.14.1">UDP connections can only generate errors on initiation due to port conflicts on the local system.<a href="#section-10.3-1.14.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.3-1.15">
<code>ConnectionError</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.3-1.16">
            <p id="section-10.3-1.16.1">UDP connections can only generate Connection errors in response to <code>Abort</code> actions. (Once in use, UDP connections can also generate <code>SoftError</code> events (ERROR.UDP) upon receiving ICMP notifications indicating failures in the network.)<a href="#section-10.3-1.16.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.3-1.17">
<code>Listen</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.3-1.18">
            <p id="section-10.3-1.18.1">LISTEN.UDP. Calling <code>Listen</code> for UDP binds a local port and prepares it to receive inbound UDP datagrams from peers.<a href="#section-10.3-1.18.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.3-1.19">
<code>ConnectionReceived</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.3-1.20">
            <p id="section-10.3-1.20.1">UDP Listeners will deliver new Connections once they have received traffic from a new Remote Endpoint.<a href="#section-10.3-1.20.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.3-1.21">
<code>Clone</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.3-1.22">
            <p id="section-10.3-1.22.1">Calling <code>Clone</code> on a UDP connection creates a new UDP connection with equivalent parameters. The two associated Connection objects are otherwise independent.<a href="#section-10.3-1.22.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.3-1.23">
<code>Send</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.3-1.24">
            <p id="section-10.3-1.24.1">SEND.UDP. Calling <code>Send</code> on a UDP connection sends the data as the payload of a complete UDP datagram. Marking Messages as <code>Final</code> does not change anything in the datagram's contents. Upon sending a UDP datagram, some relevant fields and flags in the IP header can be controlled: DSCP (SET_DSCP.UDP), DF in IPv4 (SET_DF.UDP), and ECN flag (SET_ECN.UDP).<a href="#section-10.3-1.24.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.3-1.25">
<code>Receive</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.3-1.26">
            <p id="section-10.3-1.26.1">RECEIVE.UDP. UDP only delivers complete Messages to <code>Received</code>, each of which represents a single datagram received in a UDP packet. Upon receiving a UDP datagram, the ECN flag from the IP header can be obtained (GET_ECN.UDP).<a href="#section-10.3-1.26.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.3-1.27">
<code>Close</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.3-1.28">
            <p id="section-10.3-1.28.1">Calling <code>Close</code> on a UDP connection (ABORT.UDP) releases the local port reservation. A <code>Closed</code> event is then issued.<a href="#section-10.3-1.28.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.3-1.29">
<code>Abort</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.3-1.30">
            <p id="section-10.3-1.30.1">Calling <code>Abort</code> on a UDP connection (ABORT.UDP) is identical to calling <code>Close</code> except that a <code>ConnectionError</code> event rather than a <code>Closed</code> event is issued.<a href="#section-10.3-1.30.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.3-1.31">
<code>CloseGroup</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.3-1.32">
            <p id="section-10.3-1.32.1">Calling <code>CloseGroup</code> on a UDP connection (ABORT.UDP) is identical to calling <code>Close</code> on its Connection object and on all Connections in the same ConnectionGroup.<a href="#section-10.3-1.32.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.3-1.33">
<code>AbortGroup</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.3-1.34">
            <p id="section-10.3-1.34.1">Calling <code>AbortGroup</code> on a UDP connection (ABORT.UDP) is identical to calling <code>Close</code> on its Connection object and on all Connections in the same ConnectionGroup.<a href="#section-10.3-1.34.1" class="pilcrow">¶</a></p>
</dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
<div id="udp-lite">
<section id="section-10.4">
        <h3 id="name-udp-lite">
<a href="#section-10.4" class="section-number selfRef">10.4. </a><a href="#name-udp-lite" class="section-name selfRef">UDP-Lite</a>
        </h3>
<span class="break"></span><dl class="dlParallel" id="section-10.4-1">
          <dt id="section-10.4-1.1">Connectedness:</dt>
          <dd style="margin-left: 1.5em" id="section-10.4-1.2">Connectionless<a href="#section-10.4-1.2" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-10.4-1.3">Data Unit:</dt>
          <dd style="margin-left: 1.5em" id="section-10.4-1.4">Datagram<a href="#section-10.4-1.4" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
<p id="section-10.4-2">The Transport Services API mappings for UDP-Lite are identical to UDP. In addition,
UDP-Lite supports the <code>msgChecksumLen</code> and <code>recvChecksumLen</code> Properties
that allow an application to specify the minimum number of bytes in a Message that
need to be covered by a checksum.<a href="#section-10.4-2" class="pilcrow">¶</a></p>
<p id="section-10.4-3">This includes: CONNECT.UDP-Lite; LISTEN.UDP-Lite; SEND.UDP-Lite; RECEIVE.UDP-Lite; ABORT.UDP-Lite; ERROR.UDP-Lite; SET_DSCP.UDP-Lite; SET_DF.UDP-Lite; SET_ECN.UDP-Lite; GET_ECN.UDP-Lite.<a href="#section-10.4-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="udp-multicast-receive">
<section id="section-10.5">
        <h3 id="name-udp-multicast-receive">
<a href="#section-10.5" class="section-number selfRef">10.5. </a><a href="#name-udp-multicast-receive" class="section-name selfRef">UDP Multicast Receive</a>
        </h3>
<span class="break"></span><dl class="dlParallel" id="section-10.5-1">
          <dt id="section-10.5-1.1">Connectedness:</dt>
          <dd style="margin-left: 1.5em" id="section-10.5-1.2">Connectionless<a href="#section-10.5-1.2" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-10.5-1.3">Data Unit:</dt>
          <dd style="margin-left: 1.5em" id="section-10.5-1.4">Datagram<a href="#section-10.5-1.4" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-10.5-1.5">Connection Object:</dt>
          <dd style="margin-left: 1.5em" id="section-10.5-1.6">
            <p id="section-10.5-1.6.1">Established UDP Multicast Receive connections represent a pair of specific IP addresses and ports.  The <code>direction</code> Selection Property must be set to <code>Unidirectional receive</code>, and the Local Endpoint must be configured with a group IP address and a port.<a href="#section-10.5-1.6.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.5-1.7">
<code>Initiate</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.5-1.8">
            <p id="section-10.5-1.8.1">Calling <code>Initiate</code> on a UDP Multicast Receive connection causes an immediate <code>EstablishmentError</code>.  This is an unsupported operation.<a href="#section-10.5-1.8.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.5-1.9">
<code>InitiateWithSend</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.5-1.10">
            <p id="section-10.5-1.10.1">Calling <code>InitiateWithSend</code> on a UDP Multicast Receive connection causes an immediate <code>EstablishmentError</code>.  This is an unsupported operation.<a href="#section-10.5-1.10.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.5-1.11">
<code>Ready</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.5-1.12">
            <p id="section-10.5-1.12.1">A UDP Multicast Receive connection is ready once the system has received traffic for the appropriate group and port.<a href="#section-10.5-1.12.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.5-1.13">
<code>EstablishmentError</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.5-1.14">
            <p id="section-10.5-1.14.1">UDP Multicast Receive connections cause an <code>EstablishmentError</code> indicating that joining a multicast group failed if <code>Initiate</code> is called.<a href="#section-10.5-1.14.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.5-1.15">
<code>ConnectionError</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.5-1.16">
            <p id="section-10.5-1.16.1">The only <code>ConnectionError</code> generated by a UDP Multicast Receive connection is in response to an <code>Abort</code> action.<a href="#section-10.5-1.16.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.5-1.17">
<code>Listen</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.5-1.18">
            <p id="section-10.5-1.18.1">LISTEN.UDP. Calling <code>Listen</code> for UDP Multicast Receive binds a local port, prepares it to receive inbound UDP datagrams from peers, and issues a multicast host join.  If a Remote Endpoint Identifier with an address is supplied, the join is Source-Specific Multicast, and the path selection is based on the route to the Remote Endpoint.  If a Remote Endpoint Identifier is not supplied, the join is Any-Source Multicast, and the path selection is based on the outbound route to the group supplied in the Local Endpoint.<a href="#section-10.5-1.18.1" class="pilcrow">¶</a></p>
</dd>
        <dd class="break"></dd>
</dl>
<p id="section-10.5-2">There are cases where it is required to open multiple connections for the same address(es).
For example, one Connection might be opened for a multicast group used for a shared control bus,
and another application later opens a separate Connection to the same group to send signals to and/or receive signals from the common bus.
In such cases, the Transport Services System needs to explicitly enable reuse of the same set of addresses (equivalent to setting SO_REUSEADDR
in the Socket API).<a href="#section-10.5-2" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-10.5-3">
          <dt id="section-10.5-3.1">
<code>ConnectionReceived</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.5-3.2">
            <p id="section-10.5-3.2.1">UDP Multicast Receive Listeners will deliver new Connections once they have received traffic from a new Remote Endpoint.<a href="#section-10.5-3.2.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.5-3.3">
<code>Clone</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.5-3.4">
            <p id="section-10.5-3.4.1">Calling <code>Clone</code> on a UDP Multicast Receive connection creates a new UDP Multicast Receive connection with equivalent parameters. The two associated Connection objects are otherwise independent.<a href="#section-10.5-3.4.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.5-3.5">
<code>Send</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.5-3.6">
            <p id="section-10.5-3.6.1">SEND.UDP. Calling <code>Send</code> on a UDP Multicast Receive connection causes an immediate <code>SendError</code>.  This is an unsupported operation.<a href="#section-10.5-3.6.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.5-3.7">
<code>Receive</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.5-3.8">
            <p id="section-10.5-3.8.1">RECEIVE.UDP. UDP Multicast Receive only delivers complete Messages to <code>Received</code>, each of which represents a single datagram received in a UDP packet.  Upon receiving a UDP datagram, the ECN flag from the IP header can be obtained (GET_ECN.UDP).<a href="#section-10.5-3.8.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.5-3.9">
<code>Close</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.5-3.10">
            <p id="section-10.5-3.10.1">Calling <code>Close</code> on a UDP Multicast Receive connection (ABORT.UDP) releases the local port reservation and leaves the group. A <code>Closed</code> event is then issued.<a href="#section-10.5-3.10.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.5-3.11">
<code>Abort</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.5-3.12">
            <p id="section-10.5-3.12.1">Calling <code>Abort</code> on a UDP Multicast Receive connection (ABORT.UDP) is identical to calling <code>Close</code> except that a <code>ConnectionError</code> event rather than a <code>Closed</code> event is issued.<a href="#section-10.5-3.12.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.5-3.13">
<code>CloseGroup</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.5-3.14">
            <p id="section-10.5-3.14.1">Calling <code>CloseGroup</code> on a UDP Multicast Receive connection (ABORT.UDP) is identical to calling <code>Close</code> on its Connection object and on all Connections in the same ConnectionGroup.<a href="#section-10.5-3.14.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.5-3.15">
<code>AbortGroup</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.5-3.16">
            <p id="section-10.5-3.16.1">Calling <code>AbortGroup</code> on a UDP Multicast Receive connection (ABORT.UDP) is identical to calling <code>Close</code>
on its Connection object and on all Connections in the same ConnectionGroup.<a href="#section-10.5-3.16.1" class="pilcrow">¶</a></p>
</dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
<div id="sctp">
<section id="section-10.6">
        <h3 id="name-sctp">
<a href="#section-10.6" class="section-number selfRef">10.6. </a><a href="#name-sctp" class="section-name selfRef">SCTP</a>
        </h3>
<span class="break"></span><dl class="dlParallel" id="section-10.6-1">
          <dt id="section-10.6-1.1">Connectedness:</dt>
          <dd style="margin-left: 1.5em" id="section-10.6-1.2">Connected<a href="#section-10.6-1.2" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-10.6-1.3">Data Unit:</dt>
          <dd style="margin-left: 1.5em" id="section-10.6-1.4">Message<a href="#section-10.6-1.4" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-10.6-1.5">Connection Object:</dt>
          <dd style="margin-left: 1.5em" id="section-10.6-1.6">
            <p id="section-10.6-1.6.1">Connection objects can be mapped to an SCTP association or a stream in an SCTP association. Mapping Connection objects to SCTP streams is called "stream mapping" and has additional requirements as follows. The following explanation assumes a client-server communication model.<a href="#section-10.6-1.6.1" class="pilcrow">¶</a></p>
<p id="section-10.6-1.6.2">Stream mapping requires an association to already be in place between the client and the server, and it requires the server to understand that a new incoming stream should be represented as a new Connection object by the Transport Services System. A new SCTP stream is created by sending an SCTP message with a new stream id. Thus, to implement stream mapping, the Transport Services API must provide a newly created Connection object to the application upon the reception of such a message. The necessary semantics to implement a Transport Services System's <code>Close</code> and <code>Abort</code> primitives are provided by the stream reconfiguration (reset) procedure described in <span>[<a href="#RFC6525" class="cite xref">RFC6525</a>]</span>. This also allows a stream id to be reused after resetting ("closing") the stream. To implement this functionality, SCTP stream reconfiguration <span>[<a href="#RFC6525" class="cite xref">RFC6525</a>]</span> must be supported by both the client and the server side.<a href="#section-10.6-1.6.2" class="pilcrow">¶</a></p>
<p id="section-10.6-1.6.3">To avoid head-of-line blocking, stream mapping should only be implemented when both sides support message interleaving <span>[<a href="#RFC8260" class="cite xref">RFC8260</a>]</span>. This allows a sender to schedule transmissions between multiple streams without risking that transmission of a large message on one stream will block transmissions on other streams for a long time.<a href="#section-10.6-1.6.3" class="pilcrow">¶</a></p>
<p id="section-10.6-1.6.4">To avoid conflicts between stream ids, the following procedure is recommended: the first Connection, for which the SCTP association has been created, must always use stream id zero. All additional Connections are assigned to unused stream ids in ascending order. To avoid a conflict when both endpoints map new Connections simultaneously, the peer that initiated association must use even stream ids whereas the remote side must map its Connections to odd stream ids. Both sides maintain a status map of the assigned stream ids. Generally, new streams should consume the lowest available (even or odd, depending on the side) stream id; this rule is relevant when lower stream ids become available because Connection objects associated with the streams are closed.<a href="#section-10.6-1.6.4" class="pilcrow">¶</a></p>
<p id="section-10.6-1.6.5">SCTP stream mapping as described here has been implemented in a research prototype; a description of this implementation is given in <span>[<a href="#NEAT-flow-mapping" class="cite xref">NEAT-flow-mapping</a>]</span>.<a href="#section-10.6-1.6.5" class="pilcrow">¶</a></p>
</dd>
        <dd class="break"></dd>
</dl>
<span class="break"></span><dl class="dlParallel" id="section-10.6-2">
          <dt id="section-10.6-2.1">
<code>Initiate</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.6-2.2">
            <p id="section-10.6-2.2.1">If this is the only Connection object that is assigned to the SCTP association or stream mapping is
not used, CONNECT.SCTP is called. Else, unless the Selection Property <code>activeReadBeforeSend</code>
is preferred or required, a new stream is used: if there are enough streams
available, <code>Initiate</code> is a local operation that assigns a new stream id to the Connection object.
The number of streams is negotiated as a parameter of the prior CONNECT.SCTP call, and it represents a
trade-off between local resource usage and the number of Connection objects that can be mapped
without requiring a reconfiguration signal. When running out of streams, ADD_STREAM.SCTP must be called.<a href="#section-10.6-2.2.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.6-2.3">
<code>InitiateWithSend</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.6-2.4">
            <p id="section-10.6-2.4.1">If this is the only Connection object that is assigned to the SCTP association or stream mapping is not used, CONNECT.SCTP is called with the <code>user message</code> parameter. Else, a new stream
is used (see <code>Initiate</code> for how to handle running out of streams), and this just sends the first message
on a new stream.<a href="#section-10.6-2.4.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.6-2.5">
<code>Ready</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.6-2.6">
            <p id="section-10.6-2.6.1"><code>Initiate</code> or <code>InitiateWithSend</code> returns without an error, i.e., SCTP's four-way handshake has completed. If an association with the peer already exists, stream mapping is used, and enough streams are available, a Connection object instantly becomes <code>Ready</code> after calling <code>Initiate</code> or <code>InitiateWithSend</code>.<a href="#section-10.6-2.6.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.6-2.7">
<code>EstablishmentError</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.6-2.8">
            <p id="section-10.6-2.8.1">Failure of CONNECT.SCTP.<a href="#section-10.6-2.8.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.6-2.9">
<code>ConnectionError</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.6-2.10">
            <p id="section-10.6-2.10.1">TIMEOUT.SCTP or ABORT-EVENT.SCTP.<a href="#section-10.6-2.10.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.6-2.11">
<code>Listen</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.6-2.12">
            <p id="section-10.6-2.12.1">LISTEN.SCTP. If an association with the peer already exists and stream mapping is used, <code>Listen</code> just expects to receive a new message with a new stream id (chosen in accordance with the stream id assignment procedure described above).<a href="#section-10.6-2.12.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.6-2.13">
<code>ConnectionReceived</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.6-2.14">
            <p id="section-10.6-2.14.1">LISTEN.SCTP returns without an error (a result of successful CONNECT.SCTP from the peer) or, in the case of stream mapping, the first message has arrived on a new stream (in this case, <code>Receive</code> is also invoked).<a href="#section-10.6-2.14.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.6-2.15">
<code>Clone</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.6-2.16">
            <p id="section-10.6-2.16.1">Calling <code>Clone</code> on an SCTP association creates a new Connection object and assigns it a new stream id in accordance with the stream id assignment procedure described above. If there are not enough streams available, ADD_STREAM.SCTP must be called.<a href="#section-10.6-2.16.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.6-2.17">
<code>Send</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.6-2.18">
            <p id="section-10.6-2.18.1">SEND.SCTP. Message Properties such as <code>msgLifetime</code> and <code>msgOrdered</code> map to parameters of this primitive.<a href="#section-10.6-2.18.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.6-2.19">
<code>Receive</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.6-2.20">
            <p id="section-10.6-2.20.1">RECEIVE.SCTP. The "partial flag" of RECEIVE.SCTP invokes a <code>ReceivedPartial</code> event.<a href="#section-10.6-2.20.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-10.6-2.21">
<code>Close</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.6-2.22">If this is the only Connection object that is assigned to the SCTP association, CLOSE.SCTP is called and the <code>Closed</code> event will be delivered to the application upon the ensuing CLOSE-EVENT.SCTP. Else, the Connection object is one out of several Connection objects that are assigned to the same SCTP association, and RESET_STREAM.SCTP must be called, which informs the peer that the stream will no longer be used for mapping and can be used by a future <code>Initiate</code>, <code>InitiateWithSend</code>, or <code>Listen</code> action. At the peer, the event RESET_STREAM-EVENT.SCTP will be initiated, which the peer must answer by issuing RESET_STREAM.SCTP too. The resulting local RESET_STREAM-EVENT.SCTP informs the Transport Services System that the stream id can now be reused by the next <code>Initiate</code>, <code>InitiateWithSend</code>, or <code>Listen</code> action, and invokes a <code>Closed</code> event toward the application.<a href="#section-10.6-2.22" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-10.6-2.23">
<code>Abort</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.6-2.24">If this is the only Connection object that is assigned to the SCTP association, ABORT.SCTP is called. Else, the Connection object is one out of several Connection objects that are assigned to the same SCTP association, and shutdown proceeds as described under <code>Close</code>.<a href="#section-10.6-2.24" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-10.6-2.25">
<code>CloseGroup</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.6-2.26">Calling <code>CloseGroup</code> calls CLOSE.SCTP, which closes all Connections in the SCTP association.<a href="#section-10.6-2.26" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-10.6-2.27">
<code>AbortGroup</code>:</dt>
          <dd style="margin-left: 1.5em" id="section-10.6-2.28">Calling <code>AbortGroup</code> calls ABORT.SCTP, which immediately closes all Connections in the SCTP association.<a href="#section-10.6-2.28" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
<p id="section-10.6-3">In addition to the API mappings described above, when there are multiple Connection objects assigned to the same SCTP association, SCTP can support Connection Properties such as <code>connPriority</code> and <code>connScheduler</code> where CONFIGURE_STREAM_SCHEDULER.SCTP can be called to adjust the priorities of streams in the SCTP association.<a href="#section-10.6-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="iana-considerations">
<section id="section-11">
      <h2 id="name-iana-considerations">
<a href="#section-11" class="section-number selfRef">11. </a><a href="#name-iana-considerations" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-11-1">This document has no IANA actions.<a href="#section-11-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="security-considerations">
<section id="section-12">
      <h2 id="name-security-considerations">
<a href="#section-12" class="section-number selfRef">12. </a><a href="#name-security-considerations" class="section-name selfRef">Security Considerations</a>
      </h2>
<p id="section-12-1"><span>[<a href="#RFC9621" class="cite xref">RFC9621</a>]</span> outlines general security considerations and requirements for any system that implements the Transport Services Architecture. <span>[<a href="#RFC9622" class="cite xref">RFC9622</a>]</span> provides further discussion on security and privacy implications of the Transport Services API. This document provides additional guidance on implementation specifics for the Transport Services API; as such, the security considerations in both of these documents apply. The next two subsections discuss further considerations that are specific to mechanisms specified in this document.<a href="#section-12-1" class="pilcrow">¶</a></p>
<div id="considerations-for-candidate-gathering">
<section id="section-12.1">
        <h3 id="name-considerations-for-candidat">
<a href="#section-12.1" class="section-number selfRef">12.1. </a><a href="#name-considerations-for-candidat" class="section-name selfRef">Considerations for Candidate Gathering</a>
        </h3>
<p id="section-12.1-1">As discussed in Sections <a href="https://rfc-editor.org/rfc/rfc9621#section-3" class="relref">3</a> and <a href="https://rfc-editor.org/rfc/rfc9621#section-6" class="relref">6</a> of <span>[<a href="#RFC9621" class="cite xref">RFC9621</a>]</span>, gathering and racing with Protocol Stacks that do not have equivalent security properties ought not be attempted. Therefore, implementations need to avoid downgrade attacks that allow network interference to cause the implementation to select less secure, or entirely insecure, combinations of paths and protocols.<a href="#section-12.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="considerations-for-candidate-racing">
<section id="section-12.2">
        <h3 id="name-considerations-for-candidate">
<a href="#section-12.2" class="section-number selfRef">12.2. </a><a href="#name-considerations-for-candidate" class="section-name selfRef">Considerations for Candidate Racing</a>
        </h3>
<p id="section-12.2-1">See <a href="#fastopen" class="auto internal xref">Section 5.3</a> for security considerations around racing with 0-RTT data.<a href="#section-12.2-1" class="pilcrow">¶</a></p>
<p id="section-12.2-2">An attacker that knows a particular device is racing several options during Connection establishment may be able to block packets for the first connection attempt, thus inducing the device to fall back to a secondary attempt. This is a problem if the secondary attempts have worse security properties that enable further attacks. Implementations should ensure that all options have equivalent security properties to avoid incentivizing attacks.<a href="#section-12.2-2" class="pilcrow">¶</a></p>
<p id="section-12.2-3">Since results from the network can determine how a connection attempt tree is built, such as when DNS returns a list of resolved endpoints, it is possible for the network to cause an implementation to consume significant on-device resources. Implementations should limit the maximum amount of state allowed for any given node, including the number of child nodes, especially when the state is based on results from the network.<a href="#section-12.2-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<section id="section-13">
      <h2 id="name-references">
<a href="#section-13" class="section-number selfRef">13. </a><a href="#name-references" class="section-name selfRef">References</a>
      </h2>
<div id="sec-normative-references">
<section id="section-13.1">
        <h3 id="name-normative-references">
<a href="#section-13.1" class="section-number selfRef">13.1. </a><a href="#name-normative-references" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="RFC7413">[RFC7413]</dt>
        <dd>
<span class="refAuthor">Cheng, Y.</span>, <span class="refAuthor">Chu, J.</span>, <span class="refAuthor">Radhakrishnan, S.</span>, and <span class="refAuthor">A. Jain</span>, <span class="refTitle">"TCP Fast Open"</span>, <span class="seriesInfo">RFC 7413</span>, <span class="seriesInfo">DOI 10.17487/RFC7413</span>, <time datetime="2014-12" class="refDate">December 2014</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7413">https://www.rfc-editor.org/info/rfc7413</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8303">[RFC8303]</dt>
        <dd>
<span class="refAuthor">Welzl, M.</span>, <span class="refAuthor">Tuexen, M.</span>, and <span class="refAuthor">N. Khademi</span>, <span class="refTitle">"On the Usage of Transport Features Provided by IETF Transport Protocols"</span>, <span class="seriesInfo">RFC 8303</span>, <span class="seriesInfo">DOI 10.17487/RFC8303</span>, <time datetime="2018-02" class="refDate">February 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8303">https://www.rfc-editor.org/info/rfc8303</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8304">[RFC8304]</dt>
        <dd>
<span class="refAuthor">Fairhurst, G.</span> and <span class="refAuthor">T. Jones</span>, <span class="refTitle">"Transport Features of the User Datagram Protocol (UDP) and Lightweight UDP (UDP-Lite)"</span>, <span class="seriesInfo">RFC 8304</span>, <span class="seriesInfo">DOI 10.17487/RFC8304</span>, <time datetime="2018-02" class="refDate">February 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8304">https://www.rfc-editor.org/info/rfc8304</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8305">[RFC8305]</dt>
        <dd>
<span class="refAuthor">Schinazi, D.</span> and <span class="refAuthor">T. Pauly</span>, <span class="refTitle">"Happy Eyeballs Version 2: Better Connectivity Using Concurrency"</span>, <span class="seriesInfo">RFC 8305</span>, <span class="seriesInfo">DOI 10.17487/RFC8305</span>, <time datetime="2017-12" class="refDate">December 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8305">https://www.rfc-editor.org/info/rfc8305</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8421">[RFC8421]</dt>
        <dd>
<span class="refAuthor">Martinsen, P.</span>, <span class="refAuthor">Reddy, T.</span>, and <span class="refAuthor">P. Patil</span>, <span class="refTitle">"Guidelines for Multihomed and IPv4/IPv6 Dual-Stack Interactive Connectivity Establishment (ICE)"</span>, <span class="seriesInfo">BCP 217</span>, <span class="seriesInfo">RFC 8421</span>, <span class="seriesInfo">DOI 10.17487/RFC8421</span>, <time datetime="2018-07" class="refDate">July 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8421">https://www.rfc-editor.org/info/rfc8421</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8446">[RFC8446]</dt>
        <dd>
<span class="refAuthor">Rescorla, E.</span>, <span class="refTitle">"The Transport Layer Security (TLS) Protocol Version 1.3"</span>, <span class="seriesInfo">RFC 8446</span>, <span class="seriesInfo">DOI 10.17487/RFC8446</span>, <time datetime="2018-08" class="refDate">August 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8446">https://www.rfc-editor.org/info/rfc8446</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8923">[RFC8923]</dt>
        <dd>
<span class="refAuthor">Welzl, M.</span> and <span class="refAuthor">S. Gjessing</span>, <span class="refTitle">"A Minimal Set of Transport Services for End Systems"</span>, <span class="seriesInfo">RFC 8923</span>, <span class="seriesInfo">DOI 10.17487/RFC8923</span>, <time datetime="2020-10" class="refDate">October 2020</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8923">https://www.rfc-editor.org/info/rfc8923</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9113">[RFC9113]</dt>
        <dd>
<span class="refAuthor">Thomson, M., Ed.</span> and <span class="refAuthor">C. Benfield, Ed.</span>, <span class="refTitle">"HTTP/2"</span>, <span class="seriesInfo">RFC 9113</span>, <span class="seriesInfo">DOI 10.17487/RFC9113</span>, <time datetime="2022-06" class="refDate">June 2022</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9113">https://www.rfc-editor.org/info/rfc9113</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9621">[RFC9621]</dt>
        <dd>
<span class="refAuthor">Pauly, T., Ed.</span>, <span class="refAuthor">Trammell, B., Ed.</span>, <span class="refAuthor">Brunstrom, A.</span>, <span class="refAuthor">Fairhurst, G.</span>, and <span class="refAuthor">C. S. Perkins</span>, <span class="refTitle">"Architecture and Requirements for Transport Services"</span>, <span class="seriesInfo">RFC 9621</span>, <span class="seriesInfo">DOI 10.17487/RFC9621</span>, <time datetime="2025-01" class="refDate">January 2025</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9621">https://www.rfc-editor.org/info/rfc9621</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9622">[RFC9622]</dt>
      <dd>
<span class="refAuthor">Trammell, B., Ed.</span>, <span class="refAuthor">Welzl, M., Ed.</span>, <span class="refAuthor">Enghardt, R.</span>, <span class="refAuthor">Fairhurst, G.</span>, <span class="refAuthor">Kühlewind, M.</span>, <span class="refAuthor">Perkins, C. S.</span>, <span class="refAuthor">Tiesel, P. S.</span>, and <span class="refAuthor">T. Pauly</span>, <span class="refTitle">"An Abstract Application Programming Interface (API) for Transport Services"</span>, <span class="seriesInfo">RFC 9622</span>, <span class="seriesInfo">DOI 10.17487/RFC9622</span>, <time datetime="2025-01" class="refDate">January 2025</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9622">https://www.rfc-editor.org/info/rfc9622</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</div>
<div id="sec-informative-references">
<section id="section-13.2">
        <h3 id="name-informative-references">
<a href="#section-13.2" class="section-number selfRef">13.2. </a><a href="#name-informative-references" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="NEAT-flow-mapping">[NEAT-flow-mapping]</dt>
        <dd>
<span class="refAuthor">Weinrank, F.</span> and <span class="refAuthor">M. Tuxen</span>, <span class="refTitle">"Transparent flow mapping for NEAT"</span>, <span class="refContent">2017 IFIP Networking Conference (IFIP Networking) and Workshops</span>, <span class="seriesInfo">DOI 10.23919/IFIPNetworking.2017.8264876</span>, <time datetime="2017-06" class="refDate">June 2017</time>, <span>&lt;<a href="https://ieeexplore.ieee.org/document/8264876">https://ieeexplore.ieee.org/document/8264876</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC1928">[RFC1928]</dt>
        <dd>
<span class="refAuthor">Leech, M.</span>, <span class="refAuthor">Ganis, M.</span>, <span class="refAuthor">Lee, Y.</span>, <span class="refAuthor">Kuris, R.</span>, <span class="refAuthor">Koblas, D.</span>, and <span class="refAuthor">L. Jones</span>, <span class="refTitle">"SOCKS Protocol Version 5"</span>, <span class="seriesInfo">RFC 1928</span>, <span class="seriesInfo">DOI 10.17487/RFC1928</span>, <time datetime="1996-03" class="refDate">March 1996</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc1928">https://www.rfc-editor.org/info/rfc1928</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC2782">[RFC2782]</dt>
        <dd>
<span class="refAuthor">Gulbrandsen, A.</span>, <span class="refAuthor">Vixie, P.</span>, and <span class="refAuthor">L. Esibov</span>, <span class="refTitle">"A DNS RR for specifying the location of services (DNS SRV)"</span>, <span class="seriesInfo">RFC 2782</span>, <span class="seriesInfo">DOI 10.17487/RFC2782</span>, <time datetime="2000-02" class="refDate">February 2000</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2782">https://www.rfc-editor.org/info/rfc2782</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3124">[RFC3124]</dt>
        <dd>
<span class="refAuthor">Balakrishnan, H.</span> and <span class="refAuthor">S. Seshan</span>, <span class="refTitle">"The Congestion Manager"</span>, <span class="seriesInfo">RFC 3124</span>, <span class="seriesInfo">DOI 10.17487/RFC3124</span>, <time datetime="2001-06" class="refDate">June 2001</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3124">https://www.rfc-editor.org/info/rfc3124</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3207">[RFC3207]</dt>
        <dd>
<span class="refAuthor">Hoffman, P.</span>, <span class="refTitle">"SMTP Service Extension for Secure SMTP over Transport Layer Security"</span>, <span class="seriesInfo">RFC 3207</span>, <span class="seriesInfo">DOI 10.17487/RFC3207</span>, <time datetime="2002-02" class="refDate">February 2002</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3207">https://www.rfc-editor.org/info/rfc3207</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6525">[RFC6525]</dt>
        <dd>
<span class="refAuthor">Stewart, R.</span>, <span class="refAuthor">Tuexen, M.</span>, and <span class="refAuthor">P. Lei</span>, <span class="refTitle">"Stream Control Transmission Protocol (SCTP) Stream Reconfiguration"</span>, <span class="seriesInfo">RFC 6525</span>, <span class="seriesInfo">DOI 10.17487/RFC6525</span>, <time datetime="2012-02" class="refDate">February 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6525">https://www.rfc-editor.org/info/rfc6525</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6762">[RFC6762]</dt>
        <dd>
<span class="refAuthor">Cheshire, S.</span> and <span class="refAuthor">M. Krochmal</span>, <span class="refTitle">"Multicast DNS"</span>, <span class="seriesInfo">RFC 6762</span>, <span class="seriesInfo">DOI 10.17487/RFC6762</span>, <time datetime="2013-02" class="refDate">February 2013</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6762">https://www.rfc-editor.org/info/rfc6762</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6763">[RFC6763]</dt>
        <dd>
<span class="refAuthor">Cheshire, S.</span> and <span class="refAuthor">M. Krochmal</span>, <span class="refTitle">"DNS-Based Service Discovery"</span>, <span class="seriesInfo">RFC 6763</span>, <span class="seriesInfo">DOI 10.17487/RFC6763</span>, <time datetime="2013-02" class="refDate">February 2013</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6763">https://www.rfc-editor.org/info/rfc6763</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7657">[RFC7657]</dt>
        <dd>
<span class="refAuthor">Black, D., Ed.</span> and <span class="refAuthor">P. Jones</span>, <span class="refTitle">"Differentiated Services (Diffserv) and Real-Time Communication"</span>, <span class="seriesInfo">RFC 7657</span>, <span class="seriesInfo">DOI 10.17487/RFC7657</span>, <time datetime="2015-11" class="refDate">November 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7657">https://www.rfc-editor.org/info/rfc7657</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8085">[RFC8085]</dt>
        <dd>
<span class="refAuthor">Eggert, L.</span>, <span class="refAuthor">Fairhurst, G.</span>, and <span class="refAuthor">G. Shepherd</span>, <span class="refTitle">"UDP Usage Guidelines"</span>, <span class="seriesInfo">BCP 145</span>, <span class="seriesInfo">RFC 8085</span>, <span class="seriesInfo">DOI 10.17487/RFC8085</span>, <time datetime="2017-03" class="refDate">March 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8085">https://www.rfc-editor.org/info/rfc8085</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8260">[RFC8260]</dt>
        <dd>
<span class="refAuthor">Stewart, R.</span>, <span class="refAuthor">Tuexen, M.</span>, <span class="refAuthor">Loreto, S.</span>, and <span class="refAuthor">R. Seggelmann</span>, <span class="refTitle">"Stream Schedulers and User Message Interleaving for the Stream Control Transmission Protocol"</span>, <span class="seriesInfo">RFC 8260</span>, <span class="seriesInfo">DOI 10.17487/RFC8260</span>, <time datetime="2017-11" class="refDate">November 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8260">https://www.rfc-editor.org/info/rfc8260</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8445">[RFC8445]</dt>
        <dd>
<span class="refAuthor">Keranen, A.</span>, <span class="refAuthor">Holmberg, C.</span>, and <span class="refAuthor">J. Rosenberg</span>, <span class="refTitle">"Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal"</span>, <span class="seriesInfo">RFC 8445</span>, <span class="seriesInfo">DOI 10.17487/RFC8445</span>, <time datetime="2018-07" class="refDate">July 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8445">https://www.rfc-editor.org/info/rfc8445</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8489">[RFC8489]</dt>
        <dd>
<span class="refAuthor">Petit-Huguenin, M.</span>, <span class="refAuthor">Salgueiro, G.</span>, <span class="refAuthor">Rosenberg, J.</span>, <span class="refAuthor">Wing, D.</span>, <span class="refAuthor">Mahy, R.</span>, and <span class="refAuthor">P. Matthews</span>, <span class="refTitle">"Session Traversal Utilities for NAT (STUN)"</span>, <span class="seriesInfo">RFC 8489</span>, <span class="seriesInfo">DOI 10.17487/RFC8489</span>, <time datetime="2020-02" class="refDate">February 2020</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8489">https://www.rfc-editor.org/info/rfc8489</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8656">[RFC8656]</dt>
        <dd>
<span class="refAuthor">Reddy, T., Ed.</span>, <span class="refAuthor">Johnston, A., Ed.</span>, <span class="refAuthor">Matthews, P.</span>, and <span class="refAuthor">J. Rosenberg</span>, <span class="refTitle">"Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)"</span>, <span class="seriesInfo">RFC 8656</span>, <span class="seriesInfo">DOI 10.17487/RFC8656</span>, <time datetime="2020-02" class="refDate">February 2020</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8656">https://www.rfc-editor.org/info/rfc8656</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9000">[RFC9000]</dt>
        <dd>
<span class="refAuthor">Iyengar, J., Ed.</span> and <span class="refAuthor">M. Thomson, Ed.</span>, <span class="refTitle">"QUIC: A UDP-Based Multiplexed and Secure Transport"</span>, <span class="seriesInfo">RFC 9000</span>, <span class="seriesInfo">DOI 10.17487/RFC9000</span>, <time datetime="2021-05" class="refDate">May 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9000">https://www.rfc-editor.org/info/rfc9000</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9040">[RFC9040]</dt>
        <dd>
<span class="refAuthor">Touch, J.</span>, <span class="refAuthor">Welzl, M.</span>, and <span class="refAuthor">S. Islam</span>, <span class="refTitle">"TCP Control Block Interdependence"</span>, <span class="seriesInfo">RFC 9040</span>, <span class="seriesInfo">DOI 10.17487/RFC9040</span>, <time datetime="2021-07" class="refDate">July 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9040">https://www.rfc-editor.org/info/rfc9040</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9110">[RFC9110]</dt>
        <dd>
<span class="refAuthor">Fielding, R., Ed.</span>, <span class="refAuthor">Nottingham, M., Ed.</span>, and <span class="refAuthor">J. Reschke, Ed.</span>, <span class="refTitle">"HTTP Semantics"</span>, <span class="seriesInfo">STD 97</span>, <span class="seriesInfo">RFC 9110</span>, <span class="seriesInfo">DOI 10.17487/RFC9110</span>, <time datetime="2022-06" class="refDate">June 2022</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9110">https://www.rfc-editor.org/info/rfc9110</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9460">[RFC9460]</dt>
        <dd>
<span class="refAuthor">Schwartz, B.</span>, <span class="refAuthor">Bishop, M.</span>, and <span class="refAuthor">E. Nygren</span>, <span class="refTitle">"Service Binding and Parameter Specification via the DNS (SVCB and HTTPS Resource Records)"</span>, <span class="seriesInfo">RFC 9460</span>, <span class="seriesInfo">DOI 10.17487/RFC9460</span>, <time datetime="2023-11" class="refDate">November 2023</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9460">https://www.rfc-editor.org/info/rfc9460</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="TCP-COUPLING">[TCP-COUPLING]</dt>
      <dd>
<span class="refAuthor">Islam, S.</span>, <span class="refAuthor">Welzl, M.</span>, <span class="refAuthor">Hiorth, K.</span>, <span class="refAuthor">Hayes, D.</span>, <span class="refAuthor">Armitage, G.</span>, and <span class="refAuthor">S. Gjessing</span>, <span class="refTitle">"ctrlTCP: Reducing latency through coupled, heterogeneous multi-flow TCP congestion control"</span>, <span class="refContent">IEEE INFOCOM 2018 - IEEE Conference on Computer Communications Workshops (INFOCOM WKSHPS)</span>, <span class="seriesInfo">DOI 10.1109/INFCOMW.2018.8406887</span>, <time datetime="2018" class="refDate">2018</time>, <span>&lt;<a href="https://ieeexplore.ieee.org/document/8406887">https://ieeexplore.ieee.org/document/8406887</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</div>
</section>
<div id="appendix-mapping-template">
<section id="appendix-A">
      <h2 id="name-api-mapping-template">
<a href="#appendix-A" class="section-number selfRef">Appendix A. </a><a href="#name-api-mapping-template" class="section-name selfRef">API Mapping Template</a>
      </h2>
<p id="appendix-A-1">Any protocol mapping for the Transport Services API should follow a common template.<a href="#appendix-A-1" class="pilcrow">¶</a></p>
<p id="appendix-A-2">Connectedness: (Connectionless/Connected/Multiplexing Connected)<a href="#appendix-A-2" class="pilcrow">¶</a></p>
<p id="appendix-A-3">Data Unit: (Byte-stream/Datagram/Message)<a href="#appendix-A-3" class="pilcrow">¶</a></p>
<p id="appendix-A-4">Connection Object:<a href="#appendix-A-4" class="pilcrow">¶</a></p>
<p id="appendix-A-5"><code>Initiate</code>:<a href="#appendix-A-5" class="pilcrow">¶</a></p>
<p id="appendix-A-6"><code>InitiateWithSend</code>:<a href="#appendix-A-6" class="pilcrow">¶</a></p>
<p id="appendix-A-7"><code>Ready</code>:<a href="#appendix-A-7" class="pilcrow">¶</a></p>
<p id="appendix-A-8"><code>EstablishmentError</code>:<a href="#appendix-A-8" class="pilcrow">¶</a></p>
<p id="appendix-A-9"><code>ConnectionError</code>:<a href="#appendix-A-9" class="pilcrow">¶</a></p>
<p id="appendix-A-10"><code>Listen</code>:<a href="#appendix-A-10" class="pilcrow">¶</a></p>
<p id="appendix-A-11"><code>ConnectionReceived</code>:<a href="#appendix-A-11" class="pilcrow">¶</a></p>
<p id="appendix-A-12"><code>Clone</code>:<a href="#appendix-A-12" class="pilcrow">¶</a></p>
<p id="appendix-A-13"><code>Send</code>:<a href="#appendix-A-13" class="pilcrow">¶</a></p>
<p id="appendix-A-14"><code>Receive</code>:<a href="#appendix-A-14" class="pilcrow">¶</a></p>
<p id="appendix-A-15"><code>Close</code>:<a href="#appendix-A-15" class="pilcrow">¶</a></p>
<p id="appendix-A-16"><code>Abort</code>:<a href="#appendix-A-16" class="pilcrow">¶</a></p>
<p id="appendix-A-17"><code>CloseGroup</code>:<a href="#appendix-A-17" class="pilcrow">¶</a></p>
<p id="appendix-A-18"><code>AbortGroup</code>:<a href="#appendix-A-18" class="pilcrow">¶</a></p>
</section>
</div>
<div id="appendix-reasons-errors">
<section id="appendix-B">
      <h2 id="name-reasons-for-errors">
<a href="#appendix-B" class="section-number selfRef">Appendix B. </a><a href="#name-reasons-for-errors" class="section-name selfRef">Reasons for Errors</a>
      </h2>
<p id="appendix-B-1">The Transport Services API <span>[<a href="#RFC9622" class="cite xref">RFC9622</a>]</span> allows for several generic error types to specify a more detailed reason about why an error occurred. This appendix lists some of the possible reasons.<a href="#appendix-B-1" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="appendix-B-2">
        <dt id="appendix-B-2.1">InvalidConfiguration:</dt>
        <dd style="margin-left: 1.5em" id="appendix-B-2.2">
The Properties and Endpoint Identifiers provided by the application are either contradictory or incomplete. Examples include the lack of a Remote Endpoint Identifier on an active open or using a multicast group address while not requesting a <code>Unidirectional receive</code>.<a href="#appendix-B-2.2" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-2.3">NoCandidates:</dt>
        <dd style="margin-left: 1.5em" id="appendix-B-2.4">
The configuration is valid, but none of the available transport protocols can satisfy the Properties provided by the application.<a href="#appendix-B-2.4" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-2.5">ResolutionFailed:</dt>
        <dd style="margin-left: 1.5em" id="appendix-B-2.6">
The remote or local specifier provided by the application cannot be resolved.<a href="#appendix-B-2.6" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-2.7">EstablishmentFailed:</dt>
        <dd style="margin-left: 1.5em" id="appendix-B-2.8">
The Transport Services System was unable to establish a transport-layer connection to the Remote Endpoint specified by the application.<a href="#appendix-B-2.8" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-2.9">PolicyProhibited:</dt>
        <dd style="margin-left: 1.5em" id="appendix-B-2.10">
The System Policy prevents the Transport Services System from performing the action requested by the application.<a href="#appendix-B-2.10" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-2.11">NotCloneable:</dt>
        <dd style="margin-left: 1.5em" id="appendix-B-2.12">
The Protocol Stack is not capable of being cloned.<a href="#appendix-B-2.12" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-2.13">MessageTooLarge:</dt>
        <dd style="margin-left: 1.5em" id="appendix-B-2.14">
The Message is too big for the Transport Services System to handle.<a href="#appendix-B-2.14" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-2.15">ProtocolFailed:</dt>
        <dd style="margin-left: 1.5em" id="appendix-B-2.16">
The underlying Protocol Stack failed.<a href="#appendix-B-2.16" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-2.17">InvalidMessageProperties:</dt>
        <dd style="margin-left: 1.5em" id="appendix-B-2.18">
The Message Properties either contradict the Transport Properties or cannot be satisfied by the Transport Services System.<a href="#appendix-B-2.18" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-2.19">DeframingFailed:</dt>
        <dd style="margin-left: 1.5em" id="appendix-B-2.20">
The data that was received by the underlying Protocol Stack could not be processed by the Message Framer.<a href="#appendix-B-2.20" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-2.21">ConnectionAborted:</dt>
        <dd style="margin-left: 1.5em" id="appendix-B-2.22">
The connection was aborted by the peer.<a href="#appendix-B-2.22" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-2.23">Timeout:</dt>
        <dd style="margin-left: 1.5em" id="appendix-B-2.24">
Delivery of a Message was not possible after a timeout.<a href="#appendix-B-2.24" class="pilcrow">¶</a>
</dd>
      <dd class="break"></dd>
</dl>
</section>
</div>
<div id="appendix-implementations">
<section id="appendix-C">
      <h2 id="name-existing-implementations">
<a href="#appendix-C" class="section-number selfRef">Appendix C. </a><a href="#name-existing-implementations" class="section-name selfRef">Existing Implementations</a>
      </h2>
<p id="appendix-C-1">This appendix gives an overview of existing implementations, at the time of writing, of Transport Services Systems that are (to some degree) in line with this document.<a href="#appendix-C-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-C-2.1">
          <p id="appendix-C-2.1.1">Apple's Network.framework:<a href="#appendix-C-2.1.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-C-2.1.2.1">
              <p id="appendix-C-2.1.2.1.1">Network.framework is a transport-level API built for C, Objective-C, and Swift. It is a connect-by-name API that supports transport security protocols. It provides user-space implementations of TCP, UDP, TLS, DTLS, and proxy protocols, and it allows extension via custom Framers.<a href="#appendix-C-2.1.2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="appendix-C-2.1.2.2">
              <p id="appendix-C-2.1.2.2.1">Documentation: <span><a href="https://developer.apple.com/documentation/network">https://developer.apple.com/documentation/network</a></span><a href="#appendix-C-2.1.2.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
</li>
        <li class="normal" id="appendix-C-2.2">
          <p id="appendix-C-2.2.1">NEAT and NEATPy:<a href="#appendix-C-2.2.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-C-2.2.2.1">
              <p id="appendix-C-2.2.2.1.1">NEAT is the output of the European H2020 research project "NEAT"; it is a user-space library for protocol-independent communication on top of TCP, UDP, and SCTP, with many more features, such as a policy manager.<a href="#appendix-C-2.2.2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="appendix-C-2.2.2.2">
              <p id="appendix-C-2.2.2.2.1">Code: <span><a href="https://github.com/NEAT-project/neat">https://github.com/NEAT-project/neat</a></span><a href="#appendix-C-2.2.2.2.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="appendix-C-2.2.2.3">
              <p id="appendix-C-2.2.2.3.1">Code at the Software Heritage Archive: <span><a href="https://archive.softwareheritage.org/swh:1:dir:737820840f83c4ec9493a8c0cc89b3159e2e1a57;origin=https://github.com/NEAT-project/neat;visit=swh:1:snp:bbb611b04e355439d47e426e8ad5d07cdbf647e0;anchor=swh:1:rev:652ee991043ce3560a6e5715fa2a5c211139d15c">https://archive.softwareheritage.org/swh:1:dir:737820840f83c4ec9493a8c0cc89b3159e2e1a57;origin=https://github.com/NEAT-project/neat;visit=swh:1:snp:bbb611b04e355439d47e426e8ad5d07cdbf647e0;anchor=swh:1:rev:652ee991043ce3560a6e5715fa2a5c211139d15c</a></span><a href="#appendix-C-2.2.2.3.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="appendix-C-2.2.2.4">
              <p id="appendix-C-2.2.2.4.1">NEATPy is a Python shim over NEAT that updates the NEAT API to be in line with version 6 of the Transport Services API <span>[<a href="#RFC9622" class="cite xref">RFC9622</a>]</span>.<a href="#appendix-C-2.2.2.4.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="appendix-C-2.2.2.5">
              <p id="appendix-C-2.2.2.5.1">Code: <span><a href="https://github.com/theagilepadawan/NEATPy">https://github.com/theagilepadawan/NEATPy</a></span><a href="#appendix-C-2.2.2.5.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="appendix-C-2.2.2.6">
              <p id="appendix-C-2.2.2.6.1">Code at the Software Heritage Archive: <span><a href="https://archive.softwareheritage.org/swh:1:dir:295ccd148cf918ccb9ed7ad14b5ae968a8d2c370;origin=https://github.com/theagilepadawan/NEATPy;visit=swh:1:snp:6e1a3a9dd4c532ba6c0f52c8f734c1256a06cedc;anchor=swh:1:rev:cd0788d7f7f34a0e9b8654516da7c002c44d2e95">https://archive.softwareheritage.org/swh:1:dir:295ccd148cf918ccb9ed7ad14b5ae968a8d2c370;origin=https://github.com/theagilepadawan/NEATPy;visit=swh:1:snp:6e1a3a9dd4c532ba6c0f52c8f734c1256a06cedc;anchor=swh:1:rev:cd0788d7f7f34a0e9b8654516da7c002c44d2e95</a></span><a href="#appendix-C-2.2.2.6.1" class="pilcrow">¶</a></p>
</li>
          </ul>
</li>
        <li class="normal" id="appendix-C-2.3">
          <p id="appendix-C-2.3.1">PyTAPS:<a href="#appendix-C-2.3.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-C-2.3.2.1">
              <p id="appendix-C-2.3.2.1.1">A Transport Services (TAPS) implementation based on Python asyncio, offering protocol-independent communication to applications on top of TCP, UDP, and TLS, with support for multicast.<a href="#appendix-C-2.3.2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="appendix-C-2.3.2.2">
              <p id="appendix-C-2.3.2.2.1">Code: <span><a href="https://github.com/fg-inet/python-asyncio-taps">https://github.com/fg-inet/python-asyncio-taps</a></span><a href="#appendix-C-2.3.2.2.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="appendix-C-2.3.2.3">
              <p id="appendix-C-2.3.2.3.1">Code at the Software Heritage Archive: <span><a href="https://archive.softwareheritage.org/swh:1:dir:a7151096d91352b439b092ef116d04f38e52e556;origin=https://github.com/fg-inet/python-asyncio-taps;visit=swh:1:snp:4841e59b53b28bb385726e7d3a569bee0fea7fc4;anchor=swh:1:rev:63571fd7545da25142bc1a6371b8f13097cba38e">https://archive.softwareheritage.org/swh:1:dir:a7151096d91352b439b092ef116d04f38e52e556;origin=https://github.com/fg-inet/python-asyncio-taps;visit=swh:1:snp:4841e59b53b28bb385726e7d3a569bee0fea7fc4;anchor=swh:1:rev:63571fd7545da25142bc1a6371b8f13097cba38e</a></span><a href="#appendix-C-2.3.2.3.1" class="pilcrow">¶</a></p>
</li>
          </ul>
</li>
      </ul>
</section>
</div>
<div id="acknowledgements">
<section id="appendix-D">
      <h2 id="name-acknowledgements">
<a href="#name-acknowledgements" class="section-name selfRef">Acknowledgements</a>
      </h2>
<p id="appendix-D-1">This work has received funding from the European Union's Horizon 2020 research and
innovation programme under grant agreement No. 644334 (NEAT) and No. 815178 (5GENESIS).<a href="#appendix-D-1" class="pilcrow">¶</a></p>
<p id="appendix-D-2">This work has been supported by:<a href="#appendix-D-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-D-3.1">Leibniz Prize project funds from the DFG - German
Research Foundation: Gottfried Wilhelm Leibniz-Preis 2011 (FKZ FE 570/4-1).<a href="#appendix-D-3.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="appendix-D-3.2">the UK Engineering and Physical Sciences
Research Council under grant EP/R04144X/1.<a href="#appendix-D-3.2" class="pilcrow">¶</a>
</li>
        <li class="normal" id="appendix-D-3.3">the Research Council of Norway under its "Toppforsk"
programme through the "OCARINA" project.<a href="#appendix-D-3.3" class="pilcrow">¶</a>
</li>
      </ul>
<p id="appendix-D-4">Thanks to <span class="contact-name">Colin S. Perkins</span>, <span class="contact-name">Tom Jones</span>, <span class="contact-name">Karl-Johan Grinnemo</span>, and <span class="contact-name">Gorry Fairhurst</span> for their contributions to the design of this specification.
Thanks also to <span class="contact-name">Stuart Cheshire</span>, <span class="contact-name">Josh Graessley</span>, <span class="contact-name">David Schinazi</span>, and <span class="contact-name">Eric Kinnear</span> for their implementation and design efforts, including Happy Eyeballs, that heavily influenced this work.<a href="#appendix-D-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="authors-addresses">
<section id="appendix-E">
      <h2 id="name-authors-addresses">
<a href="#name-authors-addresses" class="section-name selfRef">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Anna Brunstrom (<span class="role">editor</span>)</span></div>
<div dir="auto" class="left"><span class="org">Karlstad University</span></div>
<div dir="auto" class="left"><span class="street-address">Universitetsgatan 2</span></div>
<div dir="auto" class="left"><span class="locality">651 88 Karlstad</span></div>
<div dir="auto" class="left"><span class="country-name">Sweden</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:anna.brunstrom@kau.se" class="email">anna.brunstrom@kau.se</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Tommy Pauly (<span class="role">editor</span>)</span></div>
<div dir="auto" class="left"><span class="org">Apple Inc.</span></div>
<div dir="auto" class="left"><span class="street-address">One Apple Park Way</span></div>
<div dir="auto" class="left">
<span class="locality">Cupertino</span>, <span class="region">CA</span> <span class="postal-code">95014</span>
</div>
<div dir="auto" class="left"><span class="country-name">United States of America</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:tpauly@apple.com" class="email">tpauly@apple.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Reese Enghardt</span></div>
<div dir="auto" class="left"><span class="org">Netflix</span></div>
<div dir="auto" class="left"><span class="street-address">121 Albright Way</span></div>
<div dir="auto" class="left">
<span class="locality">Los Gatos</span>, <span class="region">CA</span> <span class="postal-code">95032</span>
</div>
<div dir="auto" class="left"><span class="country-name">United States of America</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:ietf@tenghardt.net" class="email">ietf@tenghardt.net</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Philipp S. Tiesel</span></div>
<div dir="auto" class="left"><span class="org">SAP SE</span></div>
<div dir="auto" class="left"><span class="street-address">George-Stephenson-Str. 7-13</span></div>
<div dir="auto" class="left">
<span class="postal-code">10557</span> <span class="locality">Berlin</span>
</div>
<div dir="auto" class="left"><span class="country-name">Germany</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:philipp@tiesel.net" class="email">philipp@tiesel.net</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Michael Welzl</span></div>
<div dir="auto" class="left"><span class="org">University of Oslo</span></div>
<div dir="auto" class="left"><span class="street-address">PO Box 1080 Blindern</span></div>
<div dir="auto" class="left">
<span class="postal-code">0316</span> <span class="locality">Oslo</span>
</div>
<div dir="auto" class="left"><span class="country-name">Norway</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:michawe@ifi.uio.no" class="email">michawe@ifi.uio.no</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
