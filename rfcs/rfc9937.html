<!DOCTYPE html>
<html lang="en" class="RFC">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>RFC 9937: Proportional Rate Reduction (PRR)</title>
<meta content="Matt Mathis" name="author">
<meta content="Neal Cardwell" name="author">
<meta content="Yuchung Cheng" name="author">
<meta content="Nandita Dukkipati" name="author">
<meta content="
       This document specifies a Standards Track version of the Proportional Rate Reduction (PRR) algorithm that obsoletes the Experimental version described in RFC 6937.   PRR regulates the amount of data sent by TCP or other transport protocols during fast recovery.  PRR accurately regulates the actual flight size through recovery such that at the end of recovery it will be as close as possible to the slow start threshold (ssthresh), as determined by the congestion control algorithm.
 
    " name="description">
<meta content="xml2rfc 3.31.0" name="generator">
<meta content="loss recovery" name="keyword">
<meta content="SACK" name="keyword">
<meta content="self clock" name="keyword">
<meta content="fast retransmit" name="keyword">
<meta content="fast recovery" name="keyword">
<meta content="9937" name="rfc.number">
<!-- Generator version information:
  xml2rfc 3.31.0
    Python 3.9.15
    ConfigArgParse 1.5.3
    google-i18n-address 3.0.0
    intervaltree 3.1.0
    Jinja2 3.1.2
    lxml 5.3.0
    platformdirs 3.8.0
    pycountry 22.3.5
    PyYAML 6.0
    requests 2.28.0
    wcwidth 0.2.5
    weasyprint 65.0
-->
<link href="rfc9937.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">/*

  NOTE: Changes at the bottom of this file overrides some earlier settings.

  Once the style has stabilized and has been adopted as an official RFC style,
  this can be consolidated so that style settings occur only in one place, but
  for now the contents of this file consists first of the initial CSS work as
  provided to the RFC Formatter (xml2rfc) work, followed by itemized and
  commented changes found necessary during the development of the v3
  formatters.

*/

/* fonts */
@import url('https://static.ietf.org/fonts/noto-sans/import.css'); /* Sans-serif */
@import url('https://static.ietf.org/fonts/noto-serif/import.css'); /* Serif (print) */
@import url('https://static.ietf.org/fonts/roboto-mono/import.css'); /* Monospace */

:root {
  --font-sans: 'Noto Sans', Arial, Helvetica, sans-serif;
  --font-serif: 'Noto Serif', 'Times', 'Times New Roman', serif;
  --font-mono: 'Roboto Mono', Courier, 'Courier New', monospace;
}

@viewport {
  zoom: 1.0;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}
/* general and mobile first */
html {
}
body {
  max-width: 90%;
  margin: 1.5em auto;
  color: #222;
  background-color: #fff;
  font-size: 14px;
  font-family: var(--font-sans);
  line-height: 1.6;
  scroll-behavior: smooth;
  overflow-wrap: break-word;
}
.ears {
  display: none;
}

/* headings */
#title, h1, h2, h3, h4, h5, h6 {
  margin: 1em 0 0.5em;
  font-weight: bold;
  line-height: 1.3;
}
#title {
  clear: both;
  border-bottom: 1px solid #ddd;
  margin: 0 0 0.5em 0;
  padding: 1em 0 0.5em;
}
.author {
  padding-bottom: 4px;
}
h1 {
  font-size: 26px;
  margin: 1em 0;
}
h2 {
  font-size: 22px;
  margin-top: -20px;  /* provide offset for in-page anchors */
  padding-top: 33px;
}
h3 {
  font-size: 18px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h4 {
  font-size: 16px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h5, h6 {
  font-size: 14px;
}
#n-copyright-notice {
  border-bottom: 1px solid #ddd;
  padding-bottom: 1em;
  margin-bottom: 1em;
}
/* general structure */
p {
  padding: 0;
  margin: 0 0 1em 0;
  text-align: left;
}
div, span {
  position: relative;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignRight.art-text pre {
  padding: 0;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
@media print {
  svg {
    max-height: 850px;
    max-width: 660px;
  }
}
svg[font-family~="serif" i], svg [font-family~="serif" i] {
  font-family: var(--font-serif);
}
svg[font-family~="sans-serif" i], svg [font-family~="sans-serif" i] {
  font-family: var(--font-sans);
}
svg[font-family~="monospace" i], svg [font-family~="monospace" i] {
  font-family: var(--font-mono);
}
.alignCenter.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignCenter.art-text pre {
  padding: 0;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  display: table;
  border: none;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 1em 2em;
}
ol ol, ul ul, ol ul, ul ol {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
ul.ulBare, li.ulBare {
  margin-left: 0em !important;
}
ul.compact, .ulCompact,
ol.compact, .olCompact {
  line-height: 100%;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
}
dl > dt {
  float: left;
  margin-right: 1em;
}
/* 
dl.nohang > dt {
  float: none;
}
*/
dl > dd {
  margin-bottom: .8em;
  min-height: 1.3em;
}
dl.compact > dd, .dlCompact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}

/* links */
a {
  text-decoration: none;
}
a[href] {
  color: #22e; /* Arlen: WCAG 2019 */
}
a[href]:hover {
  background-color: #f2f2f2;
}
figcaption a[href],
a[href].selfRef {
  color: #222;
}
/* XXX probably not this:
a.selfRef:hover {
  background-color: transparent;
  cursor: default;
} */

/* Figures */
tt, code, pre {
  background-color: #f9f9f9;
  font-family: var(--font-mono);
}
pre {
  border: 1px solid #eee;
  margin: 0;
  padding: 1em;
}
img {
  max-width: 100%;
}
figure {
  margin: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption {
  font-style: italic;
  margin: 0 0 1em 0;
}
@media screen {
  pre {
    overflow-x: auto;
    max-width: 100%;
    max-width: calc(100% - 22px);
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 1.2em 2em;
}
blockquote {
  background-color: #f9f9f9;
  color: #111; /* Arlen: WCAG 2019 */
  border: 1px solid #ddd;
  border-radius: 3px;
  margin: 1em 0;
}
blockquote > *:last-child {
  margin-bottom: 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}
.xref {
  overflow-wrap: normal;
}

/* tables */
table {
  width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
  border: 1px solid #eee;
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 0.5em 0.75em;
}
th {
  text-align: left;
  background-color: #e9e9e9;
}
tr:nth-child(2n+1) > td {
  background-color: #f5f5f5;
}
table caption {
  font-style: italic;
  margin: 0;
  padding: 0;
  text-align: left;
}
table p {
  /* XXX to avoid bottom margin on table row signifiers. If paragraphs should
     be allowed within tables more generally, it would be far better to select on a class. */
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  color: #666; /* Arlen: AHDJ 2019 */
  text-decoration: none;
  visibility: hidden;
  user-select: none;
  -ms-user-select: none;
  -o-user-select:none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}
@media screen {
  aside:hover > a.pilcrow,
  p:hover > a.pilcrow,
  blockquote:hover > a.pilcrow,
  div:hover > a.pilcrow,
  li:hover > a.pilcrow,
  pre:hover > a.pilcrow {
    visibility: visible;
  }
  a.pilcrow:hover {
    background-color: transparent;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid #eee;
}
.bcp14 {
  font-variant: small-caps;
}

.role {
  font-variant: all-small-caps;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: 0.9em;
}
#identifiers dt {
  width: 3em;
  clear: left;
}
#identifiers dd {
  float: left;
  margin-bottom: 0;
}
/* Fix PDF info block run off issue */
@media print {
  #identifiers dd {
    max-width: 100%;
  }
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #666; /* Arlen: WCAG 2019 */
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc  {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
nav.toc ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
nav.toc li {
  line-height: 1.3em;
  margin: 0.75em 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 7em;
}
.references dd {
  margin-left: 8em;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.refSubseries {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
.index ul {
  margin: 0 0 0 1em;
  padding: 0;
  list-style: none;
}
.index ul ul {
  margin: 0;
}
.index li {
  margin: 0;
  text-indent: -2em;
  padding-left: 2em;
  padding-bottom: 5px;
}
.indexIndex {
  margin: 0.5em 0 1em;
}
.index a {
  font-weight: 700;
}
/* make the index two-column on all but the smallest screens */
@media (min-width: 600px) {
  .index ul {
    -moz-column-count: 2;
    -moz-column-gap: 20px;
  }
  .index ul ul {
    -moz-column-count: 1;
    -moz-column-gap: 0;
  }
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}

address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  font-family: var(--font-sans);
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}

/* temporary notes */
.rfcEditorRemove::before {
  position: absolute;
  top: 0.2em;
  right: 0.2em;
  padding: 0.2em;
  content: "The RFC Editor will remove this note";
  color: #9e2a00; /* Arlen: WCAG 2019 */
  background-color: #ffd; /* Arlen: WCAG 2019 */
}
.rfcEditorRemove {
  position: relative;
  padding-top: 1.8em;
  background-color: #ffd; /* Arlen: WCAG 2019 */
  border-radius: 3px;
}
.cref {
  background-color: #ffd; /* Arlen: WCAG 2019 */
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 1023px) {
  body {
    padding-top: 2em;
  }
  #title {
    padding: 1em 0;
  }
  h1 {
    font-size: 24px;
  }
  h2 {
    font-size: 20px;
    margin-top: -18px;  /* provide offset for in-page anchors */
    padding-top: 38px;
  }
  #identifiers dd {
    max-width: 60%;
  }
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 0;
    margin: 0;
    background-color: inherit;
    border-bottom: 1px solid #ccc;
  }
  #toc h2 {
    margin: -1px 0 0 0;
    padding: 4px 0 4px 6px;
    padding-right: 1em;
    min-width: 190px;
    font-size: 1.1em;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 6px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    padding: 0.5em 1em 1em;
    overflow: auto;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 1024px) {
  body {
    max-width: 724px;
    margin: 42px auto;
    padding-left: 1.5em;
    padding-right: 29em;
  }
  #toc {
    position: fixed;
    top: 42px;
    right: 42px;
    width: 25%;
    margin: 0;
    padding: 0 1em;
    z-index: 1;
  }
  #toc h2 {
    border-top: none;
    border-bottom: 1px solid #ddd;
    font-size: 1em;
    font-weight: normal;
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 0;
    overflow: auto;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {
    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre {
    page-break-inside: avoid;
  }
  figure {
    overflow: scroll;
  }
  .breakable pre {
    break-inside: auto;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  h2+*, h3+*, h4+*, h5+*, h6+* {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

/* This is commented out here, as the string-set: doesn't
   pass W3C validation currently */
/*
.ears thead .left {
  string-set: ears-top-left content();
}

.ears thead .center {
  string-set: ears-top-center content();
}

.ears thead .right {
  string-set: ears-top-right content();
}

.ears tfoot .left {
  string-set: ears-bottom-left content();
}

.ears tfoot .center {
  string-set: ears-bottom-center content();
}

.ears tfoot .right {
  string-set: ears-bottom-right content();
}
*/

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
  /* The following is commented out here, but set appropriately by in code, as
     the content depends on the document */
  /*
  @top-left {
    content: 'Internet-Draft';
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-left {
    content: string(ears-top-left);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-center {
    content: string(ears-top-center);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-right {
    content: string(ears-top-right);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @bottom-left {
    content: string(ears-bottom-left);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-center {
    content: string(ears-bottom-center);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-right {
      content: '[Page ' counter(page) ']';
      vertical-align: top;
      border-top: solid 1px #ccc;
  }
  */

}

/* Changes introduced to fix issues found during implementation */
/* Make sure links are clickable even if overlapped by following H* */
a {
  z-index: 2;
}
/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}


/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Leave room in document info to show Internet-Draft on one line */
#identifiers dt {
  width: 8em;
}

/* Don't waste quite as much whitespace between label and value in doc info */
#identifiers dd {
  margin-left: 1em;
}

/* Give floating toc a background color (needed when it's a div inside section */
#toc {
  background-color: white;
}

/* Make the collapsed ToC header render white on gray also when it's a link */
@media screen and (max-width: 1023px) {
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
}

/* Give the bottom of the ToC some whitespace */
@media screen and (min-width: 1024px) {
  #toc {
    padding: 0 0 1em 1em;
  }
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* prevent monospace from becoming overly large */
tt, code, pre {
  font-size: 95%;
}

/* Fix the height/width aspect for ascii art*/
.sourcecode pre,
.art-text pre {
  line-height: 1.12;
}


/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin-right: 0.5em;
}

/* Fix the dl styling to match the RFC 7992 attributes */
dl > dt,
dl.dlParallel > dt {
  float: left;
  margin-right: 1em;
}
dl.dlNewline > dt {
  float: none;
}

/* Provide styling for table cell text alignment */
table td.text-left,
table th.text-left {
  text-align: left;
}
table td.text-center,
table th.text-center {
  text-align: center;
}
table td.text-right,
table th.text-right {
  text-align: right;
}

/* Make the alternative author contact information look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 30em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Provide table alignment support.  We can't use the alignX classes above
   since they do unwanted things with caption and other styling. */
table.right {
 margin-left: auto;
 margin-right: 0;
}
table.center {
 margin-left: auto;
 margin-right: auto;
}
table.left {
 margin-left: 0;
 margin-right: auto;
}

/* Give the table caption label the same styling as the figcaption */
caption a[href] {
  color: #222;
}

@media print {
  .toplink {
    display: none;
  }

  /* avoid overwriting the top border line with the ToC header */
  #toc {
    padding-top: 1px;
  }

  /* Avoid page breaks inside dl and author address entries */
  .vcard {
    page-break-inside: avoid;
  }

}
/* Tweak the bcp14 keyword presentation */
.bcp14 {
  font-variant: small-caps;
  font-weight: bold;
  font-size: 0.9em;
}
/* Tweak the invisible space above H* in order not to overlay links in text above */
 h2 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 31px;
 }
 h3 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
 h4 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
/* Float artwork pilcrow to the right */
@media screen {
  .artwork a.pilcrow {
    display: block;
    line-height: 0.7;
    margin-top: 0.15em;
  }
}
/* Make pilcrows on dd visible */
@media screen {
  dd:hover > a.pilcrow {
    visibility: visible;
  }
}
/* Make the placement of figcaption match that of a table's caption
   by removing the figure's added bottom margin */
.alignLeft.art-text,
.alignCenter.art-text,
.alignRight.art-text {
   margin-bottom: 0;
}
.alignLeft,
.alignCenter,
.alignRight {
  margin: 1em 0 0 0;
}
/* In print, the pilcrow won't show on hover, so prevent it from taking up space,
   possibly even requiring a new line */
@media print {
  a.pilcrow {
    display: none;
  }
}
/* Styling for the external metadata */
div#external-metadata {
  background-color: #eee;
  padding: 0.5em;
  margin-bottom: 0.5em;
  display: none;
}
div#internal-metadata {
  padding: 0.5em;                       /* to match the external-metadata padding */
}
/* Styling for title RFC Number */
h1#rfcnum {
  clear: both;
  margin: 0 0 -1em;
  padding: 1em 0 0 0;
}
/* Make .olPercent look the same as <ol><li> */
dl.olPercent > dd {
  margin-bottom: 0.25em;
  min-height: initial;
}
/* Give aside some styling to set it apart */
aside {
  border-left: 1px solid #ddd;
  margin: 1em 0 1em 2em;
  padding: 0.2em 2em;
}
aside > dl,
aside > ol,
aside > ul,
aside > table,
aside > p {
  margin-bottom: 0.5em;
}
/* Additional page break settings */
@media print {
  figcaption, table caption {
    page-break-before: avoid;
  }
}
/* Font size adjustments for print */
@media print {
  body  { font-size: 10pt;      line-height: normal; max-width: 96%; }
  h1    { font-size: 1.72em;    padding-top: 1.5em; } /* 1*1.2*1.2*1.2 */
  h2    { font-size: 1.44em;    padding-top: 1.5em; } /* 1*1.2*1.2 */
  h3    { font-size: 1.2em;     padding-top: 1.5em; } /* 1*1.2 */
  h4    { font-size: 1em;       padding-top: 1.5em; }
  h5, h6 { font-size: 1em;      margin: initial; padding: 0.5em 0 0.3em; }
}
/* Sourcecode margin in print, when there's no pilcrow */
@media print {
  .artwork,
  .artwork > pre,
  .sourcecode {
    margin-bottom: 1em;
  }
}
/* Avoid narrow tables forcing too narrow table captions, which may render badly */
table {
  min-width: 20em;
}
/* ol type a */
ol.type-a { list-style-type: lower-alpha; }
ol.type-A { list-style-type: upper-alpha; }
ol.type-i { list-style-type: lower-roman; }
ol.type-I { list-style-type: upper-roman; }
/* Apply the print table and row borders in general, on request from the RPC,
and increase the contrast between border and odd row background slightly */
table {
  border: 1px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
}
tr {
  break-inside: avoid;
}
tr:nth-child(2n+1) > td {
  background-color: #f8f8f8;
}
/* Use style rules to govern display of the TOC. */
@media screen and (max-width: 1023px) {
  #toc nav { display: none; }
  #toc.active nav { display: block; }
}
/* Add support for keepWithNext */
.keepWithNext {
  break-after: avoid-page;
  break-after: avoid-page;
}
/* Add support for keepWithPrevious */
.keepWithPrevious {
  break-before: avoid-page;
}
/* Change the approach to avoiding breaks inside artwork etc. */
figure, pre, table, .artwork, .sourcecode  {
  break-before: auto;
  break-after: auto;
}
/* Avoid breaks between <dt> and <dd> */
dl {
  break-before: auto;
  break-inside: auto;
}
dt {
  break-before: auto;
  break-after: avoid-page;
}
dd {
  break-before: avoid-page;
  break-after: auto;
  orphans: 3;
  widows: 3
}
span.break, dd.break {
  margin-bottom: 0;
  min-height: 0;
  break-before: auto;
  break-inside: auto;
  break-after: auto;
}
/* Undo break-before ToC */
@media print {
  #toc {
    break-before: auto;
  }
}
/* Text in compact lists should not get extra bottom margin space,
   since that would makes the list not compact */
ul.compact p, .ulCompact p,
ol.compact p, .olCompact p {
 margin: 0;
}
/* But the list as a whole needs the extra space at the end */
section ul.compact,
section .ulCompact,
section ol.compact,
section .olCompact {
  margin-bottom: 1em;                    /* same as p not within ul.compact etc. */
}
/* The tt and code background above interferes with for instance table cell
   backgrounds.  Changed to something a bit more selective. */
tt, code {
  background-color: transparent;
}
p tt, p code, li tt, li code, dt tt, dt code {
  background-color: #f8f8f8;
}
/* Tweak the pre margin -- 0px doesn't come out well */
pre {
   margin-top: 0.5px;
}
/* Tweak the compact list text */
ul.compact, .ulCompact,
ol.compact, .olCompact,
dl.compact, .dlCompact {
  line-height: normal;
}
/* Don't add top margin for nested lists */
li > ul, li > ol, li > dl,
dd > ul, dd > ol, dd > dl,
dl > dd > dl {
  margin-top: initial;
}
/* Elements that should not be rendered on the same line as a <dt> */
/* This should match the element list in writer.text.TextWriter.render_dl() */
dd > div.artwork:first-child,
dd > aside:first-child,
dd > blockquote:first-child,
dd > figure:first-child,
dd > ol:first-child,
dd > div.sourcecode:first-child,
dd > table:first-child,
dd > ul:first-child {
  clear: left;
}
/* fix for weird browser behaviour when <dd/> is empty */
dt+dd:empty::before{
  content: "\00a0";
}
/* Make paragraph spacing inside <li> smaller than in body text, to fit better within the list */
li > p {
  margin-bottom: 0.5em
}
/* Don't let p margin spill out from inside list items */
li > p:last-of-type:only-child {
  margin-bottom: 0;
}
</style>
<link href="rfc-local.css" rel="stylesheet" type="text/css">
<link href="https://datatracker.ietf.org/doc/draft-ietf-tcpm-prr-rfc6937bis-21" rel="prev">
  <link href="https://dx.doi.org/10.17487/rfc9937" rel="alternate">
  <link href="urn:issn:2070-1721" rel="alternate">
  </head>
<body class="xml2rfc">
<script src="https://www.rfc-editor.org/js/metadata.min.js"></script>
<table class="ears">
<thead><tr>
<td class="left">RFC 9937</td>
<td class="center">PRR</td>
<td class="right">December 2025</td>
</tr></thead>
<tfoot><tr>
<td class="left">Mathis, et al.</td>
<td class="center">Standards Track</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-stream">Stream:</dt>
<dd class="stream">Internet Engineering Task Force (IETF)</dd>
<dt class="label-rfc">RFC:</dt>
<dd class="rfc"><a href="https://www.rfc-editor.org/rfc/rfc9937" class="eref">9937</a></dd>
<dt class="label-obsoletes">Obsoletes:</dt>
<dd class="obsoletes">
<a href="https://www.rfc-editor.org/rfc/rfc6937" class="eref">6937</a> </dd>
<dt class="label-category">Category:</dt>
<dd class="category">Standards Track</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2025-12" class="published">December 2025</time>
    </dd>
<dt class="label-issn">ISSN:</dt>
<dd class="issn">2070-1721</dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">M. Mathis</div>
</div>
<div class="author">
      <div class="author-name">N. Cardwell</div>
<div class="org">Google, Inc.</div>
</div>
<div class="author">
      <div class="author-name">Y. Cheng</div>
<div class="org">Google, Inc.</div>
</div>
<div class="author">
      <div class="author-name">N. Dukkipati</div>
<div class="org">Google, Inc.</div>
</div>
</dd>
</dl>
</div>
<h1 id="rfcnum">RFC 9937</h1>
<h1 id="title">Proportional Rate Reduction (PRR)</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">This document specifies a Standards Track version of the Proportional Rate Reduction (PRR) algorithm that obsoletes the Experimental version described in RFC 6937.   PRR regulates the amount of data sent by TCP or other transport protocols during fast recovery.  PRR accurately regulates the actual flight size through recovery such that at the end of recovery it will be as close as possible to the slow start threshold (ssthresh), as determined by the congestion control algorithm.<a href="#section-abstract-1" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
            This is an Internet Standards Track document.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by
            the Internet Engineering Steering Group (IESG).  Further
            information on Internet Standards is available in Section 2 of 
            RFC 7841.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <span><a href="https://www.rfc-editor.org/info/rfc9937">https://www.rfc-editor.org/info/rfc9937</a></span>.<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2025 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents">
<a href="#name-table-of-contents" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1" class="keepWithNext"><a href="#section-1" class="auto internal xref">1</a>.  <a href="#name-introduction" class="internal xref">Introduction</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1" class="keepWithNext"><a href="#section-2" class="auto internal xref">2</a>.  <a href="#name-conventions" class="internal xref">Conventions</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1" class="keepWithNext"><a href="#section-3" class="auto internal xref">3</a>.  <a href="#name-definitions" class="internal xref">Definitions</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="auto internal xref">4</a>.  <a href="#name-changes-relative-to-rfc-693" class="internal xref">Changes Relative to RFC 6937</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="auto internal xref">5</a>.  <a href="#name-relationships-to-other-stan" class="internal xref">Relationships to Other Standards</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="auto internal xref">6</a>.  <a href="#name-algorithm" class="internal xref">Algorithm</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1">
                <p id="section-toc.1-1.6.2.1.1"><a href="#section-6.1" class="auto internal xref">6.1</a>.  <a href="#name-initialization-steps" class="internal xref">Initialization Steps</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.2">
                <p id="section-toc.1-1.6.2.2.1"><a href="#section-6.2" class="auto internal xref">6.2</a>.  <a href="#name-per-ack-steps" class="internal xref">Per-ACK Steps</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.3">
                <p id="section-toc.1-1.6.2.3.1"><a href="#section-6.3" class="auto internal xref">6.3</a>.  <a href="#name-per-transmit-steps" class="internal xref">Per-Transmit Steps</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.4">
                <p id="section-toc.1-1.6.2.4.1"><a href="#section-6.4" class="auto internal xref">6.4</a>.  <a href="#name-completion-steps" class="internal xref">Completion Steps</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="auto internal xref">7</a>.  <a href="#name-properties" class="internal xref">Properties</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#section-8" class="auto internal xref">8</a>.  <a href="#name-examples" class="internal xref">Examples</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#section-9" class="auto internal xref">9</a>.  <a href="#name-adapting-prr-to-other-trans" class="internal xref">Adapting PRR to Other Transport Protocols</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a href="#section-10" class="auto internal xref">10</a>. <a href="#name-measurement-studies" class="internal xref">Measurement Studies</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a href="#section-11" class="auto internal xref">11</a>. <a href="#name-operational-considerations" class="internal xref">Operational Considerations</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.1">
                <p id="section-toc.1-1.11.2.1.1"><a href="#section-11.1" class="auto internal xref">11.1</a>.  <a href="#name-incremental-deployment" class="internal xref">Incremental Deployment</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.2">
                <p id="section-toc.1-1.11.2.2.1"><a href="#section-11.2" class="auto internal xref">11.2</a>.  <a href="#name-fairness" class="internal xref">Fairness</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.3">
                <p id="section-toc.1-1.11.2.3.1"><a href="#section-11.3" class="auto internal xref">11.3</a>.  <a href="#name-protecting-the-network-agai" class="internal xref">Protecting the Network Against Excessive Queuing and Packet Loss</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a href="#section-12" class="auto internal xref">12</a>. <a href="#name-iana-considerations" class="internal xref">IANA Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13">
            <p id="section-toc.1-1.13.1"><a href="#section-13" class="auto internal xref">13</a>. <a href="#name-security-considerations" class="internal xref">Security Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14">
            <p id="section-toc.1-1.14.1"><a href="#section-14" class="auto internal xref">14</a>. <a href="#name-references" class="internal xref">References</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14.2.1">
                <p id="section-toc.1-1.14.2.1.1"><a href="#section-14.1" class="auto internal xref">14.1</a>.  <a href="#name-normative-references" class="internal xref">Normative References</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14.2.2">
                <p id="section-toc.1-1.14.2.2.1"><a href="#section-14.2" class="auto internal xref">14.2</a>.  <a href="#name-informative-references" class="internal xref">Informative References</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.15">
            <p id="section-toc.1-1.15.1"><a href="#appendix-A" class="auto internal xref">Appendix A</a>.  <a href="#name-strong-packet-conservation-" class="internal xref">Strong Packet Conservation Bound</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.16">
            <p id="section-toc.1-1.16.1"><a href="#appendix-B" class="auto internal xref"></a><a href="#name-acknowledgments" class="internal xref">Acknowledgments</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.17">
            <p id="section-toc.1-1.17.1"><a href="#appendix-C" class="auto internal xref"></a><a href="#name-authors-addresses" class="internal xref">Authors' Addresses</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<section id="section-1">
      <h2 id="name-introduction">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">Van Jacobson's packet conservation principle <span>[<a href="#Jacobson88" class="cite xref">Jacobson88</a>]</span> defines a self clock process wherein N data segments delivered to the receiver generate acknowledgments that the data sender uses as the clock to trigger sending another N data segments into the network.<a href="#section-1-1" class="pilcrow">¶</a></p>
<p id="section-1-2">Congestion control algorithms like Reno <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span> and CUBIC <span>[<a href="#RFC9438" class="cite xref">RFC9438</a>]</span> are built on the conceptual foundation of this self clock process. They control the sending process of a transport protocol connection by using a congestion window ("cwnd") to limit "inflight", the volume of data that a connection estimates is in flight in the network at a given time. Furthermore, these algorithms require that transport protocol connections  reduce their cwnd in response to packet losses. Fast recovery (see <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span> and <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>) is the algorithm for making this cwnd reduction using feedback from acknowledgments.  Its stated goal is to maintain a sender's self clock by relying on returning ACKs during recovery to clock more data into the network. Without Proportional Rate Reduction (PRR), fast recovery typically adjusts the window by waiting for a large fraction of a round-trip time (RTT) (one half round-trip time of ACKs for Reno <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span> or 30% of a round-trip time for CUBIC <span>[<a href="#RFC9438" class="cite xref">RFC9438</a>]</span>) to pass before sending any data.<a href="#section-1-2" class="pilcrow">¶</a></p>
<p id="section-1-3"><span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span> makes fast recovery with Selective Acknowledgment (SACK) <span>[<a href="#RFC2018" class="cite xref">RFC2018</a>]</span> more accurate by computing "pipe", a sender-side estimate of the number of bytes still outstanding in the network.   With <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>, fast recovery is implemented by sending data as necessary on each ACK to allow pipe to rise to match ssthresh, the target window size for fast recovery, as determined by the congestion control algorithm.  This protects fast recovery from timeouts in many cases where there are heavy losses. However, <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span> has two significant drawbacks. First, because it makes a large multiplicative decrease in cwnd at the start of fast recovery, it can cause a timeout if the entire second half of the window of data or ACKs are lost.  Second, a single ACK carrying a SACK option that implies a large quantity of missing data can cause a step discontinuity in the pipe estimator, which can cause Fast Retransmit to send a large burst of data.<a href="#section-1-3" class="pilcrow">¶</a></p>
<p id="section-1-4">PRR  regulates the transmission process during fast recovery in a manner that avoids these excess window adjustments, such that transmissions progress smoothly, and at the end of recovery, the actual window size will be as close as possible to ssthresh.<a href="#section-1-4" class="pilcrow">¶</a></p>
<p id="section-1-5">PRR's approach is inspired by Van Jacobson's packet conservation principle.  As much as possible, PRR relies  on the self clock process and is only slightly affected by the accuracy of estimators, such as the estimate of the volume of in-flight data.   This is what gives the algorithm its precision in the presence of events that cause uncertainty in other estimators.<a href="#section-1-5" class="pilcrow">¶</a></p>
<p id="section-1-6"> When inflight is above ssthresh, PRR reduces inflight smoothly toward ssthresh by clocking out transmissions at a rate that is in proportion to both the delivered data and ssthresh.<a href="#section-1-6" class="pilcrow">¶</a></p>
<p id="section-1-7">When inflight is less than ssthresh, PRR adaptively chooses between one of two  Reduction Bounds to limit the total window reduction due to all mechanisms, including transient application stalls and the losses themselves. As a baseline, to be cautious when there may be considerable congestion, PRR uses its Conservative Reduction Bound (CRB), which is strictly packet conserving. When recovery seems to be progressing well, PRR uses its Slow Start Reduction Bound (SSRB), which is more aggressive than PRR-CRB by at most one segment per ACK.  PRR-CRB meets the Strong Packet Conservation Bound described in <a href="#conservative" class="auto internal xref">Appendix A</a>; however, when used in real networks as the sole approach, it does not perform as well as the algorithm described in <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>, which proves to be more aggressive in a significant number of cases.  PRR-SSRB offers a compromise by allowing a connection to send one additional segment per ACK, relative to PRR-CRB, in some situations. Although PRR-SSRB is less aggressive than <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span> (transmitting fewer segments or taking more time to transmit them), it outperforms due to the lower probability of additional losses during recovery.<a href="#section-1-7" class="pilcrow">¶</a></p>
<p id="section-1-8">The original definition of the packet conservation principle <span>[<a href="#Jacobson88" class="cite xref">Jacobson88</a>]</span>  treated packets that are presumed to be lost (e.g., marked as candidates for retransmission) as having left the network. This idea is reflected in the inflight estimator used by PRR, but it is distinct from the Strong Packet Conservation Bound as described in <a href="#conservative" class="auto internal xref">Appendix A</a>, which is defined solely on the basis of data arriving at the receiver.<a href="#section-1-8" class="pilcrow">¶</a></p>
<p id="section-1-9">This document specifies several main changes from the earlier version of PRR in <span>[<a href="#RFC6937" class="cite xref">RFC6937</a>]</span>. First, it introduces a new adaptive heuristic that replaces a manual configuration parameter that determined how conservative PRR was when inflight was less than ssthresh (whether to use PRR-CRB or PRR-SSRB). Second, the algorithm specifies behavior for non-SACK connections (connections that have not negotiated SACK <span>[<a href="#RFC2018" class="cite xref">RFC2018</a>]</span> support via the "SACK-permitted" option). Third, the algorithm ensures a smooth sending process even when the sender has experienced high reordering and starts loss recovery after a large amount of sequence space has been SACKed.  Finally, this document also includes additional discussion about the integration of PRR with congestion control and loss detection algorithms.<a href="#section-1-9" class="pilcrow">¶</a></p>
<p id="section-1-10">PRR has extensive deployment experience in multiple TCP implementations since the first widely deployed TCP PRR implementation in 2011 <span>[<a href="#First_TCP_PRR" class="cite xref">First_TCP_PRR</a>]</span>.<a href="#section-1-10" class="pilcrow">¶</a></p>
</section>
<section id="section-2">
      <h2 id="name-conventions">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-conventions" class="section-name selfRef">Conventions</a>
      </h2>
<p id="section-2-1">
    The key words "<span class="bcp14">MUST</span>", "<span class="bcp14">MUST NOT</span>", "<span class="bcp14">REQUIRED</span>", "<span class="bcp14">SHALL</span>", "<span class="bcp14">SHALL NOT</span>", "<span class="bcp14">SHOULD</span>", "<span class="bcp14">SHOULD NOT</span>", "<span class="bcp14">RECOMMENDED</span>", "<span class="bcp14">NOT RECOMMENDED</span>",
    "<span class="bcp14">MAY</span>", and "<span class="bcp14">OPTIONAL</span>" in this document are to be interpreted as
    described in BCP 14 <span>[<a href="#RFC2119" class="cite xref">RFC2119</a>]</span> <span>[<a href="#RFC8174" class="cite xref">RFC8174</a>]</span> 
    when, and only when, they appear in all capitals, as shown here.<a href="#section-2-1" class="pilcrow">¶</a></p>
</section>
<section id="section-3">
      <h2 id="name-definitions">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-definitions" class="section-name selfRef">Definitions</a>
      </h2>
<p id="section-3-1">The following terms, parameters, and state variables are used as they are defined in earlier documents:<a href="#section-3-1" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-3-2">
        <dt id="section-3-2.1">SND.UNA:</dt>
        <dd style="margin-left: 1.5em" id="section-3-2.2">The oldest unacknowledged sequence number. This is
  defined in <span><a href="https://rfc-editor.org/rfc/rfc9293#section-3.4" class="relref">Section 3.4</a> of [<a href="#RFC9293" class="cite xref">RFC9293</a>]</span>.<a href="#section-3-2.2" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-3-2.3">SND.NXT:</dt>
        <dd style="margin-left: 1.5em" id="section-3-2.4">The next sequence number to be sent.  This is defined
  in <span><a href="https://rfc-editor.org/rfc/rfc9293#section-3.4" class="relref">Section 3.4</a> of [<a href="#RFC9293" class="cite xref">RFC9293</a>]</span>.<a href="#section-3-2.4" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-3-2.5">duplicate ACK: </dt>
        <dd style="margin-left: 1.5em" id="section-3-2.6">An acknowledgment is considered a "duplicate
  ACK" or "duplicate acknowledgment" when (a) the receiver of the ACK has
  outstanding data, (b) the incoming acknowledgment carries no data, (c) the
  SYN and FIN bits are both off, (d) the acknowledgment number is equal to
  SND.UNA, and (e) the advertised window in the incoming acknowledgment equals
  the advertised window in the last incoming acknowledgment. This is defined
  in <span><a href="https://rfc-editor.org/rfc/rfc5681#section-2" class="relref">Section 2</a> of [<a href="#RFC5681" class="cite xref">RFC5681</a>]</span>.<a href="#section-3-2.6" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-3-2.7">FlightSize:</dt>
        <dd style="margin-left: 1.5em" id="section-3-2.8">The amount of data that has been sent but not yet
  cumulatively acknowledged. This is defined in <span><a href="https://rfc-editor.org/rfc/rfc5681#section-2" class="relref">Section 2</a> of [<a href="#RFC5681" class="cite xref">RFC5681</a>]</span>.<a href="#section-3-2.8" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-3-2.9">Receiver Maximum Segment Size (RMSS):</dt>
        <dd style="margin-left: 1.5em" id="section-3-2.10">The RMSS is the size of
  the largest segment the receiver is willing to accept. This is the value
  specified in the MSS option sent by the receiver during connection startup
  (see <span><a href="https://rfc-editor.org/rfc/rfc9293#section-3.7.1" class="relref">Section 3.7.1</a> of [<a href="#RFC9293" class="cite xref">RFC9293</a>]</span>). Or if the MSS option is not
  used, it is the default of 536 bytes for IPv4 or 1220 bytes for IPv6 (see
  <span><a href="https://rfc-editor.org/rfc/rfc9293#section-3.7.1" class="relref">Section 3.7.1</a> of [<a href="#RFC9293" class="cite xref">RFC9293</a>]</span>). The size does not include the
  TCP/IP headers and options. The RMSS is defined in <span><a href="https://rfc-editor.org/rfc/rfc5681#section-2" class="relref">Section 2</a> of [<a href="#RFC5681" class="cite xref">RFC5681</a>]</span> and <span><a href="https://rfc-editor.org/rfc/rfc9293#section-3.8.6.3" class="relref">Section 3.8.6.3</a> of [<a href="#RFC9293" class="cite xref">RFC9293</a>]</span>.<a href="#section-3-2.10" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-3-2.11">Sender Maximum Segment Size (SMSS):</dt>
        <dd style="margin-left: 1.5em" id="section-3-2.12">The SMSS is the size of the
  largest segment that the sender can transmit.  This value can be based on
  the Maximum Transmission Unit (MTU) of the network, the path MTU discovery <span>[<a href="#RFC1191" class="cite xref">RFC1191</a>]</span> <span>[<a href="#RFC8201" class="cite xref">RFC8201</a>]</span> <span>[<a href="#RFC4821" class="cite xref">RFC4821</a>]</span>
  algorithm, RMSS, or other factors.  The size does not include the TCP/IP
  headers and options. This is defined in <span><a href="https://rfc-editor.org/rfc/rfc5681#section-2" class="relref">Section 2</a> of [<a href="#RFC5681" class="cite xref">RFC5681</a>]</span>.<a href="#section-3-2.12" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-3-2.13">Receiver Window (rwnd):</dt>
        <dd style="margin-left: 1.5em" id="section-3-2.14">The most recently received advertised
  receiver window, in bytes.  At any given time, a connection <span class="bcp14">MUST NOT</span> send data with a sequence number higher than the sum of SND.UNA
  and rwnd. This is defined in <span><a href="https://rfc-editor.org/rfc/rfc5681#section-2" class="relref">Section 2</a> of [<a href="#RFC5681" class="cite xref">RFC5681</a>]</span>.<a href="#section-3-2.14" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-3-2.15">Congestion Window (cwnd):</dt>
        <dd style="margin-left: 1.5em" id="section-3-2.16">A state variable that limits the
  amount of data a connection can send.  At any given time, a connection
  <span class="bcp14">MUST NOT</span> send data if inflight (see below) matches or exceeds
  cwnd. This is defined in <span><a href="https://rfc-editor.org/rfc/rfc5681#section-2" class="relref">Section 2</a> of [<a href="#RFC5681" class="cite xref">RFC5681</a>]</span>.<a href="#section-3-2.16" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-3-2.17">Slow Start Threshold (ssthresh):</dt>
        <dd style="margin-left: 1.5em" id="section-3-2.18">The slow start threshold
  (ssthresh) state variable is used to determine whether the slow start or
  congestion avoidance algorithm is used to control data transmission. During
  fast recovery, ssthresh is the target window size for a fast recovery
  episode, as determined by the congestion control algorithm. This is defined
  in <span><a href="https://rfc-editor.org/rfc/rfc5681#section-3.1" class="relref">Section 3.1</a> of [<a href="#RFC5681" class="cite xref">RFC5681</a>]</span>.<a href="#section-3-2.18" class="pilcrow">¶</a>
</dd>
      <dd class="break"></dd>
</dl>
<p id="section-3-3">PRR defines additional variables and terms:<a href="#section-3-3" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-3-4">
        <dt id="section-3-4.1">Delivered Data (DeliveredData):</dt>
        <dd style="margin-left: 1.5em" id="section-3-4.2">The data sender's best estimate of the total number of bytes that the current ACK indicates have been delivered to the receiver since the previously received ACK.<a href="#section-3-4.2" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-3-4.3">In-Flight Data (inflight):</dt>
        <dd style="margin-left: 1.5em" id="section-3-4.4">The data sender's best estimate of the number of unacknowledged bytes in flight in the network, i.e., bytes that were sent and neither lost nor received by the data receiver.<a href="#section-3-4.4" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-3-4.5">Recovery Flight Size (RecoverFS):</dt>
        <dd style="margin-left: 1.5em" id="section-3-4.6">The number of bytes the sender estimates might possibly be delivered over the course of the current PRR episode.<a href="#section-3-4.6" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-3-4.7">SafeACK:</dt>
        <dd style="margin-left: 1.5em" id="section-3-4.8">A local boolean variable indicating that the current ACK indicates the recovery is making good progress and the sender can send more aggressively, increasing inflight, if appropriate.<a href="#section-3-4.8" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-3-4.9">SndCnt:</dt>
        <dd style="margin-left: 1.5em" id="section-3-4.10">A local variable indicating exactly how many bytes should be sent  in response to each ACK.<a href="#section-3-4.10" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-3-4.11">Voluntary window reductions:</dt>
        <dd style="margin-left: 1.5em" id="section-3-4.12">Choosing not to send data in response to some ACKs, for the purpose of reducing the sending window size and data rate.<a href="#section-3-4.12" class="pilcrow">¶</a>
</dd>
      <dd class="break"></dd>
</dl>
</section>
<section id="section-4">
      <h2 id="name-changes-relative-to-rfc-693">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-changes-relative-to-rfc-693" class="section-name selfRef">Changes Relative to RFC 6937</a>
      </h2>
<p id="section-4-1">The largest change since <span>[<a href="#RFC6937" class="cite xref">RFC6937</a>]</span> is the introduction of a new heuristic that uses good recovery progress (for TCP, when the latest ACK advances SND.UNA and does not indicate that a prior fast retransmit has been lost) to select the Reduction Bound (PRR-CRB or PRR-SSRB).  <span>[<a href="#RFC6937" class="cite xref">RFC6937</a>]</span> left the choice of Reduction Bound to the discretion of the implementer but recommended to use PRR-SSRB by default.  For all of the environments explored in earlier PRR research, the new heuristic is consistent with the old recommendation.<a href="#section-4-1" class="pilcrow">¶</a></p>
<p id="section-4-2">
The paper "An Internet-Wide Analysis of Traffic Policing" <span>[<a href="#Flach2016policing" class="cite xref">Flach2016policing</a>]</span>
uncovered a crucial situation not previously explored, where both Reduction Bounds perform very poorly but for different reasons.  Under many configurations, token bucket traffic policers can suddenly start discarding a large fraction of the traffic when tokens are depleted, without any warning to the end systems.  The transport congestion control has no opportunity to measure the token rate and sets ssthresh based on the previously observed path performance.  This value for ssthresh may cause a data rate that is substantially larger than the token replenishment rate, causing high loss. Under these conditions, both Reduction Bounds perform very poorly.   PRR-CRB is too timid, sometimes causing very long recovery times at smaller than necessary windows, and PRR-SSRB is too aggressive, often causing many retransmissions to be lost for multiple rounds. Both cases lead to prolonged recovery, decimating application latency and/or goodput.<a href="#section-4-2" class="pilcrow">¶</a></p>
<p id="section-4-3">Investigating these environments led to the development of a "SafeACK" heuristic to dynamically switch between Reduction Bounds: by default, conservatively use PRR-CRB and only switch to PRR-SSRB when ACKs indicate the recovery is making good progress (SND.UNA is advancing without detecting any new losses). The SafeACK heuristic was experimented with in Google's Content Delivery Network (CDN) <span>[<a href="#Flach2016policing" class="cite xref">Flach2016policing</a>]</span> and implemented in Linux TCP since 2015.<a href="#section-4-3" class="pilcrow">¶</a></p>
<p id="section-4-4">This SafeACK heuristic is only invoked where losses, application-limited behavior, or other events cause the current estimate of in-flight data to fall below ssthresh.  The high loss rates that make the heuristic essential are only common in the presence of heavy losses, such as traffic policers <span>[<a href="#Flach2016policing" class="cite xref">Flach2016policing</a>]</span>.  In these environments, the heuristic performs better than either bound by itself.<a href="#section-4-4" class="pilcrow">¶</a></p>
<p id="section-4-5">Another PRR algorithm change improves the sending process when the sender enters recovery after a large portion of sequence space has been SACKed. This scenario could happen when the sender has previously detected reordering, for example, by using <span>[<a href="#RFC8985" class="cite xref">RFC8985</a>]</span>. In the previous version of PRR, RecoverFS did not properly account for sequence ranges SACKed before entering fast recovery, which caused PRR to initially send too slowly. With the change, PRR properly accounts for sequence ranges SACKed before entering fast recovery.<a href="#section-4-5" class="pilcrow">¶</a></p>
<p id="section-4-6">Yet another change is to force a fast retransmit  upon the first ACK that triggers the recovery. Previously, PRR may not allow a fast retransmit (i.e., SndCnt is 0) on the first ACK in fast recovery, depending on the loss situation. Forcing a fast retransmit is important to maintain the ACK clock and avoid potential retransmission timeout (RTO) events. The forced fast retransmit only happens once during the entire recovery and still follows the packet conservation principles in PRR. This heuristic has been implemented since the first widely deployed TCP PRR implementation in 2011 <span>[<a href="#First_TCP_PRR" class="cite xref">First_TCP_PRR</a>]</span>.<a href="#section-4-6" class="pilcrow">¶</a></p>
<p id="section-4-7"> In another change, upon exiting recovery, a data sender sets cwnd to ssthresh. This is important for robust performance. Without setting cwnd to ssthresh at the end of recovery and with application-limited sender behavior and some loss patterns, cwnd could end fast recovery well below ssthresh, leading to bad performance. The performance could, in some cases, be worse than <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span> recovery, which simply sets cwnd to ssthresh at the start of recovery. This behavior of setting cwnd to ssthresh at the end of recovery has been implemented since the first widely deployed TCP PRR implementation in 2011 <span>[<a href="#First_TCP_PRR" class="cite xref">First_TCP_PRR</a>]</span> and is similar to <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>, which specifies setting cwnd to ssthresh at the start of recovery.<a href="#section-4-7" class="pilcrow">¶</a></p>
<p id="section-4-8">
Since <span>[<a href="#RFC6937" class="cite xref">RFC6937</a>]</span> was written, PRR has also been adapted to perform multiplicative window reduction for non-loss-based congestion control algorithms, such as for Explicit Congestion Notification (ECN) as specified in <span>[<a href="#RFC3168" class="cite xref">RFC3168</a>]</span>.   This can be done by using some parts of the loss recovery state machine (in particular, the RecoveryPoint from <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>) to invoke the PRR ACK processing for exactly one round trip worth of ACKs. However, there can be interactions between using PRR and approaches to Active Queue Management (AQM) and ECN; guidance on the development and assessment of congestion control mechanisms is provided in <span>[<a href="#RFC9743" class="cite xref">RFC9743</a>]</span>.<a href="#section-4-8" class="pilcrow">¶</a></p>
</section>
<section id="section-5">
      <h2 id="name-relationships-to-other-stan">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-relationships-to-other-stan" class="section-name selfRef">Relationships to Other Standards</a>
      </h2>
<p id="section-5-1">PRR <span class="bcp14">MAY</span> be used in conjunction with any congestion control algorithm that intends to make a multiplicative decrease in its sending rate over approximately the time scale of one round-trip time, as long as the current volume of in-flight data is limited by a congestion window (cwnd) and the target volume of in-flight data during that reduction is a fixed value given by ssthresh. In particular, PRR is applicable to both Reno <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span> and CUBIC <span>[<a href="#RFC9438" class="cite xref">RFC9438</a>]</span> congestion control. PRR is described as a modification to "A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP" <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>.   It is most accurate with SACK <span>[<a href="#RFC2018" class="cite xref">RFC2018</a>]</span> but does not require SACK.<a href="#section-5-1" class="pilcrow">¶</a></p>
<p id="section-5-2">PRR can be used in conjunction with a wide array of loss detection algorithms. This is because PRR does not have any dependencies on the details of how a loss detection algorithm estimates which packets have been delivered and which packets have been lost. Upon the reception of each ACK, PRR simply needs the loss detection algorithm to communicate how many packets have been marked as lost and how many packets have been marked as delivered.  Thus, PRR <span class="bcp14">MAY</span> be used in conjunction with the  loss detection algorithms specified or described in the following documents: Reno <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span>, NewReno <span>[<a href="#RFC6582" class="cite xref">RFC6582</a>]</span>, SACK <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>, Forward Acknowledgment (FACK) <span>[<a href="#FACK" class="cite xref">FACK</a>]</span>, and Recent Acknowledgment Tail Loss Probe (RACK-TLP) <span>[<a href="#RFC8985" class="cite xref">RFC8985</a>]</span>. Because of the performance properties of RACK-TLP, including resilience to tail loss, reordering, and lost retransmissions, it is <span class="bcp14">RECOMMENDED</span> that PRR is implemented together with RACK-TLP loss recovery <span>[<a href="#RFC8985" class="cite xref">RFC8985</a>]</span>.<a href="#section-5-2" class="pilcrow">¶</a></p>
<p id="section-5-3">The SafeACK heuristic came about as a result of robust Lost Retransmission Detection under development in an early precursor to <span>[<a href="#RFC8985" class="cite xref">RFC8985</a>]</span>.  Without Lost Retransmission Detection, policers that cause very high loss rates are at very high risk of causing retransmission timeouts because Reno <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span>,  CUBIC <span>[<a href="#RFC9438" class="cite xref">RFC9438</a>]</span>, and <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span> can send retransmissions significantly above the policed rate.<a href="#section-5-3" class="pilcrow">¶</a></p>
</section>
<section id="section-6">
      <h2 id="name-algorithm">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-algorithm" class="section-name selfRef">Algorithm</a>
      </h2>
<section id="section-6.1">
        <h3 id="name-initialization-steps">
<a href="#section-6.1" class="section-number selfRef">6.1. </a><a href="#name-initialization-steps" class="section-name selfRef">Initialization Steps</a>
        </h3>
<p id="section-6.1-1">
At the beginning of a congestion control response episode initiated by the congestion control algorithm, a data sender using PRR <span class="bcp14">MUST</span> initialize the PRR state.<a href="#section-6.1-1" class="pilcrow">¶</a></p>
<p id="section-6.1-2">The timing of the start of a congestion control response episode is entirely up to the congestion control algorithm, and (for example) could correspond to the start of a fast recovery episode, or a once-per-round-trip reduction when lost retransmits or lost original transmissions are detected after fast recovery is already in progress.<a href="#section-6.1-2" class="pilcrow">¶</a></p>
<p id="section-6.1-3">The PRR initialization allows a congestion control algorithm, CongCtrlAlg(), that might set ssthresh to something other than FlightSize/2 (including, e.g., CUBIC <span>[<a href="#RFC9438" class="cite xref">RFC9438</a>]</span>).<a href="#section-6.1-3" class="pilcrow">¶</a></p>
<p id="section-6.1-4"> A key step of PRR initialization is computing Recovery Flight Size (RecoverFS), the number of bytes the data sender estimates might possibly be delivered over the course of the PRR episode. This can be thought of as the sum of the following values at the start of the episode: inflight, the bytes cumulatively acknowledged in the ACK triggering recovery, the bytes SACKed in the ACK triggering recovery, and the bytes between SND.UNA and SND.NXT that have been marked lost. The RecoverFS includes losses because losses are marked using heuristics, so some packets previously marked as lost may ultimately be delivered (without being retransmitted) during recovery. PRR uses RecoverFS to compute a smooth sending rate. Upon entering fast recovery, PRR initializes RecoverFS, and RecoverFS remains constant during a given fast recovery episode.<a href="#section-6.1-4" class="pilcrow">¶</a></p>
<p id="section-6.1-5">The full sequence of PRR algorithm initialization steps is as follows:<a href="#section-6.1-5" class="pilcrow">¶</a></p>
<div class="lang-pseudocode sourcecode" id="section-6.1-6">
<pre>
   ssthresh = CongCtrlAlg()      // Target flight size in recovery
   prr_delivered = 0             // Total bytes delivered in recovery
   prr_out = 0                   // Total bytes sent in recovery
   RecoverFS = SND.NXT - SND.UNA
   // Bytes SACKed before entering recovery will not be
   // marked as delivered during recovery:
   RecoverFS -= (bytes SACKed in scoreboard)
   // Include the (common) case of selectively ACKed bytes:
   RecoverFS += (bytes newly SACKed)
   // Include the (rare) case of cumulatively ACKed bytes:
   RecoverFS += (bytes newly cumulatively acknowledged)
</pre><a href="#section-6.1-6" class="pilcrow">¶</a>
</div>
</section>
<section id="section-6.2">
        <h3 id="name-per-ack-steps">
<a href="#section-6.2" class="section-number selfRef">6.2. </a><a href="#name-per-ack-steps" class="section-name selfRef">Per-ACK Steps</a>
        </h3>
<p id="section-6.2-1">On every ACK starting or during fast recovery, excluding the ACK that concludes a PRR episode, PRR executes the following steps.<a href="#section-6.2-1" class="pilcrow">¶</a></p>
<p id="section-6.2-2">First, the sender computes DeliveredData, the data sender's best estimate of the total number of bytes that the current ACK indicates have been delivered to the receiver since the previously received ACK. With SACK, DeliveredData can be computed precisely as the change in SND.UNA, plus the signed change in quantity of data marked SACKed in the scoreboard. Thus, in the special case when there are no SACKed sequence ranges in the scoreboard before or after the ACK, DeliveredData is the change in SND.UNA. In recovery without SACK, DeliveredData is estimated to be 1 SMSS on each received duplicate ACK (i.e., SND.UNA did not change). When SND.UNA advances (i.e., a full or partial ACK), DeliveredData is the change in SND.UNA, minus 1 SMSS for each preceding duplicate ACK. Note that without SACK, a poorly behaved receiver that returns extraneous duplicate ACKs  (as described in <span>[<a href="#Savage99" class="cite xref">Savage99</a>]</span>) could attempt to artificially inflate DeliveredData. As a mitigation, if not using SACK, then PRR disallows incrementing DeliveredData when the total bytes delivered in a PRR episode would exceed the estimated data outstanding upon entering recovery (RecoverFS).<a href="#section-6.2-2" class="pilcrow">¶</a></p>
<p id="section-6.2-3">Next, the sender computes inflight, the data sender's best estimate of the number of bytes that are in flight in the network. To calculate inflight, connections with SACK enabled and using <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span> loss detection <span class="bcp14">MAY</span> use the "pipe" algorithm as specified in <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>. SACK-enabled connections using RACK-TLP loss detection <span>[<a href="#RFC8985" class="cite xref">RFC8985</a>]</span> or other loss detection algorithms <span class="bcp14">MUST</span> calculate inflight by starting with SND.NXT -  SND.UNA, subtracting out bytes SACKed in the scoreboard, subtracting out bytes marked lost in the scoreboard, and adding bytes in the scoreboard that have been retransmitted since they were last marked lost. For non-SACK-enabled connections, instead of subtracting out bytes SACKed in the SACK scoreboard, senders <span class="bcp14">MUST</span> subtract out: min(RecoverFS, 1 SMSS for each preceding duplicate ACK in the fast recovery episode); the min() with RecoverFS is to protect against misbehaving receivers <span>[<a href="#Savage99" class="cite xref">Savage99</a>]</span>.<a href="#section-6.2-3" class="pilcrow">¶</a></p>
<p id="section-6.2-4">Next, the sender computes SafeACK, a local boolean variable indicating that the current ACK reported good progress. SafeACK is true only when the ACK has cumulatively acknowledged new data and the ACK does not indicate further losses. For example, an ACK triggering "rescue" retransmission (<span><a href="https://rfc-editor.org/rfc/rfc6675#section-4" class="relref">Section 4</a> of [<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>, NextSeg() condition 4) may indicate further losses. Both conditions indicate the recovery is making good progress and the sender can send more aggressively, increasing inflight, if appropriate.<a href="#section-6.2-4" class="pilcrow">¶</a></p>
<p id="section-6.2-5">Finally, the sender uses DeliveredData, inflight, SafeACK, and other PRR state to compute SndCnt, a local variable indicating exactly how many bytes should be sent  in response to each ACK, and then uses  SndCnt to update cwnd.<a href="#section-6.2-5" class="pilcrow">¶</a></p>
<p id="section-6.2-6">The full sequence of per-ACK PRR algorithm steps is as follows:<a href="#section-6.2-6" class="pilcrow">¶</a></p>
<div class="lang-pseudocode sourcecode" id="section-6.2-7">
<pre>
   if (DeliveredData is 0)
      Return


   prr_delivered += DeliveredData
   inflight = (estimated volume of in-flight data)
   SafeACK = (SND.UNA advances and no further loss indicated)
   if (inflight &gt; ssthresh) {
      // Proportional Rate Reduction
      // This uses integer division, rounding up:
      #define DIV_ROUND_UP(n, d) (((n) + (d) - 1) / (d))
      out = DIV_ROUND_UP(prr_delivered * ssthresh, RecoverFS)
      SndCnt = out - prr_out
   } else {
      // PRR-CRB by default
      SndCnt = MAX(prr_delivered - prr_out, DeliveredData)
      if (SafeACK) {
         // PRR-SSRB when recovery is making good progress
         SndCnt += SMSS
      }
      // Attempt to catch up, as permitted
      SndCnt = MIN(ssthresh - inflight, SndCnt)
   }


   if (prr_out is 0 AND SndCnt is 0) {
      // Force a fast retransmit upon entering recovery
      SndCnt = SMSS
   }
   cwnd = inflight + SndCnt</pre><a href="#section-6.2-7" class="pilcrow">¶</a>
</div>
<p id="section-6.2-8">After the sender computes SndCnt and uses it to update cwnd, the sender transmits more data. Note that the decision of which data to send (e.g., retransmit missing data or send more new data) is out of scope for this document.<a href="#section-6.2-8" class="pilcrow">¶</a></p>
</section>
<section id="section-6.3">
        <h3 id="name-per-transmit-steps">
<a href="#section-6.3" class="section-number selfRef">6.3. </a><a href="#name-per-transmit-steps" class="section-name selfRef">Per-Transmit Steps</a>
        </h3>
<p id="section-6.3-1">On any data transmission or retransmission, PRR executes the following:<a href="#section-6.3-1" class="pilcrow">¶</a></p>
<div class="lang-pseudocode sourcecode" id="section-6.3-2">
<pre>
   prr_out += (data sent)
</pre><a href="#section-6.3-2" class="pilcrow">¶</a>
</div>
</section>
<section id="section-6.4">
        <h3 id="name-completion-steps">
<a href="#section-6.4" class="section-number selfRef">6.4. </a><a href="#name-completion-steps" class="section-name selfRef">Completion Steps</a>
        </h3>
<p id="section-6.4-1"> A PRR episode ends upon either completing fast recovery or before initiating a new PRR episode due to a new congestion control response episode.<a href="#section-6.4-1" class="pilcrow">¶</a></p>
<p id="section-6.4-2">On the completion of a PRR episode, PRR executes the following:<a href="#section-6.4-2" class="pilcrow">¶</a></p>
<div class="lang-pseudocode sourcecode" id="section-6.4-3">
<pre>
   cwnd = ssthresh
</pre><a href="#section-6.4-3" class="pilcrow">¶</a>
</div>
<p id="section-6.4-4"> Note that this step that sets cwnd to ssthresh can potentially, in some scenarios, allow a burst of back-to-back segments into the network.<a href="#section-6.4-4" class="pilcrow">¶</a></p>
<p id="section-6.4-5">It is <span class="bcp14">RECOMMENDED</span> that implementations use pacing to reduce the burstiness of data traffic. This recommendation is consistent with current practice to mitigate bursts (e.g., <span>[<a href="#I-D.welzl-iccrg-pacing" class="cite xref">PACING</a>]</span>), including pacing transmission bursts after restarting from idle.<a href="#section-6.4-5" class="pilcrow">¶</a></p>
</section>
</section>
<section id="section-7">
      <h2 id="name-properties">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-properties" class="section-name selfRef">Properties</a>
      </h2>
<p id="section-7-1">The following properties are common to both PRR-CRB and PRR-SSRB, except as noted:<a href="#section-7-1" class="pilcrow">¶</a></p>
<p id="section-7-2">PRR attempts to maintain the sender's ACK clocking across recovery events, including burst losses. By contrast, <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span> can send large, unclocked bursts following burst losses.<a href="#section-7-2" class="pilcrow">¶</a></p>
<p id="section-7-3">Normally, PRR will spread voluntary window reductions out evenly across a full RTT.  This has the potential to generally reduce the burstiness of Internet traffic and could be considered to be a type of soft pacing.   Hypothetically, any pacing increases the probability that different flows are interleaved, reducing the opportunity for ACK compression and other phenomena that increase traffic burstiness. However, these effects have not been quantified.<a href="#section-7-3" class="pilcrow">¶</a></p>
<p id="section-7-4">If there are minimal losses, PRR will converge to exactly the target window chosen by the congestion control algorithm. Note that as the sender approaches the end of recovery, prr_delivered will approach RecoverFS and SndCnt will be computed such that prr_out approaches ssthresh.<a href="#section-7-4" class="pilcrow">¶</a></p>
<p id="section-7-5">Implicit window reductions, due to multiple isolated losses during recovery, cause later voluntary reductions to be skipped.  For small numbers of losses, the window size ends at exactly the window chosen by the congestion control algorithm.<a href="#section-7-5" class="pilcrow">¶</a></p>
<p id="section-7-6">For burst losses, earlier voluntary window reductions can be undone by sending extra segments in response to ACKs arriving later during recovery.    Note that as long as some voluntary window reductions are not undone, and there is no application stall, the final value for inflight will be the same as ssthresh.<a href="#section-7-6" class="pilcrow">¶</a></p>
<p id="section-7-7">PRR using either Reduction Bound improves the situation when there are
application stalls, e.g., when the sending application does not queue data for
transmission quickly enough or the receiver stops advancing its receive window.
When there is an application stall early during recovery, prr_out will
fall behind the sum of transmissions allowed by SndCnt.   The missed
opportunities to send due to stalls are treated like banked voluntary window
reductions; specifically, they cause prr_delivered - prr_out to be significantly positive.  If the application catches up while the sender is still in recovery, the sender will send a partial window burst to grow inflight to catch up to exactly where it would have been had the application never stalled.   Although such a burst could negatively impact the given flow or other sharing flows, this is exactly what happens every time there is a partial-RTT application stall while not in recovery.   PRR makes partial-RTT stall behavior uniform in all states.  Changing this behavior is out of scope for this document.<a href="#section-7-7" class="pilcrow">¶</a></p>
<p id="section-7-8">PRR with Reduction Bound is less sensitive to errors in the inflight estimator.
While in recovery, inflight is intrinsically an estimator, using incomplete
information to estimate if un-SACKed segments are actually lost or merely out
of order in the network.   Under some conditions, inflight can have significant errors; for example, inflight is underestimated when a burst of reordered data is prematurely assumed to be lost and marked for retransmission. If the transmissions are regulated directly by inflight as they are with <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>, a step discontinuity in the inflight estimator causes a burst of data, which cannot be retracted once the inflight estimator is corrected a few ACKs later.   For PRR dynamics, inflight merely determines which algorithm, PRR or the Reduction Bound, is used to compute SndCnt from DeliveredData.  While inflight is underestimated, the algorithms are different by at most 1 segment per ACK.  Once inflight is updated, they converge to the same final window at the end of recovery.<a href="#section-7-8" class="pilcrow">¶</a></p>
<p id="section-7-9">Under all conditions and sequences of events during recovery, PRR-CRB strictly bounds the data transmitted to be equal to or less than the amount of data delivered to the receiver.   This Strong Packet Conservation Bound is the most aggressive algorithm that does not lead to additional forced losses in some environments.   It has the property that if there is a standing queue at a bottleneck with no cross traffic, the queue will maintain exactly constant length for the duration of the recovery, except for +1/-1 fluctuation due to differences in packet arrival and exit times.  See  <a href="#conservative" class="auto internal xref">Appendix A</a> for a detailed discussion of this property.<a href="#section-7-9" class="pilcrow">¶</a></p>
<p id="section-7-10">Although the Strong Packet Conservation Bound is very appealing for a number of reasons, earlier measurements (in <span><a href="https://rfc-editor.org/rfc/rfc6675#section-6" class="relref">Section 6</a> of [<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>)  demonstrate that it is less aggressive and does not perform as well as <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>, which permits bursts of data when there are bursts of losses.   PRR-SSRB is a compromise that permits a sender to send one extra segment per ACK as compared to the Packet Conserving Bound when the ACK indicates the recovery is in good progress without further losses.  From the perspective of a strict Packet Conserving Bound, PRR-SSRB does indeed open the window during recovery; however, it is significantly less aggressive than <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span> in the presence of burst losses.<a href="#section-7-10" class="pilcrow">¶</a></p>
</section>
<section id="section-8">
      <h2 id="name-examples">
<a href="#section-8" class="section-number selfRef">8. </a><a href="#name-examples" class="section-name selfRef">Examples</a>
      </h2>
<p id="section-8-1">This section illustrates the PRR and <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span> algorithms by showing their different behaviors for two example scenarios: a connection experiencing either a single loss or a burst of 15 consecutive losses. All cases use bulk data transfers (no application pauses), Reno congestion control <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span>, and cwnd = FlightSize = inflight = 20 segments, so ssthresh will be set to 10 at the beginning of recovery.   The scenarios use standard Fast Retransmit <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span> and Limited Transmit <span>[<a href="#RFC3042" class="cite xref">RFC3042</a>]</span>, so the sender will send two new segments followed by one retransmit in response to the first three duplicate ACKs following the losses.<a href="#section-8-1" class="pilcrow">¶</a></p>
<p id="section-8-2">Each of the diagrams below shows the per ACK response to the first round trip for the two recovery algorithms when the zeroth segment is lost.   The top line ("ack#") indicates the transmitted segment number triggering the ACKs, with an X for the lost segment.  The "cwnd" and "inflight" lines indicate the values of cwnd and inflight, respectively, for these algorithms after processing each returning ACK but before further (re)transmission.  The "sent" line indicates how much "N"ew or "R"etransmitted data would be sent.  Note that the algorithms for deciding which data to send are out of scope of this document.<a href="#section-8-2" class="pilcrow">¶</a></p>
<figure id="figure-1">
        <div class="alignLeft art-text artwork" id="section-8-3.1">
<pre>
RFC 6675
a X  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22
c   20 20 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10
i   19 19 18 18 17 16 15 14 13 12 11 10  9  9  9  9  9  9  9  9  9  9
s    N  N  R                             N  N  N  N  N  N  N  N  N  N








PRR
a X  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22
c   20 20 19 18 18 17 17 16 16 15 15 14 14 13 13 12 12 11 11 10 10 10
i   19 19 18 18 17 17 16 16 15 15 14 14 13 13 12 12 11 11 10 10  9  9
s    N  N  R     N     N     N     N     N     N     N     N     N  N


a: ack#;  c: cwnd;  i: inflight;  s: sent
</pre>
</div>
<figcaption><a href="#figure-1" class="selfRef">Figure 1</a></figcaption></figure>
<p id="section-8-4">In this first example, ACK#1 through ACK#19 contain SACKs for the original flight of data, ACK#20 and ACK#21 carry SACKs for the limited transmits triggered by the first and second SACKed segments, and ACK#22 carries the full cumulative ACK covering all data up through the limited transmits. ACK#22 completes the fast recovery episode and thus completes the PRR episode.<a href="#section-8-4" class="pilcrow">¶</a></p>
<p id="section-8-5">Note that both algorithms send the same total amount of data, and both algorithms complete the fast recovery episode with a cwnd matching the ssthresh of 20.  <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span> experiences a "half window of silence" while PRR spreads the voluntary window reduction across an entire RTT.<a href="#section-8-5" class="pilcrow">¶</a></p>
<p id="section-8-6">Next, consider an example scenario with the same initial conditions, except that the first 15 packets (0-14) are lost.   During the remainder of the lossy round trip, only 5 ACKs are returned to the sender.   The following examines each of these algorithms in succession.<a href="#section-8-6" class="pilcrow">¶</a></p>
<figure id="figure-2">
        <div class="alignLeft art-text artwork" id="section-8-7.1">
<pre>
RFC 6675
a X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  15 16 17 18 19
c                                              20 20 10 10 10
i                                              19 19  4  9  9
s                                               N  N 6R  R  R




PRR
a X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  15 16 17 18 19
c                                              20 20  5  5  5
i                                              19 19  4  4  4
s                                               N  N  R  R  R


a: ack#;  c: cwnd;  i: inflight;  s: sent
</pre>
</div>
<figcaption><a href="#figure-2" class="selfRef">Figure 2</a></figcaption></figure>
<p id="section-8-8">In this specific situation, <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span> is more aggressive because once Fast Retransmit is triggered (on the ACK for segment 17), the sender  immediately retransmits sufficient data to bring inflight up to cwnd.  Earlier measurements (in <span><a href="https://rfc-editor.org/rfc/rfc6675#section-6" class="relref">Section 6</a> of [<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>) indicate that <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span> significantly outperforms the <span>[<a href="#RFC6937" class="cite xref">RFC6937</a>]</span> version of PRR using only PRR-CRB and some other similarly conservative algorithms that were tested, showing that it is significantly common for the actual losses to exceed the cwnd reduction determined by the congestion control algorithm.<a href="#section-8-8" class="pilcrow">¶</a></p>
<p id="section-8-9">Under such heavy losses, during the first round trip of fast recovery, PRR uses the PRR-CRB to follow the packet conservation principle.   Since the total losses bring inflight below ssthresh, data is sent such that the total data transmitted, prr_out, follows the total data delivered to the receiver as reported by returning ACKs. Transmission is controlled by the sending limit, which is set to prr_delivered - prr_out.<a href="#section-8-9" class="pilcrow">¶</a></p>
<p id="section-8-10">While not shown in the figure above, once the fast retransmits sent starting at ACK#17 are delivered and elicit ACKs that increment the SND.UNA, PRR enters PRR-SSRB and  increases the window by exactly 1 segment per ACK until inflight rises to ssthresh during recovery.  On heavy losses when cwnd is large, PRR-SSRB recovers the losses exponentially faster than PRR-CRB. Although increasing the window during recovery seems to be ill advised, it is important to remember that this is actually less aggressive than permitted by <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>, which sends the same quantity of additional data as a single burst in response to the ACK that triggered Fast Retransmit.<a href="#section-8-10" class="pilcrow">¶</a></p>
<p id="section-8-11">For less severe loss events, where the total losses are smaller than the difference between FlightSize and ssthresh, PRR-CRB and PRR-SSRB are not invoked since PRR stays in the Proportional Rate Reduction mode.<a href="#section-8-11" class="pilcrow">¶</a></p>
</section>
<section id="section-9">
      <h2 id="name-adapting-prr-to-other-trans">
<a href="#section-9" class="section-number selfRef">9. </a><a href="#name-adapting-prr-to-other-trans" class="section-name selfRef">Adapting PRR to Other Transport Protocols</a>
      </h2>
<p id="section-9-1">The main PRR algorithm and reductions bounds can be adapted to any transport that can support <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>. In one major implementation (Linux TCP), PRR has been the fast recovery algorithm for its default and supported congestion control modules since its introduction in 2011 <span>[<a href="#First_TCP_PRR" class="cite xref">First_TCP_PRR</a>]</span>.<a href="#section-9-1" class="pilcrow">¶</a></p>
<p id="section-9-2">The SafeACK heuristic can be generalized as any ACK of a retransmission that does not cause some other segment to be marked for retransmission.<a href="#section-9-2" class="pilcrow">¶</a></p>
</section>
<section id="section-10">
      <h2 id="name-measurement-studies">
<a href="#section-10" class="section-number selfRef">10. </a><a href="#name-measurement-studies" class="section-name selfRef">Measurement Studies</a>
      </h2>
<p id="section-10-1">
For <span>[<a href="#RFC6937" class="cite xref">RFC6937</a>]</span>, a companion paper <span>[<a href="#IMC11" class="cite xref">IMC11</a>]</span> evaluated <span>[<a href="#RFC3517" class="cite xref">RFC3517</a>]</span> and various experimental PRR versions in a large-scale measurement study.  At the time of publication, the legacy algorithms used in that study are no longer present in the code base used in that study, making such comparisons difficult without recreating historical algorithms.   Readers interested in the measurement study should review <span><a href="https://rfc-editor.org/rfc/rfc6937#section-5" class="relref">Section 5</a> of [<a href="#RFC6937" class="cite xref">RFC6937</a>]</span> and the IMC paper <span>[<a href="#IMC11" class="cite xref">IMC11</a>]</span>.<a href="#section-10-1" class="pilcrow">¶</a></p>
</section>
<section id="section-11">
      <h2 id="name-operational-considerations">
<a href="#section-11" class="section-number selfRef">11. </a><a href="#name-operational-considerations" class="section-name selfRef">Operational Considerations</a>
      </h2>
<section id="section-11.1">
        <h3 id="name-incremental-deployment">
<a href="#section-11.1" class="section-number selfRef">11.1. </a><a href="#name-incremental-deployment" class="section-name selfRef">Incremental Deployment</a>
        </h3>
<p id="section-11.1-1">
PRR is incrementally deployable, because it utilizes only existing transport protocol mechanisms for data delivery acknowledgment and the detection of lost data. PRR only requires changes to the transport protocol implementation at the data sender; it does not require any changes at data receivers or in networks. This allows data senders using PRR to work correctly with any existing data receivers or networks. PRR does not require any changes to or assistance from routers, switches, or other devices in the network.<a href="#section-11.1-1" class="pilcrow">¶</a></p>
</section>
<section id="section-11.2">
        <h3 id="name-fairness">
<a href="#section-11.2" class="section-number selfRef">11.2. </a><a href="#name-fairness" class="section-name selfRef">Fairness</a>
        </h3>
<p id="section-11.2-1">
PRR is designed to maintain the fairness properties of the congestion control algorithm with which it is deployed. PRR only operates during a congestion control response episode, such as fast recovery or when there is a step reduction in the cwnd from the TCP ECN reaction defined in <span>[<a href="#RFC3168" class="cite xref">RFC3168</a>]</span>, and only makes short-term, per-acknowledgment decisions to smoothly regulate the  volume of in-flight data during an episode such that at the end of the episode it will be as close as possible to the slow start threshold (ssthresh), as determined by the congestion control algorithm. PRR does not modify the congestion control cwnd increase or decrease mechanisms outside of congestion control response episodes.<a href="#section-11.2-1" class="pilcrow">¶</a></p>
</section>
<section id="section-11.3">
        <h3 id="name-protecting-the-network-agai">
<a href="#section-11.3" class="section-number selfRef">11.3. </a><a href="#name-protecting-the-network-agai" class="section-name selfRef">Protecting the Network Against Excessive Queuing and Packet Loss</a>
        </h3>
<p id="section-11.3-1">Over long time scales, PRR is designed to maintain the queuing and packet loss properties of the congestion control algorithm with which it is deployed. As noted above, PRR only operates during a congestion control response episode, such as fast recovery or response to ECN, and only makes short-term, per-acknowledgment decisions to smoothly regulate the  volume of in-flight data during an episode such that at the end of the episode it will be as close as possible to the slow start threshold (ssthresh), as determined by the congestion control algorithm.<a href="#section-11.3-1" class="pilcrow">¶</a></p>
<p id="section-11.3-2"> Over short time scales, PRR is designed to cause lower packet loss rates than preceding approaches like <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>. At a high level, PRR is inspired by the packet conservation principle, and as much as possible, PRR relies on the self clock process. By contrast, with <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>, a single ACK carrying a SACK option that implies a large quantity of missing data can cause a step discontinuity in the pipe estimator, which can cause Fast Retransmit to send a large burst of data that is much larger than the volume of delivered data. PRR avoids such bursts by basing transmission decisions on the volume of delivered data rather than the volume of lost data. Furthermore, as noted above, PRR-SSRB is less aggressive than <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span> (transmitting fewer segments or taking more time to transmit them), and it outperforms due to the lower probability of additional losses during recovery.<a href="#section-11.3-2" class="pilcrow">¶</a></p>
</section>
</section>
<div id="IANA">
<section id="section-12">
      <h2 id="name-iana-considerations">
<a href="#section-12" class="section-number selfRef">12. </a><a href="#name-iana-considerations" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-12-1">This document has no IANA actions.<a href="#section-12-1" class="pilcrow">¶</a></p>
</section>
</div>
<section id="section-13">
      <h2 id="name-security-considerations">
<a href="#section-13" class="section-number selfRef">13. </a><a href="#name-security-considerations" class="section-name selfRef">Security Considerations</a>
      </h2>
<p id="section-13-1">PRR does not change the risk profile for transport protocols.<a href="#section-13-1" class="pilcrow">¶</a></p>
<p id="section-13-2">Implementers that change PRR from counting bytes to segments have to be cautious about the effects of ACK splitting attacks <span>[<a href="#Savage99" class="cite xref">Savage99</a>]</span>, where the receiver acknowledges partial segments for the purpose of confusing the sender's congestion accounting.<a href="#section-13-2" class="pilcrow">¶</a></p>
</section>
<section id="section-14">
      <h2 id="name-references">
<a href="#section-14" class="section-number selfRef">14. </a><a href="#name-references" class="section-name selfRef">References</a>
      </h2>
<section id="section-14.1">
        <h3 id="name-normative-references">
<a href="#section-14.1" class="section-number selfRef">14.1. </a><a href="#name-normative-references" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="RFC1191">[RFC1191]</dt>
        <dd>
<span class="refAuthor">Mogul, J.</span> and <span class="refAuthor">S. Deering</span>, <span class="refTitle">"Path MTU discovery"</span>, <span class="seriesInfo">RFC 1191</span>, <span class="seriesInfo">DOI 10.17487/RFC1191</span>, <time datetime="1990-11" class="refDate">November 1990</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc1191">https://www.rfc-editor.org/info/rfc1191</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC2018">[RFC2018]</dt>
        <dd>
<span class="refAuthor">Mathis, M.</span>, <span class="refAuthor">Mahdavi, J.</span>, <span class="refAuthor">Floyd, S.</span>, and <span class="refAuthor">A. Romanow</span>, <span class="refTitle">"TCP Selective Acknowledgment Options"</span>, <span class="seriesInfo">RFC 2018</span>, <span class="seriesInfo">DOI 10.17487/RFC2018</span>, <time datetime="1996-10" class="refDate">October 1996</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2018">https://www.rfc-editor.org/info/rfc2018</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC2119">[RFC2119]</dt>
        <dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03" class="refDate">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4821">[RFC4821]</dt>
        <dd>
<span class="refAuthor">Mathis, M.</span> and <span class="refAuthor">J. Heffner</span>, <span class="refTitle">"Packetization Layer Path MTU Discovery"</span>, <span class="seriesInfo">RFC 4821</span>, <span class="seriesInfo">DOI 10.17487/RFC4821</span>, <time datetime="2007-03" class="refDate">March 2007</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4821">https://www.rfc-editor.org/info/rfc4821</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5681">[RFC5681]</dt>
        <dd>
<span class="refAuthor">Allman, M.</span>, <span class="refAuthor">Paxson, V.</span>, and <span class="refAuthor">E. Blanton</span>, <span class="refTitle">"TCP Congestion Control"</span>, <span class="seriesInfo">RFC 5681</span>, <span class="seriesInfo">DOI 10.17487/RFC5681</span>, <time datetime="2009-09" class="refDate">September 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5681">https://www.rfc-editor.org/info/rfc5681</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6582">[RFC6582]</dt>
        <dd>
<span class="refAuthor">Henderson, T.</span>, <span class="refAuthor">Floyd, S.</span>, <span class="refAuthor">Gurtov, A.</span>, and <span class="refAuthor">Y. Nishida</span>, <span class="refTitle">"The NewReno Modification to TCP's Fast Recovery Algorithm"</span>, <span class="seriesInfo">RFC 6582</span>, <span class="seriesInfo">DOI 10.17487/RFC6582</span>, <time datetime="2012-04" class="refDate">April 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6582">https://www.rfc-editor.org/info/rfc6582</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6675">[RFC6675]</dt>
        <dd>
<span class="refAuthor">Blanton, E.</span>, <span class="refAuthor">Allman, M.</span>, <span class="refAuthor">Wang, L.</span>, <span class="refAuthor">Jarvinen, I.</span>, <span class="refAuthor">Kojo, M.</span>, and <span class="refAuthor">Y. Nishida</span>, <span class="refTitle">"A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP"</span>, <span class="seriesInfo">RFC 6675</span>, <span class="seriesInfo">DOI 10.17487/RFC6675</span>, <time datetime="2012-08" class="refDate">August 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6675">https://www.rfc-editor.org/info/rfc6675</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8174">[RFC8174]</dt>
        <dd>
<span class="refAuthor">Leiba, B.</span>, <span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time datetime="2017-05" class="refDate">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8201">[RFC8201]</dt>
        <dd>
<span class="refAuthor">McCann, J.</span>, <span class="refAuthor">Deering, S.</span>, <span class="refAuthor">Mogul, J.</span>, and <span class="refAuthor">R. Hinden, Ed.</span>, <span class="refTitle">"Path MTU Discovery for IP version 6"</span>, <span class="seriesInfo">STD 87</span>, <span class="seriesInfo">RFC 8201</span>, <span class="seriesInfo">DOI 10.17487/RFC8201</span>, <time datetime="2017-07" class="refDate">July 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8201">https://www.rfc-editor.org/info/rfc8201</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8985">[RFC8985]</dt>
        <dd>
<span class="refAuthor">Cheng, Y.</span>, <span class="refAuthor">Cardwell, N.</span>, <span class="refAuthor">Dukkipati, N.</span>, and <span class="refAuthor">P. Jha</span>, <span class="refTitle">"The RACK-TLP Loss Detection Algorithm for TCP"</span>, <span class="seriesInfo">RFC 8985</span>, <span class="seriesInfo">DOI 10.17487/RFC8985</span>, <time datetime="2021-02" class="refDate">February 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8985">https://www.rfc-editor.org/info/rfc8985</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9293">[RFC9293]</dt>
        <dd>
<span class="refAuthor">Eddy, W., Ed.</span>, <span class="refTitle">"Transmission Control Protocol (TCP)"</span>, <span class="seriesInfo">STD 7</span>, <span class="seriesInfo">RFC 9293</span>, <span class="seriesInfo">DOI 10.17487/RFC9293</span>, <time datetime="2022-08" class="refDate">August 2022</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9293">https://www.rfc-editor.org/info/rfc9293</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9438">[RFC9438]</dt>
      <dd>
<span class="refAuthor">Xu, L.</span>, <span class="refAuthor">Ha, S.</span>, <span class="refAuthor">Rhee, I.</span>, <span class="refAuthor">Goel, V.</span>, and <span class="refAuthor">L. Eggert, Ed.</span>, <span class="refTitle">"CUBIC for Fast and Long-Distance Networks"</span>, <span class="seriesInfo">RFC 9438</span>, <span class="seriesInfo">DOI 10.17487/RFC9438</span>, <time datetime="2023-08" class="refDate">August 2023</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9438">https://www.rfc-editor.org/info/rfc9438</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
<section id="section-14.2">
        <h3 id="name-informative-references">
<a href="#section-14.2" class="section-number selfRef">14.2. </a><a href="#name-informative-references" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="FACK">[FACK]</dt>
        <dd>
<span class="refAuthor">Mathis, M.</span> and <span class="refAuthor">J. Mahdavi</span>, <span class="refTitle">"Forward Acknowledgment: Refining TCP Congestion Control"</span>, <span class="refContent">SIGCOMM '96: Conference Proceedings on Applications, Technologies, Architectures, and Protocols for Computer Communications, pp. 281-291</span>, <span class="seriesInfo">DOI 10.1145/248156.248181</span>, <time datetime="1996-08" class="refDate">August 1996</time>, <span>&lt;<a href="https://dl.acm.org/doi/10.1145/248156.248181">https://dl.acm.org/doi/10.1145/248156.248181</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="First_TCP_PRR">[First_TCP_PRR]</dt>
        <dd>
<span class="refTitle">"Proportional Rate Reduction for TCP."</span>, <span class="refContent">commit a262f0cdf1f2916ea918dc329492abb5323d9a6c</span>, <time datetime="2011-08" class="refDate">August 2011</time>, <span>&lt;<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=a262f0cdf1f2916ea918dc329492abb5323d9a6c">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=a262f0cdf1f2916ea918dc329492abb5323d9a6c</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Flach2016policing">[Flach2016policing]</dt>
        <dd>
<span class="refAuthor">Flach, T.</span>, <span class="refAuthor">Papageorge, P.</span>, <span class="refAuthor">Terzis, A.</span>, <span class="refAuthor">Pedrosa, L.</span>, <span class="refAuthor">Cheng, Y.</span>, <span class="refAuthor">Karim, T.</span>, <span class="refAuthor">Katz-Bassett, E.</span>, and <span class="refAuthor">R. Govindan</span>, <span class="refTitle">"An Internet-Wide Analysis of Traffic Policing"</span>, <span class="refContent">SIGCOMM '16: Proceedings of the 2016 ACM SIGCOMM Conference, pp. 468-482</span>, <span class="seriesInfo">DOI 10.1145/2934872.2934873</span>, <time datetime="2016-08" class="refDate">August 2016</time>, <span>&lt;<a href="https://doi.org/10.1145/2934872.2934873">https://doi.org/10.1145/2934872.2934873</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Hoe96Startup">[Hoe96Startup]</dt>
        <dd>
<span class="refAuthor">Hoe, J.</span>, <span class="refTitle">"Improving the Start-up Behavior of a Congestion Control Scheme for TCP"</span>, <span class="refContent">SIGCOMM '96: Conference Proceedings on Applications, Technologies, Architectures, and Protocols for Computer Communications, pp. 270-280</span>, <span class="seriesInfo">DOI 10.1145/248156.248180</span>, <time datetime="1996-08" class="refDate">August 1996</time>, <span>&lt;<a href="https://doi.org/10.1145/248156.248180">https://doi.org/10.1145/248156.248180</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="IMC11">[IMC11]</dt>
        <dd>
<span class="refAuthor">Dukkipati, N.</span>, <span class="refAuthor">Mathis, M.</span>, <span class="refAuthor">Cheng, Y.</span>, and <span class="refAuthor">M. Ghobadi</span>, <span class="refTitle">"Proportional Rate Reduction for TCP"</span>, <span class="refContent">IMC '11: Proceedings of the 2011 ACM SIGCOMM Conference on Internet Measurement Conference, pp. 155-170</span>, <span class="seriesInfo">DOI 10.1145/2068816.2068832</span>, <time datetime="2011-11" class="refDate">November 2011</time>, <span>&lt;<a href="https://doi.org/10.1145/2068816.2068832">https://doi.org/10.1145/2068816.2068832</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Jacobson88">[Jacobson88]</dt>
        <dd>
<span class="refAuthor">Jacobson, V.</span>, <span class="refTitle">"Congestion Avoidance and Control"</span>, <span class="refContent">Symposium proceedings on Communications architectures and protocols (SIGCOMM '88), pp. 314-329</span>, <span class="seriesInfo">DOI 10.1145/52325.52356</span>, <time datetime="1988-08" class="refDate">August 1988</time>, <span>&lt;<a href="https://doi.org/10.1145/52325.52356">https://doi.org/10.1145/52325.52356</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.welzl-iccrg-pacing">[PACING]</dt>
        <dd>
<span class="refAuthor">Welzl, M.</span>, <span class="refAuthor">Eddy, W.</span>, <span class="refAuthor">Goel, V.</span>, and <span class="refAuthor">M. Tüxen</span>, <span class="refTitle">"Pacing in Transport Protocols"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-welzl-iccrg-pacing-03</span>, <time datetime="2025-07-07" class="refDate">7 July 2025</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-welzl-iccrg-pacing-03">https://datatracker.ietf.org/doc/html/draft-welzl-iccrg-pacing-03</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3042">[RFC3042]</dt>
        <dd>
<span class="refAuthor">Allman, M.</span>, <span class="refAuthor">Balakrishnan, H.</span>, and <span class="refAuthor">S. Floyd</span>, <span class="refTitle">"Enhancing TCP's Loss Recovery Using Limited Transmit"</span>, <span class="seriesInfo">RFC 3042</span>, <span class="seriesInfo">DOI 10.17487/RFC3042</span>, <time datetime="2001-01" class="refDate">January 2001</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3042">https://www.rfc-editor.org/info/rfc3042</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3168">[RFC3168]</dt>
        <dd>
<span class="refAuthor">Ramakrishnan, K.</span>, <span class="refAuthor">Floyd, S.</span>, and <span class="refAuthor">D. Black</span>, <span class="refTitle">"The Addition of Explicit Congestion Notification (ECN) to IP"</span>, <span class="seriesInfo">RFC 3168</span>, <span class="seriesInfo">DOI 10.17487/RFC3168</span>, <time datetime="2001-09" class="refDate">September 2001</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3168">https://www.rfc-editor.org/info/rfc3168</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3517">[RFC3517]</dt>
        <dd>
<span class="refAuthor">Blanton, E.</span>, <span class="refAuthor">Allman, M.</span>, <span class="refAuthor">Fall, K.</span>, and <span class="refAuthor">L. Wang</span>, <span class="refTitle">"A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP"</span>, <span class="seriesInfo">RFC 3517</span>, <span class="seriesInfo">DOI 10.17487/RFC3517</span>, <time datetime="2003-04" class="refDate">April 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3517">https://www.rfc-editor.org/info/rfc3517</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6937">[RFC6937]</dt>
        <dd>
<span class="refAuthor">Mathis, M.</span>, <span class="refAuthor">Dukkipati, N.</span>, and <span class="refAuthor">Y. Cheng</span>, <span class="refTitle">"Proportional Rate Reduction for TCP"</span>, <span class="seriesInfo">RFC 6937</span>, <span class="seriesInfo">DOI 10.17487/RFC6937</span>, <time datetime="2013-05" class="refDate">May 2013</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6937">https://www.rfc-editor.org/info/rfc6937</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9743">[RFC9743]</dt>
        <dd>
<span class="refAuthor">Duke, M., Ed.</span> and <span class="refAuthor">G. Fairhurst, Ed.</span>, <span class="refTitle">"Specifying New Congestion Control Algorithms"</span>, <span class="seriesInfo">BCP 133</span>, <span class="seriesInfo">RFC 9743</span>, <span class="seriesInfo">DOI 10.17487/RFC9743</span>, <time datetime="2025-03" class="refDate">March 2025</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9743">https://www.rfc-editor.org/info/rfc9743</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Savage99">[Savage99]</dt>
        <dd>
<span class="refAuthor">Savage, S.</span>, <span class="refAuthor">Cardwell, N.</span>, <span class="refAuthor">Wetherall, D.</span>, and <span class="refAuthor">T. Anderson</span>, <span class="refTitle">"TCP Congestion Control with a Misbehaving Receiver"</span>, <span class="refContent">ACM SIGCOMM Computer Communication Review, vol. 29, no. 5, pp. 71-78</span>, <span class="seriesInfo">DOI 10.1145/505696.505704</span>, <time datetime="1999-10" class="refDate">October 1999</time>, <span>&lt;<a href="https://doi.org/10.1145/505696.505704">https://doi.org/10.1145/505696.505704</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.mathis-tcp-ratehalving">[TCP-RH]</dt>
      <dd>
<span class="refAuthor">Mathis, M.</span>, <span class="refAuthor">Mahdavi, J.</span>, and <span class="refAuthor">J. Semke</span>, <span class="refTitle">"The Rate-Halving Algorithm for TCP Congestion Control"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-mathis-tcp-ratehalving-00</span>, <time datetime="1999-08-30" class="refDate">30 August 1999</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-mathis-tcp-ratehalving-00">https://datatracker.ietf.org/doc/html/draft-mathis-tcp-ratehalving-00</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</section>
<div id="conservative">
<section id="appendix-A">
      <h2 id="name-strong-packet-conservation-">
<a href="#appendix-A" class="section-number selfRef">Appendix A. </a><a href="#name-strong-packet-conservation-" class="section-name selfRef">Strong Packet Conservation Bound</a>
      </h2>
<p id="appendix-A-1">
PRR-CRB is based on a conservative, philosophically pure, and aesthetically appealing Strong Packet Conservation Bound, described here.   Although inspired by the packet conservation principle <span>[<a href="#Jacobson88" class="cite xref">Jacobson88</a>]</span>, it differs in how it treats segments that are missing and presumed lost.   Under all conditions and sequences of events during recovery, PRR-CRB strictly bounds the data transmitted to be equal to or less than the amount of data delivered to the receiver.   
Note that the effects of presumed losses are included in the inflight calculation but do not affect the outcome of PRR-CRB once inflight has fallen below ssthresh.<a href="#appendix-A-1" class="pilcrow">¶</a></p>
<p id="appendix-A-2">This Strong Packet Conservation Bound is the most aggressive algorithm that does not lead to additional forced losses in some environments.   It has the property that if there is a standing queue at a bottleneck that is carrying no other traffic, the queue will maintain exactly constant length for the entire  duration of the recovery, except for +1/-1 fluctuation due to differences in packet arrival and exit times.    Any less aggressive algorithm will result in a declining queue at the bottleneck.  Any more aggressive algorithm will result in an increasing queue or additional losses if it is a full drop tail queue.<a href="#appendix-A-2" class="pilcrow">¶</a></p>
<p id="appendix-A-3">This property is demonstrated with a thought experiment:<a href="#appendix-A-3" class="pilcrow">¶</a></p>
<p id="appendix-A-4">
Imagine a network path that has insignificant delays in both directions, except for the processing time and queue at a single bottleneck in the forward path.  In particular, when a packet is "served" at the head of the bottleneck queue, the following events happen in much less than one bottleneck packet time: the packet arrives at the receiver; the receiver sends an ACK that arrives at the sender; the sender processes the ACK and sends some data; the data is queued at the bottleneck.<a href="#appendix-A-4" class="pilcrow">¶</a></p>
<p id="appendix-A-5">
If SndCnt is set to DeliveredData and nothing else is inhibiting sending data,
then clearly the data arriving at the bottleneck queue will exactly replace the
data that was served at the head of the queue, so the queue will have a
constant length.  If the queue is drop tail and full, then the queue will stay
exactly full. Losses or reordering on the ACK path only cause wider
fluctuations in the queue size but do not raise its peak size, independent of
whether the data is in order or out of order (including loss recovery from an earlier RTT).  Any more aggressive algorithm that sends additional data will overflow the drop tail queue and cause loss.  Any less aggressive algorithm will under-fill the queue.  Therefore, setting SndCnt to DeliveredData is the most aggressive algorithm that does not cause forced losses in this simple network.  Relaxing the assumptions (e.g., making delays more authentic and adding more flows, delayed ACKs, etc.) is likely to increase the fine-grained fluctuations in queue size but does not change its basic behavior.<a href="#appendix-A-5" class="pilcrow">¶</a></p>
<p id="appendix-A-6">Note that the congestion control algorithm implements a broader notion of optimal that includes appropriately sharing the network.  Typical congestion control algorithms are likely to reduce the data sent relative to the Packet Conserving Bound implemented by PRR, bringing TCP's actual window down to ssthresh.<a href="#appendix-A-6" class="pilcrow">¶</a></p>
</section>
</div>
<section id="appendix-B">
      <h2 id="name-acknowledgments">
<a href="#name-acknowledgments" class="section-name selfRef">Acknowledgments</a>
      </h2>
<p id="appendix-B-1">This document is based in part on previous work by <span class="contact-name">Janey C. Hoe</span> (see "Recovery from Multiple Packet Losses", Section 3.2 of <span>[<a href="#Hoe96Startup" class="cite xref">Hoe96Startup</a>]</span>), <span class="contact-name">Matt Mathis</span>, <span class="contact-name">Jeff Semke</span>, and <span class="contact-name">Jamshid Mahdavi</span> <span>[<a href="#I-D.mathis-tcp-ratehalving" class="cite xref">TCP-RH</a>]</span> and influenced by several discussions with <span class="contact-name">John Heffner</span>.<a href="#appendix-B-1" class="pilcrow">¶</a></p>
<p id="appendix-B-2"><span class="contact-name">Monia Ghobadi</span> and <span class="contact-name">Sivasankar Radhakrishnan</span> helped analyze the experiments. <span class="contact-name">Ilpo Jarvinen</span> reviewed the initial implementation. <span class="contact-name">Mark Allman</span>, <span class="contact-name">Richard Scheffenegger</span>, <span class="contact-name">Markku Kojo</span>, <span class="contact-name">Mirja Kuehlewind</span>, <span class="contact-name">Gorry Fairhurst</span>, <span class="contact-name">Russ Housley</span>, <span class="contact-name">Paul Aitken</span>, <span class="contact-name">Daniele Ceccarelli</span>, and <span class="contact-name">Mohamed Boucadair</span> improved the document through their insightful reviews and suggestions.<a href="#appendix-B-2" class="pilcrow">¶</a></p>
</section>
<div id="authors-addresses">
<section id="appendix-C">
      <h2 id="name-authors-addresses">
<a href="#name-authors-addresses" class="section-name selfRef">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Matt Mathis</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:matt.mathis@gmail.com" class="email">matt.mathis@gmail.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Neal Cardwell</span></div>
<div dir="auto" class="left"><span class="org">Google, Inc.</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:ncardwell@google.com" class="email">ncardwell@google.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Yuchung Cheng</span></div>
<div dir="auto" class="left"><span class="org">Google, Inc.</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:ycheng@google.com" class="email">ycheng@google.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Nandita Dukkipati</span></div>
<div dir="auto" class="left"><span class="org">Google, Inc.</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:nanditad@google.com" class="email">nanditad@google.com</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
