<!DOCTYPE html>
<html lang="en" class="BCP RFC">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>RFC 9700: Best Current Practice for OAuth 2.0 Security</title>
<meta content="Torsten Lodderstedt" name="author">
<meta content="John Bradley" name="author">
<meta content="Andrey Labunets" name="author">
<meta content="Daniel Fett" name="author">
<meta content="
       This document describes best current security practice for OAuth 2.0. It updates
and extends the threat model and security advice given in RFCs 6749, 6750, and 6819 to incorporate practical experiences gathered since
OAuth 2.0 was published and covers new threats relevant due to the broader
application of OAuth 2.0. Further, it deprecates some modes of operation that are
deemed less secure or even insecure. 
    " name="description">
<meta content="xml2rfc 3.26.0" name="generator">
<meta content="threat model" name="keyword">
<meta content="attacks" name="keyword">
<meta content="mitigations" name="keyword">
<meta content="9700" name="rfc.number">
<!-- Generator version information:
  xml2rfc 3.26.0
    Python 3.9.15
    ConfigArgParse 1.5.3
    google-i18n-address 3.0.0
    intervaltree 3.1.0
    Jinja2 3.1.2
    lxml 5.3.0
    platformdirs 3.8.0
    pycountry 22.3.5
    pydyf 0.10.0
    PyYAML 6.0
    requests 2.28.0
    setuptools 44.1.1
    wcwidth 0.2.5
    weasyprint 62.3
-->
<link href="rfc9700.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">/*

  NOTE: Changes at the bottom of this file overrides some earlier settings.

  Once the style has stabilized and has been adopted as an official RFC style,
  this can be consolidated so that style settings occur only in one place, but
  for now the contents of this file consists first of the initial CSS work as
  provided to the RFC Formatter (xml2rfc) work, followed by itemized and
  commented changes found necessary during the development of the v3
  formatters.

*/

/* fonts */
@import url('https://fonts.googleapis.com/css?family=Noto+Sans'); /* Sans-serif */
@import url('https://fonts.googleapis.com/css?family=Noto+Serif'); /* Serif (print) */
@import url('https://fonts.googleapis.com/css?family=Roboto+Mono'); /* Monospace */

:root {
  --font-sans: 'Noto Sans', Arial, Helvetica, sans-serif;
  --font-serif: 'Noto Serif', 'Times', 'Times New Roman', serif;
  --font-mono: 'Roboto Mono', Courier, 'Courier New', monospace;
}

@viewport {
  zoom: 1.0;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}
/* general and mobile first */
html {
}
body {
  max-width: 90%;
  margin: 1.5em auto;
  color: #222;
  background-color: #fff;
  font-size: 14px;
  font-family: var(--font-sans);
  line-height: 1.6;
  scroll-behavior: smooth;
  overflow-wrap: break-word;
}
.ears {
  display: none;
}

/* headings */
#title, h1, h2, h3, h4, h5, h6 {
  margin: 1em 0 0.5em;
  font-weight: bold;
  line-height: 1.3;
}
#title {
  clear: both;
  border-bottom: 1px solid #ddd;
  margin: 0 0 0.5em 0;
  padding: 1em 0 0.5em;
}
.author {
  padding-bottom: 4px;
}
h1 {
  font-size: 26px;
  margin: 1em 0;
}
h2 {
  font-size: 22px;
  margin-top: -20px;  /* provide offset for in-page anchors */
  padding-top: 33px;
}
h3 {
  font-size: 18px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h4 {
  font-size: 16px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h5, h6 {
  font-size: 14px;
}
#n-copyright-notice {
  border-bottom: 1px solid #ddd;
  padding-bottom: 1em;
  margin-bottom: 1em;
}
/* general structure */
p {
  padding: 0;
  margin: 0 0 1em 0;
  text-align: left;
}
div, span {
  position: relative;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignRight.art-text pre {
  padding: 0;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
svg[font-family~="serif" i], svg [font-family~="serif" i] {
  font-family: var(--font-serif);
}
svg[font-family~="sans-serif" i], svg [font-family~="sans-serif" i] {
  font-family: var(--font-sans);
}
svg[font-family~="monospace" i], svg [font-family~="monospace" i] {
  font-family: var(--font-mono);
}
.alignCenter.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignCenter.art-text pre {
  padding: 0;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  display: table;
  border: none;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 1em 2em;
}
ol ol, ul ul, ol ul, ul ol {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
ul.ulBare, li.ulBare {
  margin-left: 0em !important;
}
ul.compact, .ulCompact,
ol.compact, .olCompact {
  line-height: 100%;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
}
dl > dt {
  float: left;
  margin-right: 1em;
}
/* 
dl.nohang > dt {
  float: none;
}
*/
dl > dd {
  margin-bottom: .8em;
  min-height: 1.3em;
}
dl.compact > dd, .dlCompact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}

/* links */
a {
  text-decoration: none;
}
a[href] {
  color: #22e; /* Arlen: WCAG 2019 */
}
a[href]:hover {
  background-color: #f2f2f2;
}
figcaption a[href],
a[href].selfRef {
  color: #222;
}
/* XXX probably not this:
a.selfRef:hover {
  background-color: transparent;
  cursor: default;
} */

/* Figures */
tt, code, pre {
  background-color: #f9f9f9;
  font-family: var(--font-mono);
}
pre {
  border: 1px solid #eee;
  margin: 0;
  padding: 1em;
}
img {
  max-width: 100%;
}
figure {
  margin: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption {
  font-style: italic;
  margin: 0 0 1em 0;
}
@media screen {
  pre {
    overflow-x: auto;
    max-width: 100%;
    max-width: calc(100% - 22px);
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 1.2em 2em;
}
blockquote {
  background-color: #f9f9f9;
  color: #111; /* Arlen: WCAG 2019 */
  border: 1px solid #ddd;
  border-radius: 3px;
  margin: 1em 0;
}
blockquote > *:last-child {
  margin-bottom: 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}
.xref {
  overflow-wrap: normal;
}

/* tables */
table {
  width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
  border: 1px solid #eee;
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 0.5em 0.75em;
}
th {
  text-align: left;
  background-color: #e9e9e9;
}
tr:nth-child(2n+1) > td {
  background-color: #f5f5f5;
}
table caption {
  font-style: italic;
  margin: 0;
  padding: 0;
  text-align: left;
}
table p {
  /* XXX to avoid bottom margin on table row signifiers. If paragraphs should
     be allowed within tables more generally, it would be far better to select on a class. */
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  color: #666; /* Arlen: AHDJ 2019 */
  text-decoration: none;
  visibility: hidden;
  user-select: none;
  -ms-user-select: none;
  -o-user-select:none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}
@media screen {
  aside:hover > a.pilcrow,
  p:hover > a.pilcrow,
  blockquote:hover > a.pilcrow,
  div:hover > a.pilcrow,
  li:hover > a.pilcrow,
  pre:hover > a.pilcrow {
    visibility: visible;
  }
  a.pilcrow:hover {
    background-color: transparent;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid #eee;
}
.bcp14 {
  font-variant: small-caps;
}

.role {
  font-variant: all-small-caps;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: 0.9em;
}
#identifiers dt {
  width: 3em;
  clear: left;
}
#identifiers dd {
  float: left;
  margin-bottom: 0;
}
/* Fix PDF info block run off issue */
@media print {
  #identifiers dd {
    max-width: 100%;
  }
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #666; /* Arlen: WCAG 2019 */
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc  {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
nav.toc ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
nav.toc li {
  line-height: 1.3em;
  margin: 0.75em 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 7em;
}
.references dd {
  margin-left: 8em;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.refSubseries {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
.index ul {
  margin: 0 0 0 1em;
  padding: 0;
  list-style: none;
}
.index ul ul {
  margin: 0;
}
.index li {
  margin: 0;
  text-indent: -2em;
  padding-left: 2em;
  padding-bottom: 5px;
}
.indexIndex {
  margin: 0.5em 0 1em;
}
.index a {
  font-weight: 700;
}
/* make the index two-column on all but the smallest screens */
@media (min-width: 600px) {
  .index ul {
    -moz-column-count: 2;
    -moz-column-gap: 20px;
  }
  .index ul ul {
    -moz-column-count: 1;
    -moz-column-gap: 0;
  }
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}

address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  font-family: var(--font-sans);
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}

/* temporary notes */
.rfcEditorRemove::before {
  position: absolute;
  top: 0.2em;
  right: 0.2em;
  padding: 0.2em;
  content: "The RFC Editor will remove this note";
  color: #9e2a00; /* Arlen: WCAG 2019 */
  background-color: #ffd; /* Arlen: WCAG 2019 */
}
.rfcEditorRemove {
  position: relative;
  padding-top: 1.8em;
  background-color: #ffd; /* Arlen: WCAG 2019 */
  border-radius: 3px;
}
.cref {
  background-color: #ffd; /* Arlen: WCAG 2019 */
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 1023px) {
  body {
    padding-top: 2em;
  }
  #title {
    padding: 1em 0;
  }
  h1 {
    font-size: 24px;
  }
  h2 {
    font-size: 20px;
    margin-top: -18px;  /* provide offset for in-page anchors */
    padding-top: 38px;
  }
  #identifiers dd {
    max-width: 60%;
  }
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 0;
    margin: 0;
    background-color: inherit;
    border-bottom: 1px solid #ccc;
  }
  #toc h2 {
    margin: -1px 0 0 0;
    padding: 4px 0 4px 6px;
    padding-right: 1em;
    min-width: 190px;
    font-size: 1.1em;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 6px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    padding: 0.5em 1em 1em;
    overflow: auto;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 1024px) {
  body {
    max-width: 724px;
    margin: 42px auto;
    padding-left: 1.5em;
    padding-right: 29em;
  }
  #toc {
    position: fixed;
    top: 42px;
    right: 42px;
    width: 25%;
    margin: 0;
    padding: 0 1em;
    z-index: 1;
  }
  #toc h2 {
    border-top: none;
    border-bottom: 1px solid #ddd;
    font-size: 1em;
    font-weight: normal;
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 0;
    overflow: auto;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {
    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre {
    page-break-inside: avoid;
  }
  figure {
    overflow: scroll;
  }
  .breakable pre {
    break-inside: auto;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  h2+*, h3+*, h4+*, h5+*, h6+* {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

/* This is commented out here, as the string-set: doesn't
   pass W3C validation currently */
/*
.ears thead .left {
  string-set: ears-top-left content();
}

.ears thead .center {
  string-set: ears-top-center content();
}

.ears thead .right {
  string-set: ears-top-right content();
}

.ears tfoot .left {
  string-set: ears-bottom-left content();
}

.ears tfoot .center {
  string-set: ears-bottom-center content();
}

.ears tfoot .right {
  string-set: ears-bottom-right content();
}
*/

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
  /* The following is commented out here, but set appropriately by in code, as
     the content depends on the document */
  /*
  @top-left {
    content: 'Internet-Draft';
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-left {
    content: string(ears-top-left);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-center {
    content: string(ears-top-center);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-right {
    content: string(ears-top-right);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @bottom-left {
    content: string(ears-bottom-left);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-center {
    content: string(ears-bottom-center);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-right {
      content: '[Page ' counter(page) ']';
      vertical-align: top;
      border-top: solid 1px #ccc;
  }
  */

}

/* Changes introduced to fix issues found during implementation */
/* Make sure links are clickable even if overlapped by following H* */
a {
  z-index: 2;
}
/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}


/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Leave room in document info to show Internet-Draft on one line */
#identifiers dt {
  width: 8em;
}

/* Don't waste quite as much whitespace between label and value in doc info */
#identifiers dd {
  margin-left: 1em;
}

/* Give floating toc a background color (needed when it's a div inside section */
#toc {
  background-color: white;
}

/* Make the collapsed ToC header render white on gray also when it's a link */
@media screen and (max-width: 1023px) {
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
}

/* Give the bottom of the ToC some whitespace */
@media screen and (min-width: 1024px) {
  #toc {
    padding: 0 0 1em 1em;
  }
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* prevent monospace from becoming overly large */
tt, code, pre {
  font-size: 95%;
}

/* Fix the height/width aspect for ascii art*/
.sourcecode pre,
.art-text pre {
  line-height: 1.12;
}


/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin-right: 0.5em;
}

/* Fix the dl styling to match the RFC 7992 attributes */
dl > dt,
dl.dlParallel > dt {
  float: left;
  margin-right: 1em;
}
dl.dlNewline > dt {
  float: none;
}

/* Provide styling for table cell text alignment */
table td.text-left,
table th.text-left {
  text-align: left;
}
table td.text-center,
table th.text-center {
  text-align: center;
}
table td.text-right,
table th.text-right {
  text-align: right;
}

/* Make the alternative author contact information look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 30em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Provide table alignment support.  We can't use the alignX classes above
   since they do unwanted things with caption and other styling. */
table.right {
 margin-left: auto;
 margin-right: 0;
}
table.center {
 margin-left: auto;
 margin-right: auto;
}
table.left {
 margin-left: 0;
 margin-right: auto;
}

/* Give the table caption label the same styling as the figcaption */
caption a[href] {
  color: #222;
}

@media print {
  .toplink {
    display: none;
  }

  /* avoid overwriting the top border line with the ToC header */
  #toc {
    padding-top: 1px;
  }

  /* Avoid page breaks inside dl and author address entries */
  .vcard {
    page-break-inside: avoid;
  }

}
/* Tweak the bcp14 keyword presentation */
.bcp14 {
  font-variant: small-caps;
  font-weight: bold;
  font-size: 0.9em;
}
/* Tweak the invisible space above H* in order not to overlay links in text above */
 h2 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 31px;
 }
 h3 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
 h4 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
/* Float artwork pilcrow to the right */
@media screen {
  .artwork a.pilcrow {
    display: block;
    line-height: 0.7;
    margin-top: 0.15em;
  }
}
/* Make pilcrows on dd visible */
@media screen {
  dd:hover > a.pilcrow {
    visibility: visible;
  }
}
/* Make the placement of figcaption match that of a table's caption
   by removing the figure's added bottom margin */
.alignLeft.art-text,
.alignCenter.art-text,
.alignRight.art-text {
   margin-bottom: 0;
}
.alignLeft,
.alignCenter,
.alignRight {
  margin: 1em 0 0 0;
}
/* In print, the pilcrow won't show on hover, so prevent it from taking up space,
   possibly even requiring a new line */
@media print {
  a.pilcrow {
    display: none;
  }
}
/* Styling for the external metadata */
div#external-metadata {
  background-color: #eee;
  padding: 0.5em;
  margin-bottom: 0.5em;
  display: none;
}
div#internal-metadata {
  padding: 0.5em;                       /* to match the external-metadata padding */
}
/* Styling for title RFC Number */
h1#rfcnum {
  clear: both;
  margin: 0 0 -1em;
  padding: 1em 0 0 0;
}
/* Make .olPercent look the same as <ol><li> */
dl.olPercent > dd {
  margin-bottom: 0.25em;
  min-height: initial;
}
/* Give aside some styling to set it apart */
aside {
  border-left: 1px solid #ddd;
  margin: 1em 0 1em 2em;
  padding: 0.2em 2em;
}
aside > dl,
aside > ol,
aside > ul,
aside > table,
aside > p {
  margin-bottom: 0.5em;
}
/* Additional page break settings */
@media print {
  figcaption, table caption {
    page-break-before: avoid;
  }
}
/* Font size adjustments for print */
@media print {
  body  { font-size: 10pt;      line-height: normal; max-width: 96%; }
  h1    { font-size: 1.72em;    padding-top: 1.5em; } /* 1*1.2*1.2*1.2 */
  h2    { font-size: 1.44em;    padding-top: 1.5em; } /* 1*1.2*1.2 */
  h3    { font-size: 1.2em;     padding-top: 1.5em; } /* 1*1.2 */
  h4    { font-size: 1em;       padding-top: 1.5em; }
  h5, h6 { font-size: 1em;      margin: initial; padding: 0.5em 0 0.3em; }
}
/* Sourcecode margin in print, when there's no pilcrow */
@media print {
  .artwork,
  .artwork > pre,
  .sourcecode {
    margin-bottom: 1em;
  }
}
/* Avoid narrow tables forcing too narrow table captions, which may render badly */
table {
  min-width: 20em;
}
/* ol type a */
ol.type-a { list-style-type: lower-alpha; }
ol.type-A { list-style-type: upper-alpha; }
ol.type-i { list-style-type: lower-roman; }
ol.type-I { list-style-type: upper-roman; }
/* Apply the print table and row borders in general, on request from the RPC,
and increase the contrast between border and odd row background slightly */
table {
  border: 1px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
}
tr {
  break-inside: avoid;
}
tr:nth-child(2n+1) > td {
  background-color: #f8f8f8;
}
/* Use style rules to govern display of the TOC. */
@media screen and (max-width: 1023px) {
  #toc nav { display: none; }
  #toc.active nav { display: block; }
}
/* Add support for keepWithNext */
.keepWithNext {
  break-after: avoid-page;
  break-after: avoid-page;
}
/* Add support for keepWithPrevious */
.keepWithPrevious {
  break-before: avoid-page;
}
/* Change the approach to avoiding breaks inside artwork etc. */
figure, pre, table, .artwork, .sourcecode  {
  break-before: auto;
  break-after: auto;
}
/* Avoid breaks between <dt> and <dd> */
dl {
  break-before: auto;
  break-inside: auto;
}
dt {
  break-before: auto;
  break-after: avoid-page;
}
dd {
  break-before: avoid-page;
  break-after: auto;
  orphans: 3;
  widows: 3
}
span.break, dd.break {
  margin-bottom: 0;
  min-height: 0;
  break-before: auto;
  break-inside: auto;
  break-after: auto;
}
/* Undo break-before ToC */
@media print {
  #toc {
    break-before: auto;
  }
}
/* Text in compact lists should not get extra bottom margin space,
   since that would makes the list not compact */
ul.compact p, .ulCompact p,
ol.compact p, .olCompact p {
 margin: 0;
}
/* But the list as a whole needs the extra space at the end */
section ul.compact,
section .ulCompact,
section ol.compact,
section .olCompact {
  margin-bottom: 1em;                    /* same as p not within ul.compact etc. */
}
/* The tt and code background above interferes with for instance table cell
   backgrounds.  Changed to something a bit more selective. */
tt, code {
  background-color: transparent;
}
p tt, p code, li tt, li code, dt tt, dt code {
  background-color: #f8f8f8;
}
/* Tweak the pre margin -- 0px doesn't come out well */
pre {
   margin-top: 0.5px;
}
/* Tweak the compact list text */
ul.compact, .ulCompact,
ol.compact, .olCompact,
dl.compact, .dlCompact {
  line-height: normal;
}
/* Don't add top margin for nested lists */
li > ul, li > ol, li > dl,
dd > ul, dd > ol, dd > dl,
dl > dd > dl {
  margin-top: initial;
}
/* Elements that should not be rendered on the same line as a <dt> */
/* This should match the element list in writer.text.TextWriter.render_dl() */
dd > div.artwork:first-child,
dd > aside:first-child,
dd > figure:first-child,
dd > ol:first-child,
dd > div.sourcecode:first-child,
dd > table:first-child,
dd > ul:first-child {
  clear: left;
}
/* fix for weird browser behaviour when <dd/> is empty */
dt+dd:empty::before{
  content: "\00a0";
}
/* Make paragraph spacing inside <li> smaller than in body text, to fit better within the list */
li > p {
  margin-bottom: 0.5em
}
/* Don't let p margin spill out from inside list items */
li > p:last-of-type:only-child {
  margin-bottom: 0;
}
</style>
<link href="rfc-local.css" rel="stylesheet" type="text/css">
<link href="https://datatracker.ietf.org/doc/draft-ietf-oauth-security-topics-29" rel="prev">
  <link href="https://dx.doi.org/10.17487/rfc9700" rel="alternate">
  <link href="urn:issn:2070-1721" rel="alternate">
  </head>
<body class="xml2rfc">
<script src="https://www.rfc-editor.org/js/metadata.min.js"></script>
<table class="ears">
<thead><tr>
<td class="left">RFC 9700</td>
<td class="center">OAuth 2.0 Security BCP</td>
<td class="right">January 2025</td>
</tr></thead>
<tfoot><tr>
<td class="left">Lodderstedt, et al.</td>
<td class="center">Best Current Practice</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-stream">Stream:</dt>
<dd class="stream">Internet Engineering Task Force (IETF)</dd>
<dt class="label-rfc">RFC:</dt>
<dd class="rfc"><a href="https://www.rfc-editor.org/rfc/rfc9700" class="eref">9700</a></dd>
<dt class="label-bcp">BCP:</dt>
<dd class="bcp">240</dd>
<dt class="label-updates">Updates:</dt>
<dd class="updates">
<a href="https://www.rfc-editor.org/rfc/rfc6749" class="eref">6749</a>, <a href="https://www.rfc-editor.org/rfc/rfc6750" class="eref">6750</a>, <a href="https://www.rfc-editor.org/rfc/rfc6819" class="eref">6819</a> </dd>
<dt class="label-category">Category:</dt>
<dd class="category">Best Current Practice</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2025-01" class="published">January 2025</time>
    </dd>
<dt class="label-issn">ISSN:</dt>
<dd class="issn">2070-1721</dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">T. Lodderstedt</div>
<div class="org">SPRIND</div>
</div>
<div class="author">
      <div class="author-name">J. Bradley</div>
<div class="org">Yubico</div>
</div>
<div class="author">
      <div class="author-name">A. Labunets</div>
<div class="org">Independent Researcher</div>
</div>
<div class="author">
      <div class="author-name">D. Fett</div>
<div class="org">Authlete</div>
</div>
</dd>
</dl>
</div>
<h1 id="rfcnum">RFC 9700</h1>
<h1 id="title">Best Current Practice for OAuth 2.0 Security</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">This document describes best current security practice for OAuth 2.0. It updates
and extends the threat model and security advice given in RFCs 6749, 6750, and 6819 to incorporate practical experiences gathered since
OAuth 2.0 was published and covers new threats relevant due to the broader
application of OAuth 2.0. Further, it deprecates some modes of operation that are
deemed less secure or even insecure.<a href="#section-abstract-1" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
            This memo documents an Internet Best Current Practice.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by
            the Internet Engineering Steering Group (IESG).  Further information
            on BCPs is available in Section 2 of RFC 7841.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <span><a href="https://www.rfc-editor.org/info/rfc9700">https://www.rfc-editor.org/info/rfc9700</a></span>.<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2025 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents">
<a href="#name-table-of-contents" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1" class="keepWithNext"><a href="#section-1" class="auto internal xref">1</a>.  <a href="#name-introduction" class="internal xref">Introduction</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.1">
                <p id="section-toc.1-1.1.2.1.1" class="keepWithNext"><a href="#section-1.1" class="auto internal xref">1.1</a>.  <a href="#name-structure" class="internal xref">Structure</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.2">
                <p id="section-toc.1-1.1.2.2.1" class="keepWithNext"><a href="#section-1.2" class="auto internal xref">1.2</a>.  <a href="#name-conventions-and-terminology" class="internal xref">Conventions and Terminology</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1"><a href="#section-2" class="auto internal xref">2</a>.  <a href="#name-best-practices" class="internal xref">Best Practices</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.1">
                <p id="section-toc.1-1.2.2.1.1"><a href="#section-2.1" class="auto internal xref">2.1</a>.  <a href="#name-protecting-redirect-based-f" class="internal xref">Protecting Redirect-Based Flows</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.1.2.1">
                    <p id="section-toc.1-1.2.2.1.2.1.1"><a href="#section-2.1.1" class="auto internal xref">2.1.1</a>.  <a href="#name-authorization-code-grant" class="internal xref">Authorization Code Grant</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.1.2.2">
                    <p id="section-toc.1-1.2.2.1.2.2.1"><a href="#section-2.1.2" class="auto internal xref">2.1.2</a>.  <a href="#name-implicit-grant" class="internal xref">Implicit Grant</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.2">
                <p id="section-toc.1-1.2.2.2.1"><a href="#section-2.2" class="auto internal xref">2.2</a>.  <a href="#name-token-replay-prevention" class="internal xref">Token Replay Prevention</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.2.2.1">
                    <p id="section-toc.1-1.2.2.2.2.1.1"><a href="#section-2.2.1" class="auto internal xref">2.2.1</a>.  <a href="#name-access-tokens" class="internal xref">Access Tokens</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.2.2.2">
                    <p id="section-toc.1-1.2.2.2.2.2.1"><a href="#section-2.2.2" class="auto internal xref">2.2.2</a>.  <a href="#name-refresh-tokens" class="internal xref">Refresh Tokens</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.3">
                <p id="section-toc.1-1.2.2.3.1"><a href="#section-2.3" class="auto internal xref">2.3</a>.  <a href="#name-access-token-privilege-rest" class="internal xref">Access Token Privilege Restriction</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.4">
                <p id="section-toc.1-1.2.2.4.1"><a href="#section-2.4" class="auto internal xref">2.4</a>.  <a href="#name-resource-owner-password-cre" class="internal xref">Resource Owner Password Credentials Grant</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.5">
                <p id="section-toc.1-1.2.2.5.1"><a href="#section-2.5" class="auto internal xref">2.5</a>.  <a href="#name-client-authentication" class="internal xref">Client Authentication</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.6">
                <p id="section-toc.1-1.2.2.6.1"><a href="#section-2.6" class="auto internal xref">2.6</a>.  <a href="#name-other-recommendations" class="internal xref">Other Recommendations</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a href="#section-3" class="auto internal xref">3</a>.  <a href="#name-the-updated-oauth-20-attack" class="internal xref">The Updated OAuth 2.0 Attacker Model</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="auto internal xref">4</a>.  <a href="#name-attacks-and-mitigations" class="internal xref">Attacks and Mitigations</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1">
                <p id="section-toc.1-1.4.2.1.1"><a href="#section-4.1" class="auto internal xref">4.1</a>.  <a href="#name-insufficient-redirection-ur" class="internal xref">Insufficient Redirection URI Validation</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1.2.1">
                    <p id="section-toc.1-1.4.2.1.2.1.1"><a href="#section-4.1.1" class="auto internal xref">4.1.1</a>.  <a href="#name-redirect-uri-validation-att" class="internal xref">Redirect URI Validation Attacks on Authorization Code Grant</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1.2.2">
                    <p id="section-toc.1-1.4.2.1.2.2.1"><a href="#section-4.1.2" class="auto internal xref">4.1.2</a>.  <a href="#name-redirect-uri-validation-atta" class="internal xref">Redirect URI Validation Attacks on Implicit Grant</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1.2.3">
                    <p id="section-toc.1-1.4.2.1.2.3.1"><a href="#section-4.1.3" class="auto internal xref">4.1.3</a>.  <a href="#name-countermeasures" class="internal xref">Countermeasures</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2">
                <p id="section-toc.1-1.4.2.2.1"><a href="#section-4.2" class="auto internal xref">4.2</a>.  <a href="#name-credential-leakage-via-refe" class="internal xref">Credential Leakage via Referer Headers</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.1">
                    <p id="section-toc.1-1.4.2.2.2.1.1"><a href="#section-4.2.1" class="auto internal xref">4.2.1</a>.  <a href="#name-leakage-from-the-oauth-clie" class="internal xref">Leakage from the OAuth Client</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.2">
                    <p id="section-toc.1-1.4.2.2.2.2.1"><a href="#section-4.2.2" class="auto internal xref">4.2.2</a>.  <a href="#name-leakage-from-the-authorizat" class="internal xref">Leakage from the Authorization Server</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.3">
                    <p id="section-toc.1-1.4.2.2.2.3.1"><a href="#section-4.2.3" class="auto internal xref">4.2.3</a>.  <a href="#name-consequences" class="internal xref">Consequences</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.4">
                    <p id="section-toc.1-1.4.2.2.2.4.1"><a href="#section-4.2.4" class="auto internal xref">4.2.4</a>.  <a href="#name-countermeasures-2" class="internal xref">Countermeasures</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3">
                <p id="section-toc.1-1.4.2.3.1"><a href="#section-4.3" class="auto internal xref">4.3</a>.  <a href="#name-credential-leakage-via-brow" class="internal xref">Credential Leakage via Browser History</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3.2.1">
                    <p id="section-toc.1-1.4.2.3.2.1.1"><a href="#section-4.3.1" class="auto internal xref">4.3.1</a>.  <a href="#name-authorization-code-in-brows" class="internal xref">Authorization Code in Browser History</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3.2.2">
                    <p id="section-toc.1-1.4.2.3.2.2.1"><a href="#section-4.3.2" class="auto internal xref">4.3.2</a>.  <a href="#name-access-token-in-browser-his" class="internal xref">Access Token in Browser History</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.4">
                <p id="section-toc.1-1.4.2.4.1"><a href="#section-4.4" class="auto internal xref">4.4</a>.  <a href="#name-mix-up-attacks" class="internal xref">Mix-Up Attacks</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.4.2.1">
                    <p id="section-toc.1-1.4.2.4.2.1.1"><a href="#section-4.4.1" class="auto internal xref">4.4.1</a>.  <a href="#name-attack-description" class="internal xref">Attack Description</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.4.2.2">
                    <p id="section-toc.1-1.4.2.4.2.2.1"><a href="#section-4.4.2" class="auto internal xref">4.4.2</a>.  <a href="#name-countermeasures-3" class="internal xref">Countermeasures</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.4.2.2.2.1">
                        <p id="section-toc.1-1.4.2.4.2.2.2.1.1"><a href="#section-4.4.2.1" class="auto internal xref">4.4.2.1</a>.  <a href="#name-mix-up-defense-via-issuer-i" class="internal xref">Mix-Up Defense via Issuer Identification</a></p>
</li>
                      <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.4.2.2.2.2">
                        <p id="section-toc.1-1.4.2.4.2.2.2.2.1"><a href="#section-4.4.2.2" class="auto internal xref">4.4.2.2</a>.  <a href="#name-mix-up-defense-via-distinct" class="internal xref">Mix-Up Defense via Distinct Redirect URIs</a></p>
</li>
                    </ul>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.5">
                <p id="section-toc.1-1.4.2.5.1"><a href="#section-4.5" class="auto internal xref">4.5</a>.  <a href="#name-authorization-code-injectio" class="internal xref">Authorization Code Injection</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.5.2.1">
                    <p id="section-toc.1-1.4.2.5.2.1.1"><a href="#section-4.5.1" class="auto internal xref">4.5.1</a>.  <a href="#name-attack-description-2" class="internal xref">Attack Description</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.5.2.2">
                    <p id="section-toc.1-1.4.2.5.2.2.1"><a href="#section-4.5.2" class="auto internal xref">4.5.2</a>.  <a href="#name-discussion" class="internal xref">Discussion</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.5.2.3">
                    <p id="section-toc.1-1.4.2.5.2.3.1"><a href="#section-4.5.3" class="auto internal xref">4.5.3</a>.  <a href="#name-countermeasures-4" class="internal xref">Countermeasures</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.5.2.3.2.1">
                        <p id="section-toc.1-1.4.2.5.2.3.2.1.1"><a href="#section-4.5.3.1" class="auto internal xref">4.5.3.1</a>.  <a href="#name-pkce" class="internal xref">PKCE</a></p>
</li>
                      <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.5.2.3.2.2">
                        <p id="section-toc.1-1.4.2.5.2.3.2.2.1"><a href="#section-4.5.3.2" class="auto internal xref">4.5.3.2</a>.  <a href="#name-nonce" class="internal xref">Nonce</a></p>
</li>
                      <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.5.2.3.2.3">
                        <p id="section-toc.1-1.4.2.5.2.3.2.3.1"><a href="#section-4.5.3.3" class="auto internal xref">4.5.3.3</a>.  <a href="#name-other-solutions" class="internal xref">Other Solutions</a></p>
</li>
                    </ul>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.5.2.4">
                    <p id="section-toc.1-1.4.2.5.2.4.1"><a href="#section-4.5.4" class="auto internal xref">4.5.4</a>.  <a href="#name-limitations" class="internal xref">Limitations</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.6">
                <p id="section-toc.1-1.4.2.6.1"><a href="#section-4.6" class="auto internal xref">4.6</a>.  <a href="#name-access-token-injection" class="internal xref">Access Token Injection</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.6.2.1">
                    <p id="section-toc.1-1.4.2.6.2.1.1"><a href="#section-4.6.1" class="auto internal xref">4.6.1</a>.  <a href="#name-countermeasures-5" class="internal xref">Countermeasures</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.7">
                <p id="section-toc.1-1.4.2.7.1"><a href="#section-4.7" class="auto internal xref">4.7</a>.  <a href="#name-cross-site-request-forgery" class="internal xref">Cross-Site Request Forgery</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.7.2.1">
                    <p id="section-toc.1-1.4.2.7.2.1.1"><a href="#section-4.7.1" class="auto internal xref">4.7.1</a>.  <a href="#name-countermeasures-6" class="internal xref">Countermeasures</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.8">
                <p id="section-toc.1-1.4.2.8.1"><a href="#section-4.8" class="auto internal xref">4.8</a>.  <a href="#name-pkce-downgrade-attack" class="internal xref">PKCE Downgrade Attack</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.8.2.1">
                    <p id="section-toc.1-1.4.2.8.2.1.1"><a href="#section-4.8.1" class="auto internal xref">4.8.1</a>.  <a href="#name-attack-description-3" class="internal xref">Attack Description</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.8.2.2">
                    <p id="section-toc.1-1.4.2.8.2.2.1"><a href="#section-4.8.2" class="auto internal xref">4.8.2</a>.  <a href="#name-countermeasures-7" class="internal xref">Countermeasures</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.9">
                <p id="section-toc.1-1.4.2.9.1"><a href="#section-4.9" class="auto internal xref">4.9</a>.  <a href="#name-access-token-leakage-at-the" class="internal xref">Access Token Leakage at the Resource Server</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.9.2.1">
                    <p id="section-toc.1-1.4.2.9.2.1.1"><a href="#section-4.9.1" class="auto internal xref">4.9.1</a>.  <a href="#name-access-token-phishing-by-co" class="internal xref">Access Token Phishing by Counterfeit Resource Server</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.9.2.2">
                    <p id="section-toc.1-1.4.2.9.2.2.1"><a href="#section-4.9.2" class="auto internal xref">4.9.2</a>.  <a href="#name-compromised-resource-server" class="internal xref">Compromised Resource Server</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.9.2.3">
                    <p id="section-toc.1-1.4.2.9.2.3.1"><a href="#section-4.9.3" class="auto internal xref">4.9.3</a>.  <a href="#name-countermeasures-8" class="internal xref">Countermeasures</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.10">
                <p id="section-toc.1-1.4.2.10.1"><a href="#section-4.10" class="auto internal xref">4.10</a>. <a href="#name-misuse-of-stolen-access-tok" class="internal xref">Misuse of Stolen Access Tokens</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.10.2.1">
                    <p id="section-toc.1-1.4.2.10.2.1.1"><a href="#section-4.10.1" class="auto internal xref">4.10.1</a>.  <a href="#name-sender-constrained-access-t" class="internal xref">Sender-Constrained Access Tokens</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.10.2.2">
                    <p id="section-toc.1-1.4.2.10.2.2.1"><a href="#section-4.10.2" class="auto internal xref">4.10.2</a>.  <a href="#name-audience-restricted-access-" class="internal xref">Audience-Restricted Access Tokens</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.10.2.3">
                    <p id="section-toc.1-1.4.2.10.2.3.1"><a href="#section-4.10.3" class="auto internal xref">4.10.3</a>.  <a href="#name-discussion-preventing-leaka" class="internal xref">Discussion: Preventing Leakage via Metadata</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.11">
                <p id="section-toc.1-1.4.2.11.1"><a href="#section-4.11" class="auto internal xref">4.11</a>. <a href="#name-open-redirection" class="internal xref">Open Redirection</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.11.2.1">
                    <p id="section-toc.1-1.4.2.11.2.1.1"><a href="#section-4.11.1" class="auto internal xref">4.11.1</a>.  <a href="#name-client-as-open-redirector" class="internal xref">Client as Open Redirector</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.11.2.2">
                    <p id="section-toc.1-1.4.2.11.2.2.1"><a href="#section-4.11.2" class="auto internal xref">4.11.2</a>.  <a href="#name-authorization-server-as-ope" class="internal xref">Authorization Server as Open Redirector</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.12">
                <p id="section-toc.1-1.4.2.12.1"><a href="#section-4.12" class="auto internal xref">4.12</a>. <a href="#name-307-redirect" class="internal xref">307 Redirect</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.13">
                <p id="section-toc.1-1.4.2.13.1"><a href="#section-4.13" class="auto internal xref">4.13</a>. <a href="#name-tls-terminating-reverse-pro" class="internal xref">TLS Terminating Reverse Proxies</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.14">
                <p id="section-toc.1-1.4.2.14.1"><a href="#section-4.14" class="auto internal xref">4.14</a>. <a href="#name-refresh-token-protection" class="internal xref">Refresh Token Protection</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.14.2.1">
                    <p id="section-toc.1-1.4.2.14.2.1.1"><a href="#section-4.14.1" class="auto internal xref">4.14.1</a>.  <a href="#name-discussion-2" class="internal xref">Discussion</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.14.2.2">
                    <p id="section-toc.1-1.4.2.14.2.2.1"><a href="#section-4.14.2" class="auto internal xref">4.14.2</a>.  <a href="#name-recommendations" class="internal xref">Recommendations</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.15">
                <p id="section-toc.1-1.4.2.15.1"><a href="#section-4.15" class="auto internal xref">4.15</a>. <a href="#name-client-impersonating-resour" class="internal xref">Client Impersonating Resource Owner</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.15.2.1">
                    <p id="section-toc.1-1.4.2.15.2.1.1"><a href="#section-4.15.1" class="auto internal xref">4.15.1</a>.  <a href="#name-countermeasures-9" class="internal xref">Countermeasures</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.16">
                <p id="section-toc.1-1.4.2.16.1"><a href="#section-4.16" class="auto internal xref">4.16</a>. <a href="#name-clickjacking" class="internal xref">Clickjacking</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.17">
                <p id="section-toc.1-1.4.2.17.1"><a href="#section-4.17" class="auto internal xref">4.17</a>. <a href="#name-attacks-on-in-browser-commu" class="internal xref">Attacks on In-Browser Communication Flows</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.17.2.1">
                    <p id="section-toc.1-1.4.2.17.2.1.1"><a href="#section-4.17.1" class="auto internal xref">4.17.1</a>.  <a href="#name-examples" class="internal xref">Examples</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.17.2.1.2.1">
                        <p id="section-toc.1-1.4.2.17.2.1.2.1.1"><a href="#section-4.17.1.1" class="auto internal xref">4.17.1.1</a>.  <a href="#name-insufficient-limitation-of-" class="internal xref">Insufficient Limitation of Receiver Origins</a></p>
</li>
                      <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.17.2.1.2.2">
                        <p id="section-toc.1-1.4.2.17.2.1.2.2.1"><a href="#section-4.17.1.2" class="auto internal xref">4.17.1.2</a>.  <a href="#name-insufficient-uri-validation" class="internal xref">Insufficient URI Validation</a></p>
</li>
                      <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.17.2.1.2.3">
                        <p id="section-toc.1-1.4.2.17.2.1.2.3.1"><a href="#section-4.17.1.3" class="auto internal xref">4.17.1.3</a>.  <a href="#name-injection-after-insufficien" class="internal xref">Injection after Insufficient Validation of Sender Origin</a></p>
</li>
                    </ul>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.17.2.2">
                    <p id="section-toc.1-1.4.2.17.2.2.1"><a href="#section-4.17.2" class="auto internal xref">4.17.2</a>.  <a href="#name-recommendations-2" class="internal xref">Recommendations</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="auto internal xref">5</a>.  <a href="#name-iana-considerations" class="internal xref">IANA Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="auto internal xref">6</a>.  <a href="#name-security-considerations" class="internal xref">Security Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="auto internal xref">7</a>.  <a href="#name-references" class="internal xref">References</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.1">
                <p id="section-toc.1-1.7.2.1.1"><a href="#section-7.1" class="auto internal xref">7.1</a>.  <a href="#name-normative-references" class="internal xref">Normative References</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2">
                <p id="section-toc.1-1.7.2.2.1"><a href="#section-7.2" class="auto internal xref">7.2</a>.  <a href="#name-informative-references" class="internal xref">Informative References</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#appendix-A" class="auto internal xref"></a><a href="#name-acknowledgements" class="internal xref">Acknowledgements</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#appendix-B" class="auto internal xref"></a><a href="#name-authors-addresses" class="internal xref">Authors' Addresses</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<div id="Introduction">
<section id="section-1">
      <h2 id="name-introduction">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">Since its publication in <span>[<a href="#RFC6749" class="cite xref">RFC6749</a>]</span> and <span>[<a href="#RFC6750" class="cite xref">RFC6750</a>]</span>, OAuth 2.0 (referred to as simply "OAuth" in this document) has gained massive traction in the market
and became the standard for API protection and the basis for federated
login using OpenID Connect <span>[<a href="#OpenID.Core" class="cite xref">OpenID.Core</a>]</span>. While OAuth is used in a
variety of scenarios and different kinds of deployments, the following
challenges can be observed:<a href="#section-1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1-2.1">
          <p id="section-1-2.1.1">OAuth implementations are being attacked through known implementation
  weaknesses and anti-patterns (i.e., well-known patterns that are considered
insecure). Although most of these threats are discussed in the OAuth 2.0
  Threat Model and Security Considerations <span>[<a href="#RFC6819" class="cite xref">RFC6819</a>]</span>, continued exploitation
 demonstrates a need for more specific recommendations, easier to implement
  mitigations, and more defense in depth.<a href="#section-1-2.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-1-2.2">
          <p id="section-1-2.2.1">OAuth is being used in environments with higher security requirements than
considered initially, such as open banking, eHealth, eGovernment, and
electronic signatures. Those use cases call for stricter guidelines and
additional protection.<a href="#section-1-2.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-1-2.3">
          <p id="section-1-2.3.1">OAuth is being used in much more dynamic setups than originally anticipated,
  creating new challenges with respect to security. Those challenges go beyond
  the original scope of <span>[<a href="#RFC6749" class="cite xref">RFC6749</a>]</span>, <span>[<a href="#RFC6750" class="cite xref">RFC6750</a>]</span>, and <span>[<a href="#RFC6819" class="cite xref">RFC6819</a>]</span>.<a href="#section-1-2.3.1" class="pilcrow">¶</a></p>
<p id="section-1-2.3.2">OAuth initially assumed static relationships between clients,
authorization servers, and resource servers. The URLs of the servers were
known to the client at deployment time and built an anchor for the
trust relationships among those parties. The validation of whether the
client is talking to a legitimate server was based on TLS server
authentication (see <span><a href="https://rfc-editor.org/rfc/rfc6819#section-4.5.4" class="relref">Section 4.5.4</a> of [<a href="#RFC6819" class="cite xref">RFC6819</a>]</span>). With the increasing
adoption of OAuth, this simple model dissolved and, in several
scenarios, was replaced by a dynamic establishment of the relationship
between clients on one side and the authorization and resource servers
of a particular deployment on the other side. This way, the same
client could be used to access services of different providers (in
case of standard APIs, such as email or OpenID Connect) or serve as a
front end to a particular tenant in a multi-tenant environment.
Extensions of OAuth, such as the OAuth 2.0 Dynamic Client Registration
Protocol <span>[<a href="#RFC7591" class="cite xref">RFC7591</a>]</span> and OAuth 2.0 Authorization Server Metadata
<span>[<a href="#RFC8414" class="cite xref">RFC8414</a>]</span> were developed to support the use of OAuth in
dynamic scenarios.<a href="#section-1-2.3.2" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-1-2.4">
          <p id="section-1-2.4.1">Technology has changed. For example, the way browsers treat fragments when
  redirecting requests has changed, and with it, the implicit grant's
  underlying security model.<a href="#section-1-2.4.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-1-3">This document provides updated security recommendations to address these
challenges. It introduces new requirements beyond those defined in existing
specifications such as OAuth 2.0 <span>[<a href="#RFC6749" class="cite xref">RFC6749</a>]</span> and OpenID Connect <span>[<a href="#OpenID.Core" class="cite xref">OpenID.Core</a>]</span>
and deprecates some modes of operation that are deemed less secure or even
insecure. However, this document does not supplant the security advice given in
<span>[<a href="#RFC6749" class="cite xref">RFC6749</a>]</span>, <span>[<a href="#RFC6750" class="cite xref">RFC6750</a>]</span>, and <span>[<a href="#RFC6819" class="cite xref">RFC6819</a>]</span>, but complements those documents.<a href="#section-1-3" class="pilcrow">¶</a></p>
<p id="section-1-4">Naturally, not all existing ecosystems and implementations are
compatible with the new requirements, and following the best practices described in
this document may break interoperability. Nonetheless, it is <span class="bcp14">RECOMMENDED</span> that
implementers upgrade their implementations and ecosystems as soon as feasible.<a href="#section-1-4" class="pilcrow">¶</a></p>
<p id="section-1-5">OAuth 2.1, under development as <span>[<a href="#I-D.ietf-oauth-v2-1" class="cite xref">OAUTH-V2.1</a>]</span>, will incorporate
security recommendations from this document.<a href="#section-1-5" class="pilcrow">¶</a></p>
<div id="structure">
<section id="section-1.1">
        <h3 id="name-structure">
<a href="#section-1.1" class="section-number selfRef">1.1. </a><a href="#name-structure" class="section-name selfRef">Structure</a>
        </h3>
<p id="section-1.1-1">The remainder of this document is organized as follows: <a href="#recommendations" class="auto internal xref">Section 2</a>
summarizes the most important best practices for every OAuth implementer.
<a href="#secmodel" class="auto internal xref">Section 3</a> presents the updated OAuth attacker model. <a href="#attacks_and_mitigations" class="auto internal xref">Section 4</a> is a
detailed analysis of the threats and implementation issues that can be found in
the wild (at the time of writing) along with a discussion of potential countermeasures.<a href="#section-1.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="conventions-and-terminology">
<section id="section-1.2">
        <h3 id="name-conventions-and-terminology">
<a href="#section-1.2" class="section-number selfRef">1.2. </a><a href="#name-conventions-and-terminology" class="section-name selfRef">Conventions and Terminology</a>
        </h3>
<p id="section-1.2-1">
    The key words "<span class="bcp14">MUST</span>", "<span class="bcp14">MUST NOT</span>",
    "<span class="bcp14">REQUIRED</span>", "<span class="bcp14">SHALL</span>", "<span class="bcp14">SHALL NOT</span>",
    "<span class="bcp14">SHOULD</span>", "<span class="bcp14">SHOULD NOT</span>",
    "<span class="bcp14">RECOMMENDED</span>", "<span class="bcp14">NOT RECOMMENDED</span>",
    "<span class="bcp14">MAY</span>", and "<span class="bcp14">OPTIONAL</span>" in this document are to be
    interpreted as described in BCP 14 <span>[<a href="#RFC2119" class="cite xref">RFC2119</a>]</span> <span>[<a href="#RFC8174" class="cite xref">RFC8174</a>]</span> when, and only when, they appear in all capitals, as
    shown here.<a href="#section-1.2-1" class="pilcrow">¶</a></p>
<p id="section-1.2-2">This specification uses the terms "access token", "authorization
endpoint", "authorization grant", "authorization server", "client",
"client identifier" (client ID), "protected resource", "refresh
token", "resource owner", "resource server", and "token endpoint"
defined by OAuth 2.0 <span>[<a href="#RFC6749" class="cite xref">RFC6749</a>]</span>.<a href="#section-1.2-2" class="pilcrow">¶</a></p>
<p id="section-1.2-3">An "open redirector" is an endpoint on a web server that forwards a user's
browser to an arbitrary URI obtained from a query parameter.<a href="#section-1.2-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="recommendations">
<section id="section-2">
      <h2 id="name-best-practices">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-best-practices" class="section-name selfRef">Best Practices</a>
      </h2>
<p id="section-2-1">This section describes the core set of security mechanisms and measures that
are considered to be best practices at the time of writing. Details
about these security mechanisms and measures (including detailed attack
descriptions) and requirements for less commonly used options are provided in
<a href="#attacks_and_mitigations" class="auto internal xref">Section 4</a>.<a href="#section-2-1" class="pilcrow">¶</a></p>
<div id="rec_redirect">
<section id="section-2.1">
        <h3 id="name-protecting-redirect-based-f">
<a href="#section-2.1" class="section-number selfRef">2.1. </a><a href="#name-protecting-redirect-based-f" class="section-name selfRef">Protecting Redirect-Based Flows</a>
        </h3>
<p id="section-2.1-1">When comparing client redirection URIs against pre-registered URIs, authorization
servers <span class="bcp14">MUST</span> utilize exact string matching except for port numbers in
<code>localhost</code> redirection URIs of native apps (see <a href="#iuv_countermeasures" class="auto internal xref">Section 4.1.3</a>). This
measure contributes to the prevention of leakage of authorization codes and
access tokens (see <a href="#insufficient_uri_validation" class="auto internal xref">Section 4.1</a>). It can also help to detect
mix-up attacks (see <a href="#mix_up" class="auto internal xref">Section 4.4</a>).<a href="#section-2.1-1" class="pilcrow">¶</a></p>
<p id="section-2.1-2">Clients and authorization servers <span class="bcp14">MUST NOT</span> expose URLs that forward the user's browser to
arbitrary URIs obtained from a query parameter (open redirectors) as
described in <a href="#open_redirection" class="auto internal xref">Section 4.11</a>. Open redirectors can enable
exfiltration of authorization codes and access tokens.<a href="#section-2.1-2" class="pilcrow">¶</a></p>
<p id="section-2.1-3">Clients <span class="bcp14">MUST</span> prevent Cross-Site Request Forgery (CSRF). In this
context, CSRF refers to requests to the redirection endpoint that do
not originate at the authorization server, but at a malicious third party
(see <span><a href="https://rfc-editor.org/rfc/rfc6819#section-4.4.1.8" class="relref">Section 4.4.1.8</a> of [<a href="#RFC6819" class="cite xref">RFC6819</a>]</span> for details). Clients that have
ensured that the authorization server supports Proof Key for Code Exchange (PKCE) <span>[<a href="#RFC7636" class="cite xref">RFC7636</a>]</span> <span class="bcp14">MAY</span>
rely on the CSRF protection provided by PKCE. In OpenID Connect flows,
the <code>nonce</code> parameter provides CSRF protection. Otherwise, one-time
use CSRF tokens carried in the <code>state</code> parameter that are securely
bound to the user agent <span class="bcp14">MUST</span> be used for CSRF protection (see
<a href="#csrf_countermeasures" class="auto internal xref">Section 4.7.1</a>).<a href="#section-2.1-3" class="pilcrow">¶</a></p>
<p id="section-2.1-4">When an OAuth client can interact with more than one authorization server, a
defense against mix-up attacks (see <a href="#mix_up" class="auto internal xref">Section 4.4</a>) is <span class="bcp14">REQUIRED</span>. To this end, clients
<span class="bcp14">SHOULD</span><a href="#section-2.1-4" class="pilcrow">¶</a></p>
<ul class="compact">
<li class="compact" id="section-2.1-5.1">use the <code>iss</code> parameter as a countermeasure according to
<span>[<a href="#RFC9207" class="cite xref">RFC9207</a>]</span>, or<a href="#section-2.1-5.1" class="pilcrow">¶</a>
</li>
          <li class="compact" id="section-2.1-5.2">use an alternative countermeasure based on an <code>iss</code> value in the
authorization response (such as the <code>iss</code> claim in the ID Token in
<span>[<a href="#OpenID.Core" class="cite xref">OpenID.Core</a>]</span> or in <span>[<a href="#OpenID.JARM" class="cite xref">OpenID.JARM</a>]</span> responses), processing that value as described in
<span>[<a href="#RFC9207" class="cite xref">RFC9207</a>]</span>.<a href="#section-2.1-5.2" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-2.1-6">In the absence of these options, clients <span class="bcp14">MAY</span> instead use distinct redirection URIs
to identify authorization endpoints and token endpoints, as described in
<a href="#mixupcountermeasures" class="auto internal xref">Section 4.4.2</a>.<a href="#section-2.1-6" class="pilcrow">¶</a></p>
<p id="section-2.1-7">An authorization server that redirects a request potentially containing user credentials
<span class="bcp14">MUST</span> avoid forwarding these user credentials accidentally (see
<a href="#redirect_307" class="auto internal xref">Section 4.12</a> for details).<a href="#section-2.1-7" class="pilcrow">¶</a></p>
<div id="ac">
<section id="section-2.1.1">
          <h4 id="name-authorization-code-grant">
<a href="#section-2.1.1" class="section-number selfRef">2.1.1. </a><a href="#name-authorization-code-grant" class="section-name selfRef">Authorization Code Grant</a>
          </h4>
<p id="section-2.1.1-1">Clients <span class="bcp14">MUST</span> prevent authorization code
injection attacks (see <a href="#code_injection" class="auto internal xref">Section 4.5</a>) and misuse of authorization codes using one of the following options:<a href="#section-2.1.1-1" class="pilcrow">¶</a></p>
<ul class="compact">
<li class="compact" id="section-2.1.1-2.1">Public clients <span class="bcp14">MUST</span> use PKCE <span>[<a href="#RFC7636" class="cite xref">RFC7636</a>]</span> to this end, as motivated in
<a href="#pkce_as_injection_protection" class="auto internal xref">Section 4.5.3.1</a>.<a href="#section-2.1.1-2.1" class="pilcrow">¶</a>
</li>
            <li class="compact" id="section-2.1.1-2.2">For confidential clients, the use of PKCE <span>[<a href="#RFC7636" class="cite xref">RFC7636</a>]</span> is <span class="bcp14">RECOMMENDED</span>, as it
provides strong protection against misuse and injection of authorization
codes as described in <a href="#pkce_as_injection_protection" class="auto internal xref">Section 4.5.3.1</a>. Also, as a side effect,
it prevents CSRF even in the presence of strong attackers as described in
<a href="#csrf_countermeasures" class="auto internal xref">Section 4.7.1</a>.<a href="#section-2.1.1-2.2" class="pilcrow">¶</a>
</li>
            <li class="compact" id="section-2.1.1-2.3">With additional precautions, described in <a href="#nonce_as_injection_protection" class="auto internal xref">Section 4.5.3.2</a>,
confidential OpenID Connect <span>[<a href="#OpenID.Core" class="cite xref">OpenID.Core</a>]</span> clients <span class="bcp14">MAY</span> use the <code>nonce</code> parameter and the
respective Claim in the ID Token instead.<a href="#section-2.1.1-2.3" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-2.1.1-3">In any case, the PKCE challenge or OpenID Connect <code>nonce</code> <span class="bcp14">MUST</span> be
transaction-specific and securely bound to the client and the user agent in
which the transaction was started.
Authorization servers are encouraged to make a reasonable effort at detecting and
preventing the use of constant values for the PKCE challenge or OpenID Connect <code>nonce</code>.<a href="#section-2.1.1-3" class="pilcrow">¶</a></p>
<p id="section-2.1.1-4">Note: Although PKCE was designed as a mechanism to protect native
apps, this advice applies to all kinds of OAuth clients, including web
applications.<a href="#section-2.1.1-4" class="pilcrow">¶</a></p>
<p id="section-2.1.1-5">When using PKCE, clients <span class="bcp14">SHOULD</span> use PKCE code challenge methods that
do not expose the PKCE verifier in the authorization request.
Otherwise, attackers that can read the authorization request (cf. Attacker <a href="#read_request" class="internal xref">(A4)</a> in <a href="#secmodel" class="auto internal xref">Section 3</a>) can break the security provided
by PKCE. Currently, <code>S256</code> is the only such method.<a href="#section-2.1.1-5" class="pilcrow">¶</a></p>
<p id="section-2.1.1-6">Authorization servers <span class="bcp14">MUST</span> support PKCE <span>[<a href="#RFC7636" class="cite xref">RFC7636</a>]</span>.<a href="#section-2.1.1-6" class="pilcrow">¶</a></p>
<p id="section-2.1.1-7">If a client sends a valid PKCE <code>code_challenge</code> parameter in the
authorization request, the authorization server <span class="bcp14">MUST</span> enforce the correct usage
of <code>code_verifier</code> at the token endpoint.<a href="#section-2.1.1-7" class="pilcrow">¶</a></p>
<p id="section-2.1.1-8">Authorization servers <span class="bcp14">MUST</span> mitigate PKCE downgrade attacks by ensuring that a
token request containing a <code>code_verifier</code> parameter is accepted only if a
<code>code_challenge</code> parameter was present in the authorization request; see
<a href="#pkce_downgrade_countermeasures" class="auto internal xref">Section 4.8.2</a> for details.<a href="#section-2.1.1-8" class="pilcrow">¶</a></p>
<p id="section-2.1.1-9">Authorization servers <span class="bcp14">MUST</span> provide a way to detect their support for
PKCE. It is <span class="bcp14">RECOMMENDED</span> for authorization servers to publish the element
<code>code_challenge_methods_supported</code> in their Authorization Server Metadata <span>[<a href="#RFC8414" class="cite xref">RFC8414</a>]</span>
containing the supported PKCE challenge methods (which can be used by
the client to detect PKCE support). Authorization servers <span class="bcp14">MAY</span> instead provide a
deployment-specific way to ensure or determine PKCE support by the authorization server.<a href="#section-2.1.1-9" class="pilcrow">¶</a></p>
</section>
</div>
<div id="implicit_grant_recommendation">
<section id="section-2.1.2">
          <h4 id="name-implicit-grant">
<a href="#section-2.1.2" class="section-number selfRef">2.1.2. </a><a href="#name-implicit-grant" class="section-name selfRef">Implicit Grant</a>
          </h4>
<p id="section-2.1.2-1">The implicit grant (response type <code>token</code>) and other response types
causing the authorization server to issue access tokens in the
authorization response are vulnerable to access token leakage and
access token replay as described in Sections <a href="#insufficient_uri_validation" class="auto internal xref">4.1</a>,
<a href="#credential_leakage_referrer" class="auto internal xref">4.2</a>, <a href="#browser_history" class="auto internal xref">4.3</a>, and
<a href="#access_token_injection" class="auto internal xref">4.6</a>.<a href="#section-2.1.2-1" class="pilcrow">¶</a></p>
<p id="section-2.1.2-2">Moreover, no standardized method for sender-constraining exists to
bind access tokens to a specific client (as recommended in
<a href="#token_replay_prevention" class="auto internal xref">Section 2.2</a>) when the access tokens are issued in the
authorization response. This means that an attacker can use the leaked or stolen
access token at a resource endpoint.<a href="#section-2.1.2-2" class="pilcrow">¶</a></p>
<p id="section-2.1.2-3">In order to avoid these issues, clients <span class="bcp14">SHOULD NOT</span> use the implicit
grant (response type <code>token</code>) or other response types issuing
access tokens in the authorization response, unless access token injection
in the authorization response is prevented and the aforementioned token leakage
vectors are mitigated.<a href="#section-2.1.2-3" class="pilcrow">¶</a></p>
<p id="section-2.1.2-4">Clients <span class="bcp14">SHOULD</span> instead use the response type <code>code</code> (i.e., authorization
code grant type) as specified in <a href="#ac" class="auto internal xref">Section 2.1.1</a> or any other response type that
causes the authorization server to issue access tokens in the token
response, such as the <code>code id_token</code> response type. This allows the
authorization server to detect replay attempts by attackers and
generally reduces the attack surface since access tokens are not
exposed in URLs. It also allows the authorization server to
sender-constrain the issued tokens (see <a href="#token_replay_prevention" class="auto internal xref">Section 2.2</a>).<a href="#section-2.1.2-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="token_replay_prevention">
<section id="section-2.2">
        <h3 id="name-token-replay-prevention">
<a href="#section-2.2" class="section-number selfRef">2.2. </a><a href="#name-token-replay-prevention" class="section-name selfRef">Token Replay Prevention</a>
        </h3>
<div id="access-tokens">
<section id="section-2.2.1">
          <h4 id="name-access-tokens">
<a href="#section-2.2.1" class="section-number selfRef">2.2.1. </a><a href="#name-access-tokens" class="section-name selfRef">Access Tokens</a>
          </h4>
<p id="section-2.2.1-1">A sender-constrained access token scopes the applicability of an access
token to a certain sender. This sender is obliged to demonstrate knowledge
of a certain secret as a prerequisite for the acceptance of that token at
the recipient (e.g., a resource server).<a href="#section-2.2.1-1" class="pilcrow">¶</a></p>
<p id="section-2.2.1-2">Authorization and resource servers <span class="bcp14">SHOULD</span> use mechanisms for sender-constraining
access tokens, such as mutual TLS for OAuth 2.0 <span>[<a href="#RFC8705" class="cite xref">RFC8705</a>]</span> or OAuth 2.0
Demonstrating Proof of Possession (DPoP) <span>[<a href="#RFC9449" class="cite xref">RFC9449</a>]</span> (see
<a href="#pop_tokens" class="auto internal xref">Section 4.10.1</a>), to prevent misuse of stolen and leaked access tokens.<a href="#section-2.2.1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="refresh-tokens">
<section id="section-2.2.2">
          <h4 id="name-refresh-tokens">
<a href="#section-2.2.2" class="section-number selfRef">2.2.2. </a><a href="#name-refresh-tokens" class="section-name selfRef">Refresh Tokens</a>
          </h4>
<p id="section-2.2.2-1">Refresh tokens for public clients <span class="bcp14">MUST</span> be sender-constrained or use refresh
token rotation as described in <a href="#refresh_token_protection" class="auto internal xref">Section 4.14</a>. <span>[<a href="#RFC6749" class="cite xref">RFC6749</a>]</span> already
mandates that refresh tokens for confidential clients can only be used by the
client for which they were issued.<a href="#section-2.2.2-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="access-token-privilege-restriction">
<section id="section-2.3">
        <h3 id="name-access-token-privilege-rest">
<a href="#section-2.3" class="section-number selfRef">2.3. </a><a href="#name-access-token-privilege-rest" class="section-name selfRef">Access Token Privilege Restriction</a>
        </h3>
<p id="section-2.3-1">The privileges associated with an access token <span class="bcp14">SHOULD</span> be restricted to
the minimum required for the particular application or use case. This
prevents clients from exceeding the privileges authorized by the
resource owner. It also prevents users from exceeding their privileges
authorized by the respective security policy. Privilege restrictions
also help to reduce the impact of access token leakage.<a href="#section-2.3-1" class="pilcrow">¶</a></p>
<p id="section-2.3-2">In particular, access tokens <span class="bcp14">SHOULD</span> be audience-restricted to a specific resource
server or, if that is not feasible, to a small set of resource servers. To put this into effect, the authorization server associates
the access token with certain resource servers, and every resource
server is obliged to verify, for every request, whether the access
token sent with that request was meant to be used for that particular
resource server. If it was not, the resource server <span class="bcp14">MUST</span> refuse to serve the
respective request. The <code>aud</code> claim as defined in <span>[<a href="#RFC9068" class="cite xref">RFC9068</a>]</span> <span class="bcp14">MAY</span> be
used to audience-restrict access tokens. Clients and authorization servers <span class="bcp14">MAY</span> utilize the
parameters <code>scope</code> or <code>resource</code> as specified in <span>[<a href="#RFC6749" class="cite xref">RFC6749</a>]</span> and
<span>[<a href="#RFC8707" class="cite xref">RFC8707</a>]</span>, respectively, to determine the
resource server they want to access.<a href="#section-2.3-2" class="pilcrow">¶</a></p>
<p id="section-2.3-3">Additionally, access tokens <span class="bcp14">SHOULD</span> be restricted to certain resources
and actions on resource servers or resources. To put this into effect,
the authorization server associates the access token with the
respective resource and actions and every resource server is obliged
to verify, for every request, whether the access token sent with that
request was meant to be used for that particular action on the
particular resource. If not, the resource server must refuse to serve
the respective request. Clients and authorization servers <span class="bcp14">MAY</span> utilize
the parameter <code>scope</code> as specified in <span>[<a href="#RFC6749" class="cite xref">RFC6749</a>]</span> and <code>authorization_details</code> as specified in <span>[<a href="#RFC9396" class="cite xref">RFC9396</a>]</span> to determine those
resources and/or actions.<a href="#section-2.3-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="resource-owner-password-credentials-grant">
<section id="section-2.4">
        <h3 id="name-resource-owner-password-cre">
<a href="#section-2.4" class="section-number selfRef">2.4. </a><a href="#name-resource-owner-password-cre" class="section-name selfRef">Resource Owner Password Credentials Grant</a>
        </h3>
<p id="section-2.4-1">The resource owner password credentials grant <span>[<a href="#RFC6749" class="cite xref">RFC6749</a>]</span> <span class="bcp14">MUST NOT</span>
be used. This grant type insecurely exposes the credentials of the resource
owner to the client. Even if the client is benign, usage of this grant results in an increased
attack surface (i.e., credentials can leak in more places than just the authorization server) and in training users to enter their credentials in places other than the authorization server.<a href="#section-2.4-1" class="pilcrow">¶</a></p>
<p id="section-2.4-2">Furthermore, the resource owner password credentials grant is not designed to
work with two-factor authentication and authentication processes that require
multiple user interaction steps. Authentication with cryptographic credentials
(cf. WebCrypto <span>[<a href="#W3C.WebCrypto" class="cite xref">W3C.WebCrypto</a>]</span>, WebAuthn <span>[<a href="#W3C.WebAuthn" class="cite xref">W3C.WebAuthn</a>]</span>) may be impossible
to implement with this grant type, as it is usually bound to a specific web origin.<a href="#section-2.4-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="client-authentication">
<section id="section-2.5">
        <h3 id="name-client-authentication">
<a href="#section-2.5" class="section-number selfRef">2.5. </a><a href="#name-client-authentication" class="section-name selfRef">Client Authentication</a>
        </h3>
<p id="section-2.5-1">Authorization servers <span class="bcp14">SHOULD</span> enforce client authentication if it is feasible, in
the particular deployment, to establish a process for issuance/registration of
credentials for clients and ensuring the confidentiality of those credentials.<a href="#section-2.5-1" class="pilcrow">¶</a></p>
<p id="section-2.5-2">
It is <span class="bcp14">RECOMMENDED</span> to use asymmetric cryptography for
client authentication, such as mutual TLS for OAuth 2.0 <span>[<a href="#RFC8705" class="cite xref">RFC8705</a>]</span> or signed JWTs
("Private Key JWT") in accordance with <span>[<a href="#RFC7521" class="cite xref">RFC7521</a>]</span> and <span>[<a href="#RFC7523" class="cite xref">RFC7523</a>]</span>. The latter is defined in <span>[<a href="#OpenID.Core" class="cite xref">OpenID.Core</a>]</span> as the client authentication method <code>private_key_jwt</code>).
When asymmetric cryptography for client authentication is used, authorization
servers do not need to store sensitive symmetric keys, making these
methods more robust against leakage of keys.<a href="#section-2.5-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="other_recommendations">
<section id="section-2.6">
        <h3 id="name-other-recommendations">
<a href="#section-2.6" class="section-number selfRef">2.6. </a><a href="#name-other-recommendations" class="section-name selfRef">Other Recommendations</a>
        </h3>
<p id="section-2.6-1">The use of OAuth Authorization Server Metadata <span>[<a href="#RFC8414" class="cite xref">RFC8414</a>]</span> can help to improve the security of OAuth
deployments:<a href="#section-2.6-1" class="pilcrow">¶</a></p>
<ul class="compact">
<li class="compact" id="section-2.6-2.1">It ensures that security features and other new OAuth features can be enabled
automatically by compliant software libraries.<a href="#section-2.6-2.1" class="pilcrow">¶</a>
</li>
          <li class="compact" id="section-2.6-2.2">It reduces chances for misconfigurations -- for example, misconfigured endpoint
URLs (that might belong to an attacker) or misconfigured security features.<a href="#section-2.6-2.2" class="pilcrow">¶</a>
</li>
          <li class="compact" id="section-2.6-2.3">It can help to facilitate rotation of cryptographic keys and to ensure
cryptographic agility.<a href="#section-2.6-2.3" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-2.6-3">It is therefore <span class="bcp14">RECOMMENDED</span> that authorization servers publish OAuth Authorization Server Metadata according to
<span>[<a href="#RFC8414" class="cite xref">RFC8414</a>]</span> and that clients make use of this Authorization Server Metadata (when available) to configure themselves.<a href="#section-2.6-3" class="pilcrow">¶</a></p>
<p id="section-2.6-4">Under the conditions described in <a href="#client_impersonating_countermeasures" class="auto internal xref">Section 4.15.1</a>,
authorization servers <span class="bcp14">SHOULD NOT</span> allow clients to influence their <code>client_id</code> or
any other claim that could cause confusion with a genuine resource owner.<a href="#section-2.6-4" class="pilcrow">¶</a></p>
<p id="section-2.6-5">It is <span class="bcp14">RECOMMENDED</span> to use end-to-end TLS according to <span>[<a href="#BCP195" class="cite xref">BCP195</a>]</span> between the client and the resource server. If TLS
traffic needs to be terminated at an intermediary, refer to
<a href="#tls_terminating" class="auto internal xref">Section 4.13</a> for further security advice.<a href="#section-2.6-5" class="pilcrow">¶</a></p>
<p id="section-2.6-6">Authorization responses <span class="bcp14">MUST NOT</span> be transmitted over unencrypted network
connections. To this end, authorization servers <span class="bcp14">MUST NOT</span> allow redirection URIs that use the <code>http</code>
scheme except for native clients that use loopback interface redirection as
described in <span><a href="https://rfc-editor.org/rfc/rfc8252#section-7.3" class="relref">Section 7.3</a> of [<a href="#RFC8252" class="cite xref">RFC8252</a>]</span>.<a href="#section-2.6-6" class="pilcrow">¶</a></p>
<p id="section-2.6-7">If the authorization response is sent with in-browser communication techniques
like postMessage <span>[<a href="#WHATWG.postmessage_api" class="cite xref">WHATWG.postmessage_api</a>]</span> instead of HTTP redirects, both the
initiator and receiver of the in-browser message <span class="bcp14">MUST</span> be strictly verified as described
in <a href="#rec_ibc" class="auto internal xref">Section 4.17</a>.<a href="#section-2.6-7" class="pilcrow">¶</a></p>
<p id="section-2.6-8">To support browser-based clients, endpoints directly accessed by such clients
including the Token Endpoint, Authorization Server Metadata Endpoint, <code>jwks_uri</code>
Endpoint, and Dynamic Client Registration Endpoint <span class="bcp14">MAY</span> support the use of
Cross-Origin Resource Sharing (CORS) <span>[<a href="#WHATWG.CORS" class="cite xref">WHATWG.CORS</a>]</span>. 
However, CORS <span class="bcp14">MUST NOT</span> be
supported at the authorization endpoint, as the client does not access this
endpoint directly; instead, the client redirects the user agent to it.<a href="#section-2.6-8" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="secmodel">
<section id="section-3">
      <h2 id="name-the-updated-oauth-20-attack">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-the-updated-oauth-20-attack" class="section-name selfRef">The Updated OAuth 2.0 Attacker Model</a>
      </h2>
<p id="section-3-1">In <span>[<a href="#RFC6819" class="cite xref">RFC6819</a>]</span>, a threat model is laid out that describes the threats against
which OAuth deployments must be protected. While doing so, <span>[<a href="#RFC6819" class="cite xref">RFC6819</a>]</span> makes
certain assumptions about attackers and their capabilities, i.e., it implicitly
establishes an attacker model. In the following, this attacker model is made
explicit and is updated and expanded to account for the potentially dynamic
relationships involving multiple parties (as described in <a href="#Introduction" class="auto internal xref">Section 1</a>), to
include new types of attackers, and to define the attacker model more clearly.<a href="#section-3-1" class="pilcrow">¶</a></p>
<p id="section-3-2">The goal of this document is to ensure that the authorization of a resource
owner (with a user agent) at an authorization server and the subsequent usage of
the access token at a resource server is protected, as well as practically
possible, at least against the following attackers.<a href="#section-3-2" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="olPercent" id="section-3-3">
<dt>(A1)</dt>
<dd id="section-3-3.1">
<div id="web_attackers">
          <p id="section-3-3.1.1">Web attackers that can set up and operate an arbitrary number of
network endpoints (besides the "honest" ones) including browsers and
servers. Web attackers may set up websites that are visited by the resource
owner, operate their own user agents, and participate in the protocol.<a href="#section-3-3.1.1" class="pilcrow">¶</a></p>
<p id="section-3-3.1.2">In particular, web attackers may operate OAuth clients that are registered
at the authorization server, and they may operate their own authorization and
resource servers that can be used (in parallel to the "honest" ones) by the
resource owner and other resource owners.<a href="#section-3-3.1.2" class="pilcrow">¶</a></p>
<p id="section-3-3.1.3">It must also be assumed that web attackers can lure the user to
navigate their browser to arbitrary attacker-chosen URIs at any time. In practice, this
can be achieved in many ways, for example, by injecting malicious
advertisements into advertisement networks or by sending
legitimate-looking emails.<a href="#section-3-3.1.3" class="pilcrow">¶</a></p>
<p id="section-3-3.1.4">Web attackers can use their own user credentials to create new
messages as well as any secrets they learned previously. For
example, if a web attacker learns an authorization code of a user
through a misconfigured redirection URI, the web attacker can then
try to redeem that code for an access token.<a href="#section-3-3.1.4" class="pilcrow">¶</a></p>
<p id="section-3-3.1.5">They cannot, however, read or manipulate messages that are not
targeted towards them (e.g., sent to a URL of an authorization server not under control of an attacker).<a href="#section-3-3.1.5" class="pilcrow">¶</a></p>
</div>
        </dd>
<dd class="break"></dd>
<dt>(A2)</dt>
<dd id="section-3-3.2">
<div id="network_attackers">
          <p id="section-3-3.2.1">Network attackers that additionally have full control over
the network over which protocol participants communicate. They can
eavesdrop on, manipulate, and spoof messages, except when these
are properly protected by cryptographic methods (e.g., TLS).
Network attackers can also block arbitrary messages.<a href="#section-3-3.2.1" class="pilcrow">¶</a></p>
</div>
      </dd>
<dd class="break"></dd>
</dl>
<p id="section-3-4">While an example for a web attacker would be a customer of an internet
service provider, network attackers could be the internet service
provider itself, an attacker in a public (Wi-Fi) network using ARP
spoofing, or a state-sponsored attacker with access to internet
exchange points, for instance.<a href="#section-3-4" class="pilcrow">¶</a></p>
<p id="section-3-5">The aforementioned attackers <a href="#web_attackers" class="internal xref">(A1)</a> and <a href="#network_attackers" class="internal xref">(A2)</a> conform to the attacker model that was used in formal analysis
efforts for OAuth <span>[<a href="#arXiv.1601.01229" class="cite xref">arXiv.1601.01229</a>]</span>. This is a minimal attacker model.
Implementers <span class="bcp14">MUST</span> take into account all possible types of attackers in the
environment of their OAuth implementations. For example, in <span>[<a href="#arXiv.1901.11520" class="cite xref">arXiv.1901.11520</a>]</span>,
a very strong attacker model is used that includes attackers that have
full control over the token endpoint. This models effects of a
possible misconfiguration of endpoints in the ecosystem, which can be avoided
by using authorization server metadata as described in <a href="#other_recommendations" class="auto internal xref">Section 2.6</a>. Such an attacker is therefore not listed here.<a href="#section-3-5" class="pilcrow">¶</a></p>
<p id="section-3-6">However, previous attacks on OAuth have shown that the following types of
attackers are relevant in particular:<a href="#section-3-6" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="olPercent" id="section-3-7">
<dt>(A3)</dt>
<dd id="section-3-7.1">
<div id="read_response">
          <p id="section-3-7.1.1">
    Attackers that can read, but not modify, the contents of the
    authorization response (i.e., the authorization response can leak
    to an attacker).<a href="#section-3-7.1.1" class="pilcrow">¶</a></p>
<p id="section-3-7.1.2">
    Examples of such attacks include open redirector attacks and
    mix-up attacks (see <a href="#mix_up" class="auto internal xref">Section 4.4</a>), where the client is tricked 
    into sending credentials to an attacker-controlled authorization 
    server.<a href="#section-3-7.1.2" class="pilcrow">¶</a></p>
<p id="section-3-7.1.3">
    Also, this includes attacks that take advantage of:<a href="#section-3-7.1.3" class="pilcrow">¶</a></p>
<ul class="compact">
<li class="compact" id="section-3-7.1.4.1"> insufficient checking of redirect URIs (see <a href="#insufficient_uri_validation" class="auto internal xref">Section 4.1</a>);<a href="#section-3-7.1.4.1" class="pilcrow">¶</a>
</li>
            <li class="compact" id="section-3-7.1.4.2"> problems existing on mobile operating systems, where different
    apps can register themselves on the same URI; and<a href="#section-3-7.1.4.2" class="pilcrow">¶</a>
</li>
            <li class="compact" id="section-3-7.1.4.3"> URLs stored/logged by browsers (history), proxy servers, and operating systems.<a href="#section-3-7.1.4.3" class="pilcrow">¶</a>
</li>
          </ul>
</div>
        </dd>
<dd class="break"></dd>
<dt>(A4)</dt>
<dd id="section-3-7.2">
<div id="read_request">
          <p id="section-3-7.2.1">Attackers that can read, but not modify, the contents of the
authorization request (i.e., the authorization request can leak,
in the same manner as above, to an attacker).<a href="#section-3-7.2.1" class="pilcrow">¶</a></p>
</div>
        </dd>
<dd class="break"></dd>
<dt>(A5)</dt>
<dd id="section-3-7.3">
<div id="acquire_token">
          <p id="section-3-7.3.1">Attackers that can acquire an access token issued by an authorization server. 
For
example, a resource server may be compromised by an attacker, an
access token may be sent to an attacker-controlled resource server
due to a misconfiguration, or social engineering may be used to get a resource owner to
use an attacker-controlled resource server. Also see <a href="#comp_res_server" class="auto internal xref">Section 4.9.2</a>.<a href="#section-3-7.3.1" class="pilcrow">¶</a></p>
</div>
      </dd>
<dd class="break"></dd>
</dl>
<p id="section-3-8"><a href="#read_response" class="internal xref">(A3)</a>, <a href="#read_request" class="internal xref">(A4)</a>, and <a href="#acquire_token" class="internal xref">(A5)</a> typically occur together with either <a href="#web_attackers" class="internal xref">(A1)</a> or <a href="#network_attackers" class="internal xref">(A2)</a>.
Attackers can collaborate to reach a common goal.<a href="#section-3-8" class="pilcrow">¶</a></p>
<p id="section-3-9">Note that an Attacker <a href="#web_attackers" class="internal xref">(A1)</a> or <a href="#network_attackers" class="internal xref">(A2)</a> can be a resource owner or
act as one. For example, such an attacker can use their own browser to replay
tokens or authorization codes obtained by any of the attacks described
above at the client or resource server.<a href="#section-3-9" class="pilcrow">¶</a></p>
<p id="section-3-10">This document focuses on threats resulting from Attackers <a href="#web_attackers" class="internal xref">(A1)</a> to <a href="#acquire_token" class="internal xref">(A5)</a>.<a href="#section-3-10" class="pilcrow">¶</a></p>
</section>
</div>
<div id="attacks_and_mitigations">
<section id="section-4">
      <h2 id="name-attacks-and-mitigations">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-attacks-and-mitigations" class="section-name selfRef">Attacks and Mitigations</a>
      </h2>
<p id="section-4-1">This section gives a detailed description of attacks on OAuth implementations,
along with potential countermeasures. Attacks and mitigations already covered in
<span>[<a href="#RFC6819" class="cite xref">RFC6819</a>]</span> are not listed here, except where new recommendations are made.<a href="#section-4-1" class="pilcrow">¶</a></p>
<p id="section-4-2">This section further defines additional requirements (beyond those defined in
<a href="#recommendations" class="auto internal xref">Section 2</a>) for certain cases and protocol options.<a href="#section-4-2" class="pilcrow">¶</a></p>
<div id="insufficient_uri_validation">
<section id="section-4.1">
        <h3 id="name-insufficient-redirection-ur">
<a href="#section-4.1" class="section-number selfRef">4.1. </a><a href="#name-insufficient-redirection-ur" class="section-name selfRef">Insufficient Redirection URI Validation</a>
        </h3>
<p id="section-4.1-1">Some authorization servers allow clients to register redirection URI
patterns instead of complete redirection URIs. The authorization servers
then match the redirection URI parameter value at the authorization
endpoint against the registered patterns at runtime. This approach
allows clients to encode transaction state into additional redirect
URI parameters or to register a single pattern for multiple
redirection URIs.<a href="#section-4.1-1" class="pilcrow">¶</a></p>
<p id="section-4.1-2">This approach turned out to be more complex to implement and more
error-prone to manage than exact redirection URI matching. Several
successful attacks exploiting flaws in the pattern-matching
implementation or concrete configurations have been observed in the
wild (see, e.g., <span>[<a href="#research.rub2" class="cite xref">research.rub2</a>]</span>). Insufficient validation of the redirection URI effectively breaks
client identification or authentication (depending on grant and client
type) and allows the attacker to obtain an authorization code or
access token, either<a href="#section-4.1-2" class="pilcrow">¶</a></p>
<ul class="compact">
<li class="compact" id="section-4.1-3.1">by directly sending the user agent to a URI under the attacker's
control, or<a href="#section-4.1-3.1" class="pilcrow">¶</a>
</li>
          <li class="compact" id="section-4.1-3.2">by exposing the OAuth credentials to an attacker by utilizing an
open redirector at the client in conjunction with the way user
agents handle URL fragments.<a href="#section-4.1-3.2" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-4.1-4">These attacks are shown in detail in the following subsections.<a href="#section-4.1-4" class="pilcrow">¶</a></p>
<div id="insufficient_uri_validation_acg">
<section id="section-4.1.1">
          <h4 id="name-redirect-uri-validation-att">
<a href="#section-4.1.1" class="section-number selfRef">4.1.1. </a><a href="#name-redirect-uri-validation-att" class="section-name selfRef">Redirect URI Validation Attacks on Authorization Code Grant</a>
          </h4>
<p id="section-4.1.1-1">For a client using the grant type <code>code</code>, an attack may work as
follows:<a href="#section-4.1.1-1" class="pilcrow">¶</a></p>
<p id="section-4.1.1-2">Assume the redirection URL pattern <code>https://*.somesite.example/*</code> is
registered for the client with the client ID <code>s6BhdRkqt3</code>. The
intention is to allow any subdomain of <code>somesite.example</code> to be a
valid redirection URI for the client, for example,
<code>https://app1.somesite.example/redirect</code>. However, a naive implementation on
the authorization server might interpret the wildcard <code>*</code> as
"any character" and not "any character valid for a domain name". The
authorization server, therefore, might permit
<code>https://attacker.example/.somesite.example</code> as a redirection URI,
although <code>attacker.example</code> is a different domain potentially
controlled by a malicious party.<a href="#section-4.1.1-2" class="pilcrow">¶</a></p>
<p id="section-4.1.1-3">The attack can then be conducted as follows:<a href="#section-4.1.1-3" class="pilcrow">¶</a></p>
<p id="section-4.1.1-4">To begin, the attacker needs to trick the user into opening a tampered
URL in their browser that launches a page under the attacker's
control, say, <code>https://www.evil.example</code> (see attacker <a href="#web_attackers" class="internal xref">A1</a> in <a href="#secmodel" class="auto internal xref">Section 3</a>).<a href="#section-4.1.1-4" class="pilcrow">¶</a></p>
<p id="section-4.1.1-5">This URL initiates the following authorization request with the client
ID of a legitimate client to the authorization endpoint (line breaks
for display only):<a href="#section-4.1.1-5" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-4.1.1-6">
<pre>
GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=9ad67f13
     &amp;redirect_uri=https%3A%2F%2Fattacker.example%2F.somesite.example
     HTTP/1.1
Host: server.somesite.example
</pre><a href="#section-4.1.1-6" class="pilcrow">¶</a>
</div>
<p id="section-4.1.1-7">The authorization server validates the redirection URI and compares it to
the registered redirection URL patterns for the client <code>s6BhdRkqt3</code>.
The authorization request is processed and presented to the user.<a href="#section-4.1.1-7" class="pilcrow">¶</a></p>
<p id="section-4.1.1-8">If the user does not see the redirection URI or does not recognize the
attack, the code is issued and immediately sent to the attacker's
domain. If an automatic approval of the authorization is enabled
(which is not recommended for public clients according to
<span>[<a href="#RFC6749" class="cite xref">RFC6749</a>]</span>), the attack can be performed even without user
interaction.<a href="#section-4.1.1-8" class="pilcrow">¶</a></p>
<p id="section-4.1.1-9">If the attacker impersonates a public client, the attacker can
exchange the code for tokens at the respective token endpoint.<a href="#section-4.1.1-9" class="pilcrow">¶</a></p>
<p id="section-4.1.1-10">This attack will not work as easily for confidential clients, since
the code exchange requires authentication with the legitimate client's
secret. However, the attacker can use the legitimate confidential
client to redeem the code by performing an authorization code
injection attack; see <a href="#code_injection" class="auto internal xref">Section 4.5</a>.<a href="#section-4.1.1-10" class="pilcrow">¶</a></p>
<p id="section-4.1.1-11">It is important to note that redirection URI validation vulnerabilities can also exist if the authorization
server handles wildcards properly. For example, assume that the client
registers the redirection URL pattern <code>https://*.somesite.example/*</code> and
the authorization server interprets this as "allow redirection URIs
pointing to any host residing in the domain <code>somesite.example</code>". If an
attacker manages to establish a host or subdomain in
<code>somesite.example</code>, the attacker can impersonate the legitimate client. For example, this
could be caused by a subdomain takeover attack <span>[<a href="#research.udel" class="cite xref">research.udel</a>]</span>, where an
outdated CNAME record (say, <code>external-service.somesite.example</code>)
points to an external DNS name that no longer exists (say,
<code>customer-abc.service.example</code>) and can be taken over by an attacker
(e.g., by registering as <code>customer-abc</code> with the external service).<a href="#section-4.1.1-11" class="pilcrow">¶</a></p>
</section>
</div>
<div id="redir_uri_open_redir">
<section id="section-4.1.2">
          <h4 id="name-redirect-uri-validation-atta">
<a href="#section-4.1.2" class="section-number selfRef">4.1.2. </a><a href="#name-redirect-uri-validation-atta" class="section-name selfRef">Redirect URI Validation Attacks on Implicit Grant</a>
          </h4>
<p id="section-4.1.2-1">The attack described above works for the implicit grant as well. If
the attacker is able to send the authorization response to an attacker-controlled URI, the attacker will directly get access to the fragment carrying the
access token.<a href="#section-4.1.2-1" class="pilcrow">¶</a></p>
<p id="section-4.1.2-2">Additionally, implicit grants (and also other grants when using <code>response_mode=fragment</code> as defined in <span>[<a href="#OAuth.Responses" class="cite xref">OAuth.Responses</a>]</span>) can be subject to a further kind of
attack. The attack utilizes the fact that user agents reattach fragments to
the destination URL of a redirect if the location header does not
contain a fragment (see <span><a href="https://rfc-editor.org/rfc/rfc9110#section-17.11" class="relref">Section 17.11</a> of [<a href="#RFC9110" class="cite xref">RFC9110</a>]</span>). The attack
described here combines this behavior with the client as an open
redirector (see <a href="#open_redirector_on_client" class="auto internal xref">Section 4.11.1</a>) in order to obtain access tokens. This allows
circumvention even of very narrow redirection URI patterns, but not of strict URL
matching.<a href="#section-4.1.2-2" class="pilcrow">¶</a></p>
<p id="section-4.1.2-3">Assume the registered URL pattern for client <code>s6BhdRkqt3</code> is
<code>https://client.somesite.example/cb?*</code>, i.e., any parameter is allowed
for redirects to <code>https://client.somesite.example/cb</code>. Unfortunately,
the client exposes an open redirector. This endpoint supports a
parameter <code>redirect_to</code> which takes a target URL and will send the
browser to this URL using an HTTP Location header redirect 303.<a href="#section-4.1.2-3" class="pilcrow">¶</a></p>
<p id="section-4.1.2-4">The attack can now be conducted as follows:<a href="#section-4.1.2-4" class="pilcrow">¶</a></p>
<p id="section-4.1.2-5">To begin, as above, the attacker needs to trick the user into opening
a tampered URL in their browser that launches a page under the
attacker's control, say, <code>https://www.evil.example</code>.<a href="#section-4.1.2-5" class="pilcrow">¶</a></p>
<p id="section-4.1.2-6">Afterwards, the website initiates an authorization request that is
very similar to the one in the attack on the code flow. Different to
above, it utilizes the open redirector by encoding
<code>redirect_to=https://attacker.example</code> into the parameters of the
redirection URI, and it uses the response type <code>token</code> (line breaks for display only):<a href="#section-4.1.2-6" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-4.1.2-7">
<pre>
GET /authorize?response_type=token&amp;state=9ad67f13
    &amp;client_id=s6BhdRkqt3
    &amp;redirect_uri=https%3A%2F%2Fclient.somesite.example
     %2Fcb%26redirect_to%253Dhttps%253A%252F
     %252Fattacker.example%252F HTTP/1.1
Host: server.somesite.example
</pre><a href="#section-4.1.2-7" class="pilcrow">¶</a>
</div>
<p id="section-4.1.2-8">Then, since the redirection URI matches the registered pattern, the
authorization server permits the request and sends the resulting access
token in a 303 redirect (some response parameters omitted for
readability):<a href="#section-4.1.2-8" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-4.1.2-9">
<pre>
HTTP/1.1 303 See Other
Location: https://client.somesite.example/cb?
          redirect_to%3Dhttps%3A%2F%2Fattacker.example%2Fcb
          #access_token=2YotnFZFEjr1zCsicMWpAA&amp;...
</pre><a href="#section-4.1.2-9" class="pilcrow">¶</a>
</div>
<p id="section-4.1.2-10">At client.somesite.example, the request arrives at the open redirector. The endpoint will
read the redirect parameter and will issue an HTTP 303 Location header
redirect to the URL <code>https://attacker.example/</code>.<a href="#section-4.1.2-10" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-4.1.2-11">
<pre>
HTTP/1.1 303 See Other
Location: https://attacker.example/
</pre><a href="#section-4.1.2-11" class="pilcrow">¶</a>
</div>
<p id="section-4.1.2-12">Since the redirector at client.somesite.example does not include a
fragment in the Location header, the user agent will reattach the
original fragment <code>#access_token=2YotnFZFEjr1zCsicMWpAA&amp;amp;...</code> to
the URL and will navigate to the following URL:<a href="#section-4.1.2-12" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.1.2-13">
<pre>
https://attacker.example/#access_token=2YotnFZFEjr1z...
</pre><a href="#section-4.1.2-13" class="pilcrow">¶</a>
</div>
<p id="section-4.1.2-14">The attacker's page at <code>attacker.example</code> can then access the
fragment and obtain the access token.<a href="#section-4.1.2-14" class="pilcrow">¶</a></p>
</section>
</div>
<div id="iuv_countermeasures">
<section id="section-4.1.3">
          <h4 id="name-countermeasures">
<a href="#section-4.1.3" class="section-number selfRef">4.1.3. </a><a href="#name-countermeasures" class="section-name selfRef">Countermeasures</a>
          </h4>
<p id="section-4.1.3-1">The complexity of implementing and managing pattern matching correctly obviously
causes security issues. This document therefore advises simplifying the required
logic and configuration by using exact redirection URI matching. This means the
authorization server <span class="bcp14">MUST</span> ensure that the two URIs are equal; see <span><a href="https://rfc-editor.org/rfc/rfc3986#section-6.2.1" class="relref">Section 6.2.1</a> of [<a href="#RFC3986" class="cite xref">RFC3986</a>]</span>, Simple String Comparison, for details. The only exception is
native apps using a <code>localhost</code> URI: In this case, the authorization server <span class="bcp14">MUST</span> allow variable
port numbers as described in <span><a href="https://rfc-editor.org/rfc/rfc8252#section-7.3" class="relref">Section 7.3</a> of [<a href="#RFC8252" class="cite xref">RFC8252</a>]</span>.<a href="#section-4.1.3-1" class="pilcrow">¶</a></p>
<p id="section-4.1.3-2">Additional recommendations:<a href="#section-4.1.3-2" class="pilcrow">¶</a></p>
<ul class="compact">
<li class="compact" id="section-4.1.3-3.1">Web servers on which redirection URIs are hosted <span class="bcp14">MUST NOT</span> expose open
redirectors (see <a href="#open_redirection" class="auto internal xref">Section 4.11</a>).<a href="#section-4.1.3-3.1" class="pilcrow">¶</a>
</li>
            <li class="compact" id="section-4.1.3-3.2">Browsers reattach URL fragments to Location redirection URLs only
if the URL in the Location header does not already contain a fragment.
Therefore, servers <span class="bcp14">MAY</span> prevent browsers from reattaching fragments
to redirection URLs by attaching an arbitrary fragment identifier,
for example <code>#_</code>, to URLs in Location headers.<a href="#section-4.1.3-3.2" class="pilcrow">¶</a>
</li>
            <li class="compact" id="section-4.1.3-3.3">Clients <span class="bcp14">SHOULD</span> use the authorization code response type instead of
response types that cause access token issuance at the authorization
endpoint. This offers countermeasures against the reuse of leaked
credentials through the exchange process with the authorization
server and against token replay through sender-constraining of the access
tokens.<a href="#section-4.1.3-3.3" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-4.1.3-4">If the origin and integrity of the authorization request containing
the redirection URI can be verified, for example, when using
<span>[<a href="#RFC9101" class="cite xref">RFC9101</a>]</span> or <span>[<a href="#RFC9126" class="cite xref">RFC9126</a>]</span> with client
authentication, the authorization server <span class="bcp14">MAY</span> trust the redirection URI
without further checks.<a href="#section-4.1.3-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="credential_leakage_referrer">
<section id="section-4.2">
        <h3 id="name-credential-leakage-via-refe">
<a href="#section-4.2" class="section-number selfRef">4.2. </a><a href="#name-credential-leakage-via-refe" class="section-name selfRef">Credential Leakage via Referer Headers</a>
        </h3>
<p id="section-4.2-1">The contents of the authorization request URI or the authorization
response URI can unintentionally be disclosed to attackers through the
Referer HTTP header (see <span><a href="https://rfc-editor.org/rfc/rfc9110#section-10.1.3" class="relref">Section 10.1.3</a> of [<a href="#RFC9110" class="cite xref">RFC9110</a>]</span>), by leaking from either the authorization server's or the client's website, respectively. Most
importantly, authorization codes or <code>state</code> values can be disclosed in
this way. Although specified otherwise in <span><a href="https://rfc-editor.org/rfc/rfc9110#section-10.1.3" class="relref">Section 10.1.3</a> of [<a href="#RFC9110" class="cite xref">RFC9110</a>]</span>,
the same may happen to access tokens conveyed in URI fragments due to
browser implementation issues, as illustrated by a (now fixed) issue in the Chromium project <span>[<a href="#bug.chromium" class="cite xref">bug.chromium</a>]</span>.<a href="#section-4.2-1" class="pilcrow">¶</a></p>
<div id="leakage-from-the-oauth-client">
<section id="section-4.2.1">
          <h4 id="name-leakage-from-the-oauth-clie">
<a href="#section-4.2.1" class="section-number selfRef">4.2.1. </a><a href="#name-leakage-from-the-oauth-clie" class="section-name selfRef">Leakage from the OAuth Client</a>
          </h4>
<p id="section-4.2.1-1">Leakage from the OAuth client requires that the client, as a result of
a successful authorization request, renders a page that<a href="#section-4.2.1-1" class="pilcrow">¶</a></p>
<ul class="compact">
<li class="compact" id="section-4.2.1-2.1">contains links to other pages under the attacker's control and a
user clicks on such a link, or<a href="#section-4.2.1-2.1" class="pilcrow">¶</a>
</li>
            <li class="compact" id="section-4.2.1-2.2">includes third-party content (advertisements in iframes, images,
etc.), for example, if the page contains user-generated content
(blog).<a href="#section-4.2.1-2.2" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-4.2.1-3">As soon as the browser navigates to the attacker's page or loads the
third-party content, the attacker receives the authorization response
URL and can extract <code>code</code> or <code>state</code> (and potentially <code>access_token</code>).<a href="#section-4.2.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="leakage-from-the-authorization-server">
<section id="section-4.2.2">
          <h4 id="name-leakage-from-the-authorizat">
<a href="#section-4.2.2" class="section-number selfRef">4.2.2. </a><a href="#name-leakage-from-the-authorizat" class="section-name selfRef">Leakage from the Authorization Server</a>
          </h4>
<p id="section-4.2.2-1">In a similar way, an attacker can learn <code>state</code> from the authorization
request if the authorization endpoint at the authorization server
contains links or third-party content as above.<a href="#section-4.2.2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="consequences">
<section id="section-4.2.3">
          <h4 id="name-consequences">
<a href="#section-4.2.3" class="section-number selfRef">4.2.3. </a><a href="#name-consequences" class="section-name selfRef">Consequences</a>
          </h4>
<p id="section-4.2.3-1">An attacker that learns a valid code or access token through a
Referer header can perform the attacks as described in Sections 
<a href="#insufficient_uri_validation_acg" class="auto internal xref">4.1.1</a>, <a href="#code_injection" class="auto internal xref">4.5</a> and
<a href="#access_token_injection" class="auto internal xref">4.6</a>. If the attacker learns <code>state</code>, the CSRF
protection achieved by using <code>state</code> is lost, resulting in CSRF
attacks as described in <span><a href="https://rfc-editor.org/rfc/rfc6819#section-4.4.1.8" class="relref">Section 4.4.1.8</a> of [<a href="#RFC6819" class="cite xref">RFC6819</a>]</span>.<a href="#section-4.2.3-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="countermeasures">
<section id="section-4.2.4">
          <h4 id="name-countermeasures-2">
<a href="#section-4.2.4" class="section-number selfRef">4.2.4. </a><a href="#name-countermeasures-2" class="section-name selfRef">Countermeasures</a>
          </h4>
<p id="section-4.2.4-1">The page rendered as a result of the OAuth authorization response and
the authorization endpoint <span class="bcp14">SHOULD NOT</span> include third-party resources or
links to external sites.<a href="#section-4.2.4-1" class="pilcrow">¶</a></p>
<p id="section-4.2.4-2">The following measures further reduce the chances of a successful attack:<a href="#section-4.2.4-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.2.4-3.1">Suppress the Referer header by applying an appropriate Referrer
Policy <span>[<a href="#W3C.webappsec-referrer-policy" class="cite xref">W3C.webappsec-referrer-policy</a>]</span> to the document (either as
part of the "referrer" meta attribute or by setting a
Referrer-Policy header). For example, the header <code>Referrer-Policy:
no-referrer</code> in the response completely suppresses the Referer
header in all requests originating from the resulting document.<a href="#section-4.2.4-3.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.2.4-3.2">Use authorization code instead of response types causing access
token issuance from the authorization endpoint.<a href="#section-4.2.4-3.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.2.4-3.3">Bind the authorization code to a confidential client or PKCE
challenge. In this case, the attacker lacks the secret to request
the code exchange.<a href="#section-4.2.4-3.3" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.2.4-3.4">
              <p id="section-4.2.4-3.4.1">As described in <span><a href="https://rfc-editor.org/rfc/rfc6749#section-4.1.2" class="relref">Section 4.1.2</a> of [<a href="#RFC6749" class="cite xref">RFC6749</a>]</span>, authorization codes
<span class="bcp14">MUST</span> be invalidated by the authorization server after their first use at the token
endpoint. For example, if an authorization server invalidated the code after the
legitimate client redeemed it, the attacker would fail to exchange
this code later.<a href="#section-4.2.4-3.4.1" class="pilcrow">¶</a></p>
<p id="section-4.2.4-3.4.2">This does not mitigate the attack if the attacker manages to
exchange the code for a token before the legitimate client does
so. Therefore, <span>[<a href="#RFC6749" class="cite xref">RFC6749</a>]</span> further recommends that, when an
attempt is made to redeem a code twice, the authorization server <span class="bcp14">SHOULD</span> revoke all
tokens issued previously based on that code.<a href="#section-4.2.4-3.4.2" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.2.4-3.5">
              <p id="section-4.2.4-3.5.1">The <code>state</code> value <span class="bcp14">SHOULD</span> be invalidated by the client after its
first use at the redirection endpoint. If this is implemented, and
an attacker receives a token through the Referer header from the
client's website, the <code>state</code> was already used, invalidated by
the client and cannot be used again by the attacker. (This does
not help if the <code>state</code> leaks from the
authorization server's website, since then the <code>state</code>
has not been used at the redirection endpoint at the client yet.)<a href="#section-4.2.4-3.5.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.2.4-3.6">
              <p id="section-4.2.4-3.6.1">Use the form post response mode instead of a redirect for the
authorization response (see <span>[<a href="#OAuth.Post" class="cite xref">OAuth.Post</a>]</span>).<a href="#section-4.2.4-3.6.1" class="pilcrow">¶</a></p>
</li>
          </ul>
</section>
</div>
</section>
</div>
<div id="browser_history">
<section id="section-4.3">
        <h3 id="name-credential-leakage-via-brow">
<a href="#section-4.3" class="section-number selfRef">4.3. </a><a href="#name-credential-leakage-via-brow" class="section-name selfRef">Credential Leakage via Browser History</a>
        </h3>
<p id="section-4.3-1">Authorization codes and access tokens can end up in the browser's
history of visited URLs, enabling the attacks described in the
following.<a href="#section-4.3-1" class="pilcrow">¶</a></p>
<div id="authorization-code-in-browser-history">
<section id="section-4.3.1">
          <h4 id="name-authorization-code-in-brows">
<a href="#section-4.3.1" class="section-number selfRef">4.3.1. </a><a href="#name-authorization-code-in-brows" class="section-name selfRef">Authorization Code in Browser History</a>
          </h4>
<p id="section-4.3.1-1">When a browser navigates to
<code>client.example/redirection_endpoint?code=abcd</code> as a result of a
redirect from a provider's authorization endpoint, the URL including
the authorization code may end up in the browser's history. An
attacker with access to the device could obtain the code and try to
replay it.<a href="#section-4.3.1-1" class="pilcrow">¶</a></p>
<p id="section-4.3.1-2">Countermeasures:<a href="#section-4.3.1-2" class="pilcrow">¶</a></p>
<ul class="compact">
<li class="compact" id="section-4.3.1-3.1">Authorization code replay prevention as described in <span><a href="https://rfc-editor.org/rfc/rfc6819#section-4.4.1.1" class="relref">Section 4.4.1.1</a> of [<a href="#RFC6819" class="cite xref">RFC6819</a>]</span>, and <a href="#code_injection" class="auto internal xref">Section 4.5</a>.<a href="#section-4.3.1-3.1" class="pilcrow">¶</a>
</li>
            <li class="compact" id="section-4.3.1-3.2">Use the form post response mode instead of redirect for the authorization
response (see <span>[<a href="#OAuth.Post" class="cite xref">OAuth.Post</a>]</span>).<a href="#section-4.3.1-3.2" class="pilcrow">¶</a>
</li>
          </ul>
</section>
</div>
<div id="access-token-in-browser-history">
<section id="section-4.3.2">
          <h4 id="name-access-token-in-browser-his">
<a href="#section-4.3.2" class="section-number selfRef">4.3.2. </a><a href="#name-access-token-in-browser-his" class="section-name selfRef">Access Token in Browser History</a>
          </h4>
<p id="section-4.3.2-1">An access token may end up in the browser history if a client or a website that already has a token deliberately navigates to a page like
<code>provider.com/get_user_profile?access_token=abcdef</code>. <span>[<a href="#RFC6750" class="cite xref">RFC6750</a>]</span>
discourages this practice and advises transferring tokens via a header,
but in practice websites often pass access tokens in query
parameters.<a href="#section-4.3.2-1" class="pilcrow">¶</a></p>
<p id="section-4.3.2-2">In the case of implicit grant, a URL like
<code>client.example/redirection_endpoint#access_token=abcdef</code> may also end
up in the browser history as a result of a redirect from a provider's
authorization endpoint.<a href="#section-4.3.2-2" class="pilcrow">¶</a></p>
<p id="section-4.3.2-3">Countermeasures:<a href="#section-4.3.2-3" class="pilcrow">¶</a></p>
<ul class="compact">
<li class="compact" id="section-4.3.2-4.1">Clients <span class="bcp14">MUST NOT</span> pass access tokens in a URI query parameter in
the way described in <span><a href="https://rfc-editor.org/rfc/rfc6750#section-2.3" class="relref">Section 2.3</a> of [<a href="#RFC6750" class="cite xref">RFC6750</a>]</span>. The authorization
code grant or alternative OAuth response modes like the form post
response mode <span>[<a href="#OAuth.Post" class="cite xref">OAuth.Post</a>]</span> can be used to
this end.<a href="#section-4.3.2-4.1" class="pilcrow">¶</a>
</li>
          </ul>
</section>
</div>
</section>
</div>
<div id="mix_up">
<section id="section-4.4">
        <h3 id="name-mix-up-attacks">
<a href="#section-4.4" class="section-number selfRef">4.4. </a><a href="#name-mix-up-attacks" class="section-name selfRef">Mix-Up Attacks</a>
        </h3>
<p id="section-4.4-1">Mix-up attacks can occur in scenarios where an OAuth client interacts with
two or more authorization servers and at least one authorization
server is under the control of the attacker. This can be the case,
for example, if the attacker uses dynamic registration to register the
client at their own authorization server or if an authorization server
becomes compromised.<a href="#section-4.4-1" class="pilcrow">¶</a></p>
<p id="section-4.4-2">The goal of the attack is to obtain an authorization code or an access
token for an uncompromised authorization server. This is achieved by
tricking the client into sending those credentials to the compromised
authorization server (the attacker) instead of using them at the
respective endpoint of the uncompromised authorization/resource
server.<a href="#section-4.4-2" class="pilcrow">¶</a></p>
<div id="attack-description">
<section id="section-4.4.1">
          <h4 id="name-attack-description">
<a href="#section-4.4.1" class="section-number selfRef">4.4.1. </a><a href="#name-attack-description" class="section-name selfRef">Attack Description</a>
          </h4>
<p id="section-4.4.1-1">The description here follows <span>[<a href="#arXiv.1601.01229" class="cite xref">arXiv.1601.01229</a>]</span>, with
variants of the attack outlined below.<a href="#section-4.4.1-1" class="pilcrow">¶</a></p>
<p id="section-4.4.1-2">Preconditions: For this variant of the attack to work, it is assumed that<a href="#section-4.4.1-2" class="pilcrow">¶</a></p>
<ul class="compact">
<li class="compact" id="section-4.4.1-3.1">the implicit or authorization code grant is used with multiple authorization servers
of which one is considered "honest" (H-AS) and one is operated by
the attacker (A-AS), and<a href="#section-4.4.1-3.1" class="pilcrow">¶</a>
</li>
            <li class="compact" id="section-4.4.1-3.2">the client stores the authorization server chosen by the user in a session bound to
the user's browser and uses the same redirection URI for
each authorization server.<a href="#section-4.4.1-3.2" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-4.4.1-4">In the following, it is further assumed that the client is registered with H-AS (URI:
<code>https://honest.as.example</code>, client ID: <code>7ZGZldHQ</code>) and with A-AS (URI:
<code>https://attacker.example</code>, client ID: <code>666RVZJTA</code>). URLs shown in the following
example are shortened for presentation to include only parameters relevant to the
attack.<a href="#section-4.4.1-4" class="pilcrow">¶</a></p>
<p id="section-4.4.1-5">Attack on the authorization code grant:<a href="#section-4.4.1-5" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.4.1-6">
<li id="section-4.4.1-6.1">The user selects to start the grant using A-AS (e.g., by clicking on a button on the
client's website).<a href="#section-4.4.1-6.1" class="pilcrow">¶</a>
</li>
            <li id="section-4.4.1-6.2">
<div id="step_2_mixup">The client stores in the user's session that the user selected
"A-AS" and redirects the user to A-AS's authorization endpoint
with a Location header containing the URL
<code>https://attacker.example/authorize?response_type=code&amp;client_id=666RVZJTA</code>.<a href="#step_2_mixup" class="pilcrow">¶</a>
</div>
            </li>
<li id="section-4.4.1-6.3">When the user's browser navigates to the attacker's authorization endpoint,
the attacker immediately redirects the browser to the authorization endpoint
of H-AS. In the authorization request, the attacker replaces the client ID
of the client at A-AS with the client's ID at H-AS. Therefore, the browser
receives a redirection (303 See Other) with a Location header pointing to
<code>https://honest.as.example/authorize?response_type=code&amp;client_id=7ZGZldHQ</code><a href="#section-4.4.1-6.3" class="pilcrow">¶</a>
</li>
            <li id="section-4.4.1-6.4">
<div id="step_4_mixup">
              <p id="section-4.4.1-6.4.1">The user authorizes the client to access their resources at H-AS. (Note that a
vigilant user might at this point detect that they intended to use A-AS
instead of H-AS. The first attack variant listed does not have this limitation.) H-AS
issues a code and sends it (via the browser) back to the client.<a href="#section-4.4.1-6.4.1" class="pilcrow">¶</a></p>
</div>
            </li>
<li id="section-4.4.1-6.5">
              <p id="section-4.4.1-6.5.1">Since the client still assumes that the code was issued by A-AS,
it will try to redeem the code at A-AS's token endpoint.<a href="#section-4.4.1-6.5.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.4.1-6.6">
              <p id="section-4.4.1-6.6.1">The attacker therefore obtains code and can either exchange the
code for an access token (for public clients) or perform an
authorization code injection attack as described in
<a href="#code_injection" class="auto internal xref">Section 4.5</a>.<a href="#section-4.4.1-6.6.1" class="pilcrow">¶</a></p>
</li>
          </ol>
<p id="section-4.4.1-7">Variants:<a href="#section-4.4.1-7" class="pilcrow">¶</a></p>
<ul class="compact">
<li class="compact" id="section-4.4.1-8.1">Mix-Up with Interception: This variant works only if the attacker can
intercept and manipulate the first request/response pair from a user's
browser to the client (in which the user selects a certain authorization server and is then
redirected by the client to that authorization server), as in <a href="#network_attackers" class="internal xref">Attacker (A2)</a> (see <a href="#secmodel" class="auto internal xref">Section 3</a>). This capability
can, for example, be the result of an attacker-in-the-middle attack on the user's
connection to the client. In the attack, the user starts the flow with H-AS.
The attacker intercepts this request and changes the user's selection to
A-AS. The rest of the attack proceeds as in <a href="#step_2_mixup" class="internal xref">Step 2</a> and following above.<a href="#section-4.4.1-8.1" class="pilcrow">¶</a>
</li>
            <li class="compact" id="section-4.4.1-8.2">Implicit Grant: In the implicit grant, the attacker receives an access
token instead of the code in <a href="#step_4_mixup" class="internal xref">Step 4</a>. The attacker's authorization server receives the access token
when the client makes either a request to the A-AS userinfo endpoint (defined in <span>[<a href="#OpenID.Core" class="cite xref">OpenID.Core</a>]</span>) or a request to the attacker's resource server (since the client believes it has completed the flow with A-AS).<a href="#section-4.4.1-8.2" class="pilcrow">¶</a>
</li>
            <li class="compact" id="section-4.4.1-8.3">Per-AS Redirect URIs: If clients use different redirection URIs for
different authorization servers, clients do not store the selected authorization server in the user's session, and authorization servers
do not check the redirection URIs properly, attackers can mount an attack
called "Cross Social-Network Request Forgery". These attacks have been
observed in practice. Refer to <span>[<a href="#research.jcs_14" class="cite xref">research.jcs_14</a>]</span> for details.<a href="#section-4.4.1-8.3" class="pilcrow">¶</a>
</li>
            <li class="compact" id="section-4.4.1-8.4">OpenID Connect: Some variants can be used to attack OpenID
Connect. In these attacks, the attacker misuses features of the OpenID
Connect Discovery <span>[<a href="#OpenID.Discovery" class="cite xref">OpenID.Discovery</a>]</span> mechanism or replays access tokens or ID
Tokens to conduct a mix-up attack. The attacks are described in detail in Appendix A of
<span>[<a href="#arXiv.1704.08539" class="cite xref">arXiv.1704.08539</a>]</span> and Section 6 of <span>[<a href="#arXiv.1508.04324v2" class="cite xref">arXiv.1508.04324v2</a>]</span> ("Malicious Endpoints Attacks").<a href="#section-4.4.1-8.4" class="pilcrow">¶</a>
</li>
          </ul>
</section>
</div>
<div id="mixupcountermeasures">
<section id="section-4.4.2">
          <h4 id="name-countermeasures-3">
<a href="#section-4.4.2" class="section-number selfRef">4.4.2. </a><a href="#name-countermeasures-3" class="section-name selfRef">Countermeasures</a>
          </h4>
<p id="section-4.4.2-1">When an OAuth client can only interact with one authorization server, a mix-up
defense is not required. In scenarios where an OAuth client interacts with two
or more authorization servers, however, clients <span class="bcp14">MUST</span> prevent mix-up attacks. Two
different methods are discussed below.<a href="#section-4.4.2-1" class="pilcrow">¶</a></p>
<p id="section-4.4.2-2">For both defenses, clients <span class="bcp14">MUST</span> store, for each authorization request, the
issuer they sent the authorization request to and bind this information to the
user agent. The issuer serves, via the associated metadata, as an abstract
identifier for the combination of the authorization endpoint and token endpoint
that are to be used in the flow. If an issuer identifier is not available (for
example, if neither OAuth Authorization Server Metadata <span>[<a href="#RFC8414" class="cite xref">RFC8414</a>]</span> nor OpenID Connect Discovery <span>[<a href="#OpenID.Discovery" class="cite xref">OpenID.Discovery</a>]</span> is
used), a different unique identifier for this tuple or the tuple itself can be
used instead. For brevity of presentation, such a deployment-specific identifier
will be subsumed under the issuer (or issuer identifier) in the following.<a href="#section-4.4.2-2" class="pilcrow">¶</a></p>
<p id="section-4.4.2-3">It is important to note that just storing the authorization server URL is not sufficient to identify
mix-up attacks. An attacker might declare an uncompromised authorization server's authorization endpoint URL as
"their" authorization server URL, but declare a token endpoint under their own control.<a href="#section-4.4.2-3" class="pilcrow">¶</a></p>
<div id="mix-up-defense-via-issuer-identification">
<section id="section-4.4.2.1">
            <h5 id="name-mix-up-defense-via-issuer-i">
<a href="#section-4.4.2.1" class="section-number selfRef">4.4.2.1. </a><a href="#name-mix-up-defense-via-issuer-i" class="section-name selfRef">Mix-Up Defense via Issuer Identification</a>
            </h5>
<p id="section-4.4.2.1-1">This defense requires that the authorization server sends its issuer identifier
in the authorization response to the client. When receiving the authorization
response, the client <span class="bcp14">MUST</span> compare the received issuer identifier to the stored
issuer identifier. If there is a mismatch, the client <span class="bcp14">MUST</span> abort the
interaction.<a href="#section-4.4.2.1-1" class="pilcrow">¶</a></p>
<p id="section-4.4.2.1-2">There are different ways this issuer identifier can be transported to the client:<a href="#section-4.4.2.1-2" class="pilcrow">¶</a></p>
<ul class="compact">
<li class="compact" id="section-4.4.2.1-3.1">The issuer information can be transported, for
example, via a separate response parameter <code>iss</code>, defined in
<span>[<a href="#RFC9207" class="cite xref">RFC9207</a>]</span>.<a href="#section-4.4.2.1-3.1" class="pilcrow">¶</a>
</li>
              <li class="compact" id="section-4.4.2.1-3.2">When OpenID Connect is used and an ID Token is returned in the authorization
response, the client can evaluate the <code>iss</code> claim in the ID Token.<a href="#section-4.4.2.1-3.2" class="pilcrow">¶</a>
</li>
            </ul>
<p id="section-4.4.2.1-4">In both cases, the <code>iss</code> value <span class="bcp14">MUST</span> be evaluated according to <span>[<a href="#RFC9207" class="cite xref">RFC9207</a>]</span>.<a href="#section-4.4.2.1-4" class="pilcrow">¶</a></p>
<p id="section-4.4.2.1-5">While this defense may require deploying new OAuth features to transport the
issuer information, it is a robust and relatively simple defense against mix-up.<a href="#section-4.4.2.1-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="mix-up-defense-via-distinct-redirect-uris">
<section id="section-4.4.2.2">
            <h5 id="name-mix-up-defense-via-distinct">
<a href="#section-4.4.2.2" class="section-number selfRef">4.4.2.2. </a><a href="#name-mix-up-defense-via-distinct" class="section-name selfRef">Mix-Up Defense via Distinct Redirect URIs</a>
            </h5>
<p id="section-4.4.2.2-1">For this defense, clients <span class="bcp14">MUST</span> use a distinct redirection URI for each issuer
they interact with.<a href="#section-4.4.2.2-1" class="pilcrow">¶</a></p>
<p id="section-4.4.2.2-2">Clients <span class="bcp14">MUST</span> check that the authorization response was received from the correct
issuer by comparing the distinct redirection URI for the issuer to the URI where
the authorization response was received on. If there is a mismatch, the client
<span class="bcp14">MUST</span> abort the flow.<a href="#section-4.4.2.2-2" class="pilcrow">¶</a></p>
<p id="section-4.4.2.2-3">While this defense builds upon existing OAuth functionality, it cannot be used
in scenarios where clients only register once for the use of many different
issuers (as in some open banking schemes) and due to the tight integration with
the client registration, it is harder to deploy automatically.<a href="#section-4.4.2.2-3" class="pilcrow">¶</a></p>
<p id="section-4.4.2.2-4">Furthermore, an attacker might be able to circumvent the protection offered by
this defense by registering a new client with the "honest" authorization server using the redirect
URI that the client assigned to the attacker's authorization server. The attacker could then run
the attack as described above, replacing the
client ID with the client ID of their newly created client.<a href="#section-4.4.2.2-4" class="pilcrow">¶</a></p>
<p id="section-4.4.2.2-5">This defense <span class="bcp14">SHOULD</span> therefore only be used if other options are not available.<a href="#section-4.4.2.2-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="code_injection">
<section id="section-4.5">
        <h3 id="name-authorization-code-injectio">
<a href="#section-4.5" class="section-number selfRef">4.5. </a><a href="#name-authorization-code-injectio" class="section-name selfRef">Authorization Code Injection</a>
        </h3>
<p id="section-4.5-1">An attacker who has gained access to an authorization code contained in an
authorization response (see <a href="#read_response" class="internal xref">Attacker (A3)</a> in <a href="#secmodel" class="auto internal xref">Section 3</a>) can try to redeem the
authorization code for an access token or otherwise make use of the
authorization code.<a href="#section-4.5-1" class="pilcrow">¶</a></p>
<p id="section-4.5-2">In the case that the authorization code was created for a public client, the
attacker can send the authorization code to the token endpoint of the
authorization server and thereby get an access token. This attack was described
in <span><a href="https://rfc-editor.org/rfc/rfc6819#section-4.4.1.1" class="relref">Section 4.4.1.1</a> of [<a href="#RFC6819" class="cite xref">RFC6819</a>]</span>.<a href="#section-4.5-2" class="pilcrow">¶</a></p>
<p id="section-4.5-3">For confidential clients, or in some special situations, the attacker can
execute an authorization code injection attack, as described in the following.<a href="#section-4.5-3" class="pilcrow">¶</a></p>
<p id="section-4.5-4">In an authorization code injection attack, the attacker attempts to inject a
stolen authorization code into the attacker's own session with the client. The
aim is to associate the attacker's session at the client with the victim's
resources or identity, thereby giving the attacker at least limited access to
the victim's resources.<a href="#section-4.5-4" class="pilcrow">¶</a></p>
<p id="section-4.5-5">Besides circumventing the client authentication of confidential clients, other
use cases for this attack include:<a href="#section-4.5-5" class="pilcrow">¶</a></p>
<ul class="compact">
<li class="compact" id="section-4.5-6.1">The attacker wants to access certain functions in this particular
client. As an example, the attacker wants to impersonate their
victim in a certain app or on a certain website.<a href="#section-4.5-6.1" class="pilcrow">¶</a>
</li>
          <li class="compact" id="section-4.5-6.2">The authorization or resource servers are limited to certain
networks that the attacker is unable to access directly.<a href="#section-4.5-6.2" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-4.5-7">Except in these special cases, authorization code injection is usually not
interesting when the code is created for a public client, as sending the code
to the token endpoint is a simpler and more powerful attack, as described above.<a href="#section-4.5-7" class="pilcrow">¶</a></p>
<div id="attack-description-1">
<section id="section-4.5.1">
          <h4 id="name-attack-description-2">
<a href="#section-4.5.1" class="section-number selfRef">4.5.1. </a><a href="#name-attack-description-2" class="section-name selfRef">Attack Description</a>
          </h4>
<p id="section-4.5.1-1">The authorization code injection attack works as follows:<a href="#section-4.5.1-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="compact type-1" id="section-4.5.1-2">
<li id="section-4.5.1-2.1">The attacker obtains an authorization code (see <a href="#read_response" class="internal xref">Attacker (A3)</a> in <a href="#secmodel" class="auto internal xref">Section 3</a>). For the rest
of the attack, only the capabilities of a web attacker <a href="#web_attackers" class="internal xref">(A1)</a> are required.<a href="#section-4.5.1-2.1" class="pilcrow">¶</a>
</li>
            <li id="section-4.5.1-2.2">
<div id="step_2_code_injection">From the attacker's device, the attacker starts a regular OAuth authorization
process with the legitimate client.<a href="#step_2_code_injection" class="pilcrow">¶</a>
</div>
            </li>
<li id="section-4.5.1-2.3">
<div id="step_3_code_injection">In the response of the authorization server to the legitimate client, the
attacker replaces the newly created authorization code with the stolen
authorization code. Since this response is passing through the attacker's
device, the attacker can use any tool that can intercept and manipulate the
authorization response to this end. The attacker does not need to control
the network.<a href="#step_3_code_injection" class="pilcrow">¶</a>
</div>
            </li>
<li id="section-4.5.1-2.4">The legitimate client sends the code to the authorization server's token
endpoint, along with the <code>redirect_uri</code> and the client's client ID and
client secret (or other means of client authentication).<a href="#section-4.5.1-2.4" class="pilcrow">¶</a>
</li>
            <li id="section-4.5.1-2.5">
<div id="checkin">The authorization server checks the client secret, whether the
code was issued to the particular client, and whether the actual
redirection URI matches the <code>redirect_uri</code> parameter (see
<span>[<a href="#RFC6749" class="cite xref">RFC6749</a>]</span>).<a href="#checkin" class="pilcrow">¶</a>
</div>
            </li>
<li id="section-4.5.1-2.6">All checks succeed and the authorization server issues access and
other tokens to the client. The attacker has now associated their
session with the legitimate client with the victim's resources
and/or identity.<a href="#section-4.5.1-2.6" class="pilcrow">¶</a>
</li>
          </ol>
</section>
</div>
<div id="discussion">
<section id="section-4.5.2">
          <h4 id="name-discussion">
<a href="#section-4.5.2" class="section-number selfRef">4.5.2. </a><a href="#name-discussion" class="section-name selfRef">Discussion</a>
          </h4>
<p id="section-4.5.2-1">Obviously, the check-in step (<a href="#checkin" class="internal xref">Step 5</a>) will fail if the code was issued to
another client ID, e.g., a client set up by the attacker. The check
will also fail if the authorization code was already redeemed by the
legitimate user and was one-time use only.<a href="#section-4.5.2-1" class="pilcrow">¶</a></p>
<p id="section-4.5.2-2">An attempt to inject a code obtained via a manipulated redirection URI
should also be detected if the authorization server stored the
complete redirection URI used in the authorization request and compares
it with the <code>redirect_uri</code> parameter.<a href="#section-4.5.2-2" class="pilcrow">¶</a></p>
<p id="section-4.5.2-3"><span><a href="https://rfc-editor.org/rfc/rfc6749#section-4.1.3" class="relref">Section 4.1.3</a> of [<a href="#RFC6749" class="cite xref">RFC6749</a>]</span> requires the authorization server to<a href="#section-4.5.2-3" class="pilcrow">¶</a></p>
<blockquote id="section-4.5.2-4">
      ensure that the "redirect_uri" parameter is present if the
      "redirect_uri" parameter was included in the initial authorization
      request as described in Section <a href="https://rfc-editor.org/rfc/rfc6749#section-4.1.1" class="relref">4.1.1</a>, and if included ensure that
      their values are identical.<a href="#section-4.5.2-4" class="pilcrow">¶</a>
</blockquote>
<p id="section-4.5.2-5">In the attack scenario described in <a href="#attack-description-1" class="auto internal xref">Section 4.5.1</a>, the legitimate
client would use the correct redirection URI it always uses for
authorization requests. But this URI would not match the tampered
redirection URI used by the attacker (otherwise, the redirect would not
land at the attacker's page). So, the authorization server would detect
the attack and refuse to exchange the code.<a href="#section-4.5.2-5" class="pilcrow">¶</a></p>
<p id="section-4.5.2-6">This check could also detect attempts to inject an authorization
code that had been obtained from another instance of the same client
on another device if certain conditions are fulfilled:<a href="#section-4.5.2-6" class="pilcrow">¶</a></p>
<ul class="compact">
<li class="compact" id="section-4.5.2-7.1">the redirection URI itself contains a nonce or another kind
of one-time use, secret data and<a href="#section-4.5.2-7.1" class="pilcrow">¶</a>
</li>
            <li class="compact" id="section-4.5.2-7.2">the client has bound this data to this particular instance of the
client.<a href="#section-4.5.2-7.2" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-4.5.2-8">But, this approach conflicts with the idea of enforcing exact redirect
URI matching at the authorization endpoint. Moreover, it has been
observed that providers very often ignore the <code>redirect_uri</code> check
requirement at this stage, maybe because it doesn't seem to be
security-critical from reading the specification.<a href="#section-4.5.2-8" class="pilcrow">¶</a></p>
<p id="section-4.5.2-9">Other providers just pattern match the <code>redirect_uri</code> parameter
against the registered redirection URI pattern. This saves the
authorization server from storing the link between the actual redirect
URI and the respective authorization code for every transaction. However,
this kind of check obviously does not fulfill the intent of the
specification, since the tampered redirection URI is not considered. So,
any attempt to inject an authorization code obtained using the
<code>client_id</code> of a legitimate client or by utilizing the legitimate
client on another device will not be detected in the respective
deployments.<a href="#section-4.5.2-9" class="pilcrow">¶</a></p>
<p id="section-4.5.2-10">It is also assumed that the requirements defined in <span><a href="https://rfc-editor.org/rfc/rfc6749#section-4.1.3" class="relref">Section 4.1.3</a> of [<a href="#RFC6749" class="cite xref">RFC6749</a>]</span> increase client implementation complexity as clients
need to store or reconstruct the correct redirection URI for the call
to the token endpoint.<a href="#section-4.5.2-10" class="pilcrow">¶</a></p>
<p id="section-4.5.2-11">Asymmetric methods for client authentication do not stop this attack, as the
legitimate client authenticates at the token endpoint.<a href="#section-4.5.2-11" class="pilcrow">¶</a></p>
<p id="section-4.5.2-12">This document therefore recommends instead binding every authorization
code to a certain client instance on a certain device (or in a certain
user agent) in the context of a certain transaction using one of the
mechanisms described next.<a href="#section-4.5.2-12" class="pilcrow">¶</a></p>
</section>
</div>
<div id="countermeasures-1">
<section id="section-4.5.3">
          <h4 id="name-countermeasures-4">
<a href="#section-4.5.3" class="section-number selfRef">4.5.3. </a><a href="#name-countermeasures-4" class="section-name selfRef">Countermeasures</a>
          </h4>
<p id="section-4.5.3-1">There are two good technical solutions to binding authorization codes to client
instances, as follows.<a href="#section-4.5.3-1" class="pilcrow">¶</a></p>
<div id="pkce_as_injection_protection">
<section id="section-4.5.3.1">
            <h5 id="name-pkce">
<a href="#section-4.5.3.1" class="section-number selfRef">4.5.3.1. </a><a href="#name-pkce" class="section-name selfRef">PKCE</a>
            </h5>
<p id="section-4.5.3.1-1">The PKCE mechanism specified in <span>[<a href="#RFC7636" class="cite xref">RFC7636</a>]</span> can be used as a countermeasure
(even though it was originally designed to secure native apps). When the
attacker attempts to inject an authorization code, the check of the
<code>code_verifier</code> fails: the client uses its correct verifier, but the code is
associated with a <code>code_challenge</code> that does not match this verifier.<a href="#section-4.5.3.1-1" class="pilcrow">¶</a></p>
<p id="section-4.5.3.1-2">PKCE not only protects against the authorization code injection attack but
also protects authorization codes created for public clients: PKCE ensures that
an attacker cannot redeem a stolen authorization code at the token endpoint of
the authorization server without knowledge of the <code>code_verifier</code>.<a href="#section-4.5.3.1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="nonce_as_injection_protection">
<section id="section-4.5.3.2">
            <h5 id="name-nonce">
<a href="#section-4.5.3.2" class="section-number selfRef">4.5.3.2. </a><a href="#name-nonce" class="section-name selfRef">Nonce</a>
            </h5>
<p id="section-4.5.3.2-1">OpenID Connect's existing <code>nonce</code> parameter can protect against authorization
code injection attacks. The <code>nonce</code> value is one-time use and is created by the
client. The client is supposed to bind it to the user agent session and send it
with the initial request to the OpenID Provider (OP). The OP puts the received <code>nonce</code> value into the ID Token that is issued
as part of the code exchange at the token endpoint. 

If an attacker injects an
authorization code in the authorization response, the nonce value in the client
session and the <code>nonce</code> value in the ID Token received from the token endpoint will not match, and the attack is
detected. The assumption is that an attacker cannot get hold of the user agent
state on the victim's device (from which the attacker has stolen the respective authorization
code).<a href="#section-4.5.3.2-1" class="pilcrow">¶</a></p>
<p id="section-4.5.3.2-2">It is important to note that this countermeasure only works if the client
properly checks the <code>nonce</code> parameter in the ID Token obtained from the token endpoint and does not use any
issued token until this check has succeeded. More precisely, a client protecting
itself against code injection using the <code>nonce</code> parameter<a href="#section-4.5.3.2-2" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="compact type-1" id="section-4.5.3.2-3">
<li id="section-4.5.3.2-3.1">
                <span class="bcp14">MUST</span> validate the <code>nonce</code> in the ID Token obtained from the token endpoint,
 even if another ID Token was obtained from the authorization response
 (e.g., <code>response_type=code+id_token</code>), and<a href="#section-4.5.3.2-3.1" class="pilcrow">¶</a>
</li>
              <li id="section-4.5.3.2-3.2">
                <span class="bcp14">MUST</span> ensure that, unless and until that check succeeds, all tokens (ID
 Tokens and the access token) are disregarded and not used for any other
 purpose.<a href="#section-4.5.3.2-3.2" class="pilcrow">¶</a>
</li>
            </ol>
<p id="section-4.5.3.2-4">It is important to note that <code>nonce</code> does not protect authorization codes of
public clients, as an attacker does not need to execute an authorization code
injection attack. Instead, an attacker can directly call the token endpoint with
the stolen authorization code.<a href="#section-4.5.3.2-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="other-solutions">
<section id="section-4.5.3.3">
            <h5 id="name-other-solutions">
<a href="#section-4.5.3.3" class="section-number selfRef">4.5.3.3. </a><a href="#name-other-solutions" class="section-name selfRef">Other Solutions</a>
            </h5>
<p id="section-4.5.3.3-1">Other solutions like binding <code>state</code> to the code, sender-constraining the code
using cryptographic means, or per-instance client credentials are
conceivable, but lack support and bring new security requirements.<a href="#section-4.5.3.3-1" class="pilcrow">¶</a></p>
<p id="section-4.5.3.3-2">PKCE is the most obvious solution for OAuth clients, as it is available
at the time of writing, while <code>nonce</code> is
appropriate for OpenID Connect clients.<a href="#section-4.5.3.3-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="limitations">
<section id="section-4.5.4">
          <h4 id="name-limitations">
<a href="#section-4.5.4" class="section-number selfRef">4.5.4. </a><a href="#name-limitations" class="section-name selfRef">Limitations</a>
          </h4>
<p id="section-4.5.4-1">An attacker can circumvent the countermeasures described above if they
can modify the <code>nonce</code> or <code>code_challenge</code> values that are used in the
victim's authorization request. The attacker can modify these values
to be the same ones as those chosen by the client in their own session
in <a href="#step_2_code_injection" class="internal xref">Step 2</a> of the attack above. (This requires that the victim's
session with the client begins after the attacker started their session
with the client.) If the attacker is then able to capture the
authorization code from the victim, the attacker will be able to
inject the stolen code in <a href="#step_3_code_injection" class="internal xref">Step 3</a> even if PKCE or <code>nonce</code> are used.<a href="#section-4.5.4-1" class="pilcrow">¶</a></p>
<p id="section-4.5.4-2">This attack is complex and requires a close interaction between the
attacker and the victim's session. Nonetheless, measures to prevent
attackers from reading the contents of the authorization response
still need to be taken, as described in Sections 
<a href="#insufficient_uri_validation" class="auto internal xref">4.1</a>, <a href="#credential_leakage_referrer" class="auto internal xref">4.2</a>,
<a href="#browser_history" class="auto internal xref">4.3</a>, <a href="#mix_up" class="auto internal xref">4.4</a>, and <a href="#open_redirection" class="auto internal xref">4.11</a>.<a href="#section-4.5.4-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="access_token_injection">
<section id="section-4.6">
        <h3 id="name-access-token-injection">
<a href="#section-4.6" class="section-number selfRef">4.6. </a><a href="#name-access-token-injection" class="section-name selfRef">Access Token Injection</a>
        </h3>
<p id="section-4.6-1">In an access token injection attack, the attacker attempts to inject a
stolen access token into a legitimate client (that is not under the
attacker's control). This will typically happen if the attacker wants
to utilize a leaked access token to impersonate a user in a certain
client.<a href="#section-4.6-1" class="pilcrow">¶</a></p>
<p id="section-4.6-2">To conduct the attack, the attacker starts an OAuth flow with the
client using the implicit grant and modifies the authorization
response by replacing the access token issued by the authorization
server or directly making up an authorization server response including
the leaked access token. Since the response includes the <code>state</code> value
generated by the client for this particular transaction, the client
does not treat the response as a CSRF attack and uses the access token
injected by the attacker.<a href="#section-4.6-2" class="pilcrow">¶</a></p>
<div id="countermeasures-2">
<section id="section-4.6.1">
          <h4 id="name-countermeasures-5">
<a href="#section-4.6.1" class="section-number selfRef">4.6.1. </a><a href="#name-countermeasures-5" class="section-name selfRef">Countermeasures</a>
          </h4>
<p id="section-4.6.1-1">There is no way to detect such an injection attack in pure-OAuth
flows since the token is issued without any binding to the
transaction or the particular user agent.<a href="#section-4.6.1-1" class="pilcrow">¶</a></p>
<p id="section-4.6.1-2">In OpenID Connect, the attack can be mitigated, as the authorization response
additionally contains an ID Token containing the <code>at_hash</code> claim. The attacker
therefore needs to replace both the access token as well as the ID Token in the
response. The attacker cannot forge the ID Token, as it is signed or encrypted
with authentication. The attacker also cannot inject a leaked ID Token matching
the stolen access token, as the <code>nonce</code> claim in the leaked ID Token will
contain (with a very high probability) a different value than the one expected
in the authorization response.<a href="#section-4.6.1-2" class="pilcrow">¶</a></p>
<p id="section-4.6.1-3">Note that further protection, like sender-constrained access tokens, is still
required to prevent attackers from using the access token at the resource
endpoint directly.<a href="#section-4.6.1-3" class="pilcrow">¶</a></p>
<p id="section-4.6.1-4">The recommendations in <a href="#implicit_grant_recommendation" class="auto internal xref">Section 2.1.2</a> follow from this.<a href="#section-4.6.1-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="csrf">
<section id="section-4.7">
        <h3 id="name-cross-site-request-forgery">
<a href="#section-4.7" class="section-number selfRef">4.7. </a><a href="#name-cross-site-request-forgery" class="section-name selfRef">Cross-Site Request Forgery</a>
        </h3>
<p id="section-4.7-1">An attacker might attempt to inject a request to the redirection URI of
the legitimate client on the victim's device, e.g., to cause the
client to access resources under the attacker's control. This is a
variant of an attack known as Cross-Site Request Forgery (CSRF).<a href="#section-4.7-1" class="pilcrow">¶</a></p>
<div id="csrf_countermeasures">
<section id="section-4.7.1">
          <h4 id="name-countermeasures-6">
<a href="#section-4.7.1" class="section-number selfRef">4.7.1. </a><a href="#name-countermeasures-6" class="section-name selfRef">Countermeasures</a>
          </h4>
<p id="section-4.7.1-1">The long-established countermeasure is that clients pass a random value, also
known as a CSRF Token, in the <code>state</code> parameter that links the request to
the redirection URI to the user agent session as described. This
countermeasure is described in detail in <span><a href="https://rfc-editor.org/rfc/rfc6819#section-5.3.5" class="relref">Section 5.3.5</a> of [<a href="#RFC6819" class="cite xref">RFC6819</a>]</span>. The
same protection is provided by PKCE or the OpenID Connect <code>nonce</code> value.<a href="#section-4.7.1-1" class="pilcrow">¶</a></p>
<p id="section-4.7.1-2">When using PKCE instead of <code>state</code> or <code>nonce</code> for CSRF protection, it is
important to note that:<a href="#section-4.7.1-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.7.1-3.1">
              <p id="section-4.7.1-3.1.1">Clients <span class="bcp14">MUST</span> ensure that the authorization server supports PKCE before using PKCE for
CSRF protection. If an authorization server does not support PKCE,
<code>state</code> or <code>nonce</code> <span class="bcp14">MUST</span> be used for CSRF protection.<a href="#section-4.7.1-3.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.7.1-3.2">
              <p id="section-4.7.1-3.2.1">If <code>state</code> is used for carrying application state, and the integrity of
its contents is a concern, clients <span class="bcp14">MUST</span> protect <code>state</code> against
tampering and swapping. This can be achieved by binding the
contents of state to the browser session and/or by signing/encrypting
state values. One example of this is discussed in the expired Internet-Draft <span>[<a href="#I-D.bradley-oauth-jwt-encoded-state" class="cite xref">JWT-ENCODED-STATE</a>]</span>.<a href="#section-4.7.1-3.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-4.7.1-4">The authorization server therefore <span class="bcp14">MUST</span> provide a way to detect their support for PKCE. Using Authorization Server Metadata according to <span>[<a href="#RFC8414" class="cite xref">RFC8414</a>]</span> is <span class="bcp14">RECOMMENDED</span>, but authorization servers <span class="bcp14">MAY</span> instead provide a
deployment-specific way to ensure or determine PKCE support.<a href="#section-4.7.1-4" class="pilcrow">¶</a></p>
<p id="section-4.7.1-5">PKCE provides robust protection against CSRF attacks even in the presence of an attacker that
can read the authorization response (see <a href="#read_response" class="internal xref">Attacker (A3)</a> in <a href="#secmodel" class="auto internal xref">Section 3</a>). When
<code>state</code> is used or an ID Token is returned in the authorization response (e.g.,
<code>response_type=code+id_token</code>), the attacker either learns the <code>state</code> value and
can replay it into the forged authorization response, or can extract the <code>nonce</code>
from the ID Token and use it in a new request to the authorization server to
mint an ID Token with the same <code>nonce</code>. The new ID Token can then be used for
the CSRF attack.<a href="#section-4.7.1-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="pkce-downgrade-attack">
<section id="section-4.8">
        <h3 id="name-pkce-downgrade-attack">
<a href="#section-4.8" class="section-number selfRef">4.8. </a><a href="#name-pkce-downgrade-attack" class="section-name selfRef">PKCE Downgrade Attack</a>
        </h3>
<p id="section-4.8-1">An authorization server that supports PKCE but does not make its use mandatory for
all flows can be susceptible to a PKCE downgrade attack.<a href="#section-4.8-1" class="pilcrow">¶</a></p>
<p id="section-4.8-2">The first prerequisite for this attack is that there is an attacker-controllable
flag in the authorization request that enables or disables PKCE for the
particular flow. The presence or absence of the <code>code_challenge</code> parameter lends
itself for this purpose, i.e., the authorization server enables and enforces PKCE if this
parameter is present in the authorization request, but it does not enforce PKCE if
the parameter is missing.<a href="#section-4.8-2" class="pilcrow">¶</a></p>
<p id="section-4.8-3">The second prerequisite for this attack is that the client is not using <code>state</code>
at all (e.g., because the client relies on PKCE for CSRF prevention) or that the
client is not checking <code>state</code> correctly.<a href="#section-4.8-3" class="pilcrow">¶</a></p>
<p id="section-4.8-4">Roughly speaking, this attack is a variant of a CSRF attack. The attacker
achieves the same goal as in the attack described in <a href="#csrf" class="auto internal xref">Section 4.7</a>: The attacker injects an
authorization code (and with that, an access token) that is bound to the attacker's
resources into a session between their victim and the client.<a href="#section-4.8-4" class="pilcrow">¶</a></p>
<div id="attack-description-2">
<section id="section-4.8.1">
          <h4 id="name-attack-description-3">
<a href="#section-4.8.1" class="section-number selfRef">4.8.1. </a><a href="#name-attack-description-3" class="section-name selfRef">Attack Description</a>
          </h4>
<ol start="1" type="1" class="compact type-1" id="section-4.8.1-1">
<li id="section-4.8.1-1.1">The user has started an OAuth session using some client at an authorization server. In the
authorization request, the client has set the parameter
<code>code_challenge=hash(abc)</code> as the PKCE code challenge (with the hash function and parameter encoding as defined in <span>[<a href="#RFC7636" class="cite xref">RFC7636</a>]</span>). The client is now
waiting to receive the authorization response from the user's browser.<a href="#section-4.8.1-1.1" class="pilcrow">¶</a>
</li>
            <li id="section-4.8.1-1.2">To conduct the attack, the attacker uses their own device to start an
authorization flow with the targeted client. The client now uses another
PKCE code challenge, say, <code>code_challenge=hash(xyz)</code>, in the authorization
request. The attacker intercepts the request and removes the entire
<code>code_challenge</code> parameter from the request. Since this step is performed on
the attacker's device, the attacker has full access to the request contents,
for example, using browser debug tools.<a href="#section-4.8.1-1.2" class="pilcrow">¶</a>
</li>
            <li id="section-4.8.1-1.3">If the authorization server allows for flows without PKCE, it will create a
code that is not bound to any PKCE code challenge.<a href="#section-4.8.1-1.3" class="pilcrow">¶</a>
</li>
            <li id="section-4.8.1-1.4">The attacker now redirects the user's browser to an authorization response
URL that contains the code for the attacker's session with the authorization server.<a href="#section-4.8.1-1.4" class="pilcrow">¶</a>
</li>
            <li id="section-4.8.1-1.5">The user's browser sends the authorization code to the client, which will
now try to redeem the code for an access token at the authorization server. The client will
send <code>code_verifier=abc</code> as the PKCE code verifier in the token request.<a href="#section-4.8.1-1.5" class="pilcrow">¶</a>
</li>
            <li id="section-4.8.1-1.6">Since the authorization server sees that this code is not bound to any PKCE
code challenge, it will not check the presence or contents of the
<code>code_verifier</code> parameter. It will issue an access token (which belongs to the
attacker's resource) to the client under the user's control.<a href="#section-4.8.1-1.6" class="pilcrow">¶</a>
</li>
          </ol>
</section>
</div>
<div id="pkce_downgrade_countermeasures">
<section id="section-4.8.2">
          <h4 id="name-countermeasures-7">
<a href="#section-4.8.2" class="section-number selfRef">4.8.2. </a><a href="#name-countermeasures-7" class="section-name selfRef">Countermeasures</a>
          </h4>
<p id="section-4.8.2-1">Using <code>state</code> properly would prevent this attack. However, practice has shown
that many OAuth clients do not use or check <code>state</code> properly.<a href="#section-4.8.2-1" class="pilcrow">¶</a></p>
<p id="section-4.8.2-2">Therefore, authorization servers <span class="bcp14">MUST</span> mitigate this attack.<a href="#section-4.8.2-2" class="pilcrow">¶</a></p>
<p id="section-4.8.2-3">Note that from the view of the authorization server, in the attack described above, a
<code>code_verifier</code> parameter is received at the token endpoint although no
<code>code_challenge</code> parameter was present in the authorization request for the
OAuth flow in which the authorization code was issued.<a href="#section-4.8.2-3" class="pilcrow">¶</a></p>
<p id="section-4.8.2-4">This fact can be used to mitigate this attack. <span>[<a href="#RFC7636" class="cite xref">RFC7636</a>]</span> already mandates that<a href="#section-4.8.2-4" class="pilcrow">¶</a></p>
<ul class="compact">
<li class="compact" id="section-4.8.2-5.1">an authorization server that supports PKCE <span class="bcp14">MUST</span> check whether a code challenge is contained in
the authorization request and bind this information to the code that is
issued; and<a href="#section-4.8.2-5.1" class="pilcrow">¶</a>
</li>
            <li class="compact" id="section-4.8.2-5.2">when a code arrives at the token endpoint, and there was a <code>code_challenge</code>
in the authorization request for which this code was issued, there must be a
valid <code>code_verifier</code> in the token request.<a href="#section-4.8.2-5.2" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-4.8.2-6">Beyond this, to prevent PKCE downgrade attacks, the authorization server <span class="bcp14">MUST</span> ensure that
if there was no <code>code_challenge</code> in the authorization request, a request to
the token endpoint containing a <code>code_verifier</code> is rejected.<a href="#section-4.8.2-6" class="pilcrow">¶</a></p>
<p id="section-4.8.2-7">Authorization servers that mandate the use of PKCE (in general or for particular clients)
implicitly implement this security measure.<a href="#section-4.8.2-7" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="access_token_leakage">
<section id="section-4.9">
        <h3 id="name-access-token-leakage-at-the">
<a href="#section-4.9" class="section-number selfRef">4.9. </a><a href="#name-access-token-leakage-at-the" class="section-name selfRef">Access Token Leakage at the Resource Server</a>
        </h3>
<p id="section-4.9-1">Access tokens can leak from a resource server under certain
circumstances.<a href="#section-4.9-1" class="pilcrow">¶</a></p>
<div id="counterfeit_res_server">
<section id="section-4.9.1">
          <h4 id="name-access-token-phishing-by-co">
<a href="#section-4.9.1" class="section-number selfRef">4.9.1. </a><a href="#name-access-token-phishing-by-co" class="section-name selfRef">Access Token Phishing by Counterfeit Resource Server</a>
          </h4>
<p id="section-4.9.1-1">An attacker may set up their own resource server and trick a client into
sending access tokens to it that are valid for other resource servers
(see Attackers <a href="#web_attackers" class="internal xref">(A1)</a> and  <a href="#acquire_token" class="internal xref">(A5)</a> in <a href="#secmodel" class="auto internal xref">Section 3</a>). If the client sends a valid access token to
this counterfeit resource server, the attacker in turn may use that
token to access other services on behalf of the resource owner.<a href="#section-4.9.1-1" class="pilcrow">¶</a></p>
<p id="section-4.9.1-2">This attack assumes the client is not bound to one specific resource
server (and its URL) at development time, but client instances are
provided with the resource server URL at runtime. 

This kind of late
binding is typical in situations where the client uses a service
implementing a standardized API (e.g., for email, calendaring, eHealth,
or open banking) and where the client is configured by a user or
administrator.<a href="#section-4.9.1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="comp_res_server">
<section id="section-4.9.2">
          <h4 id="name-compromised-resource-server">
<a href="#section-4.9.2" class="section-number selfRef">4.9.2. </a><a href="#name-compromised-resource-server" class="section-name selfRef">Compromised Resource Server</a>
          </h4>
<p id="section-4.9.2-1">An attacker may compromise a resource server to gain access to the
resources of the respective deployment. Such a compromise may range
from partial access to the system, e.g., its log files, to full
control over the respective server, in which case all controls can be
circumvented and all resources can be
accessed. The attacker would also be able to obtain other access
tokens held on the compromised system that would potentially be valid
to access other resource servers.<a href="#section-4.9.2-1" class="pilcrow">¶</a></p>
<p id="section-4.9.2-2">Preventing server breaches by hardening and monitoring server systems
is considered a standard operational procedure and, therefore, out of
the scope of this document. 

<a href="#access_token_leakage" class="auto internal xref">Section 4.9</a> focuses on the impact of
OAuth-related breaches and the replaying of captured access tokens.<a href="#section-4.9.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="countermeasures-3">
<section id="section-4.9.3">
          <h4 id="name-countermeasures-8">
<a href="#section-4.9.3" class="section-number selfRef">4.9.3. </a><a href="#name-countermeasures-8" class="section-name selfRef">Countermeasures</a>
          </h4>
<p id="section-4.9.3-1">The following measures should be taken into account by implementers in
order to cope with access token replay by malicious actors:<a href="#section-4.9.3-1" class="pilcrow">¶</a></p>
<ul class="compact">
<li class="compact" id="section-4.9.3-2.1">Sender-constrained access tokens, as described in <a href="#pop_tokens" class="auto internal xref">Section 4.10.1</a>,
<span class="bcp14">SHOULD</span> be used to prevent the attacker from replaying the access
tokens on other resource servers. If an attacker has only partial
access to the compromised system, like a read-only access to web
server logs, sender-constrained access tokens may also prevent
replay on the compromised system.<a href="#section-4.9.3-2.1" class="pilcrow">¶</a>
</li>
            <li class="compact" id="section-4.9.3-2.2">Audience restriction as described in <a href="#aud_restriction" class="auto internal xref">Section 4.10.2</a> <span class="bcp14">SHOULD</span> be
used to prevent replay of captured access tokens on other resource
servers.<a href="#section-4.9.3-2.2" class="pilcrow">¶</a>
</li>
            <li class="compact" id="section-4.9.3-2.3">The resource server <span class="bcp14">MUST</span> treat access tokens like other sensitive secrets
and not store or transfer them in plaintext.<a href="#section-4.9.3-2.3" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-4.9.3-3">The first and second recommendations also apply to other scenarios
where access tokens leak (see <a href="#acquire_token" class="internal xref">Attacker (A5)</a> in <a href="#secmodel" class="auto internal xref">Section 3</a>).<a href="#section-4.9.3-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="misuse-of-stolen-access-tokens">
<section id="section-4.10">
        <h3 id="name-misuse-of-stolen-access-tok">
<a href="#section-4.10" class="section-number selfRef">4.10. </a><a href="#name-misuse-of-stolen-access-tok" class="section-name selfRef">Misuse of Stolen Access Tokens</a>
        </h3>
<p id="section-4.10-1">Access tokens can be stolen by an attacker in various ways, for example,
via the attacks described in Sections <a href="#insufficient_uri_validation" class="auto internal xref">4.1</a>,
<a href="#credential_leakage_referrer" class="auto internal xref">4.2</a>, <a href="#browser_history" class="auto internal xref">4.3</a>, <a href="#mix_up" class="auto internal xref">4.4</a>, and
<a href="#access_token_leakage" class="auto internal xref">4.9</a>. Some of these attacks can be mitigated by
specific security measures, as described in the respective sections.
However, in some cases, these measures are not sufficient or are not
implemented correctly. Authorization servers therefore <span class="bcp14">SHOULD</span> ensure that
access tokens are sender-constrained and audience-restricted as described
in the following. Architecture and performance reasons may
prevent the use of these measures in some deployments.<a href="#section-4.10-1" class="pilcrow">¶</a></p>
<div id="pop_tokens">
<section id="section-4.10.1">
          <h4 id="name-sender-constrained-access-t">
<a href="#section-4.10.1" class="section-number selfRef">4.10.1. </a><a href="#name-sender-constrained-access-t" class="section-name selfRef">Sender-Constrained Access Tokens</a>
          </h4>
<p id="section-4.10.1-1">As the name suggests, sender-constrained access tokens scope the
applicability of an access token to a certain sender. This sender is
obliged to demonstrate knowledge of a certain secret as a prerequisite
for the acceptance of that token at a resource server.<a href="#section-4.10.1-1" class="pilcrow">¶</a></p>
<p id="section-4.10.1-2">A typical flow looks like this:<a href="#section-4.10.1-2" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="compact type-1" id="section-4.10.1-3">
<li id="section-4.10.1-3.1">The authorization server associates data with the access token
that binds this particular token to a certain client. The binding
can utilize the client's identity, but in most cases, the authorization server utilizes
key material (or data derived from the key material) known to the
client.<a href="#section-4.10.1-3.1" class="pilcrow">¶</a>
</li>
            <li id="section-4.10.1-3.2">This key material must be distributed somehow. Either the key
material already exists before the authorization server creates the binding or the
authorization server creates ephemeral keys. The way preexisting key material is
distributed varies among the different approaches. For example,
X.509 certificates can be used, in which case the distribution
happens explicitly during the enrollment process. Or, the key
material is created and distributed at the TLS layer, in which
case it might automatically happen during the setup of a TLS
connection.<a href="#section-4.10.1-3.2" class="pilcrow">¶</a>
</li>
            <li id="section-4.10.1-3.3">The resource server must implement the actual proof-of-possession check. This
is typically done on the application level, often tied to specific
material provided by the transport layer (e.g., TLS). The resource server must also
ensure that a replay of the proof of possession is not possible.<a href="#section-4.10.1-3.3" class="pilcrow">¶</a>
</li>
          </ol>
<p id="section-4.10.1-4">Two methods for sender-constrained access tokens using proof of possession have
been defined by the OAuth working group and are in use in practice:<a href="#section-4.10.1-4" class="pilcrow">¶</a></p>
<ul class="compact">
<li class="compact" id="section-4.10.1-5.1">"OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound
Access Tokens" <span>[<a href="#RFC8705" class="cite xref">RFC8705</a>]</span>: The approach specified in this)
document allows the use of mutual TLS for both client
authentication and sender-constrained access tokens. For the
purpose of sender-constrained access tokens, the client is
identified towards the resource server by the fingerprint of its
public key. During the processing of an access token request, the
authorization server obtains the client's public key from the TLS
stack and associates its fingerprint with the respective access
tokens. The resource server in the same way obtains the public key
from the TLS stack and compares its fingerprint with the
fingerprint associated with the access token.<a href="#section-4.10.1-5.1" class="pilcrow">¶</a>
</li>
            <li class="compact" id="section-4.10.1-5.2">"OAuth 2.0 Demonstrating Proof of Possession (DPoP)" <span>[<a href="#RFC9449" class="cite xref">RFC9449</a>]</span>:

DPoP outlines an
application-level mechanism for sender-constraining access and refresh
tokens. It uses
proof-of-possession based on a public/private key pair and
application-level signing. DPoP can be used with public clients
and, in the case of confidential clients, can be combined with any
client authentication method.<a href="#section-4.10.1-5.2" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-4.10.1-6">Note that the security of sender-constrained tokens is undermined when
an attacker gets access to the token and the key material. This is, in
particular, the case for corrupted client software and cross-site
scripting attacks (when the client is running in the browser). If the
key material is protected in a hardware or software security module or
only indirectly accessible (like in a TLS stack), sender-constrained
tokens at least protect against the use of the token when the client is
offline, i.e., when the security module or interface is not available
to the attacker. This applies to access tokens as well as to refresh
tokens (see <a href="#refresh_token_protection" class="auto internal xref">Section 4.14</a>).<a href="#section-4.10.1-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="aud_restriction">
<section id="section-4.10.2">
          <h4 id="name-audience-restricted-access-">
<a href="#section-4.10.2" class="section-number selfRef">4.10.2. </a><a href="#name-audience-restricted-access-" class="section-name selfRef">Audience-Restricted Access Tokens</a>
          </h4>
<p id="section-4.10.2-1">Audience restriction essentially restricts access tokens to a
particular resource server. The authorization server associates the
access token with the particular resource server, and the resource
server is then supposed to verify the intended audience. If the access token fails
the intended audience validation, the resource server refuses to
serve the respective request.<a href="#section-4.10.2-1" class="pilcrow">¶</a></p>
<p id="section-4.10.2-2">In general, audience restriction limits the impact of token leakage.
In the case of a counterfeit resource server, it may (as described
below) also prevent abuse of the phished access token at the
legitimate resource server.<a href="#section-4.10.2-2" class="pilcrow">¶</a></p>
<p id="section-4.10.2-3">The audience can be expressed using logical names or
physical addresses (like URLs). To prevent phishing, it is
necessary to use the actual URL the client will send requests to. In
the phishing case, this URL will point to the counterfeit resource
server. If the attacker tries to use the access token at the
legitimate resource server (which has a different URL), the resource
server will detect the mismatch (wrong audience) and refuse to serve
the request.<a href="#section-4.10.2-3" class="pilcrow">¶</a></p>
<p id="section-4.10.2-4">In deployments where the authorization server knows the URLs of all
resource servers, the authorization server may just refuse to issue
access tokens for unknown resource server URLs.<a href="#section-4.10.2-4" class="pilcrow">¶</a></p>
<p id="section-4.10.2-5">For this to work, the client needs to tell the authorization server the intended
resource server. The mechanism in <span>[<a href="#RFC8707" class="cite xref">RFC8707</a>]</span> can be used for this or the
information can be encoded in the scope value (<span><a href="https://rfc-editor.org/rfc/rfc6749#section-3.3" class="relref">Section 3.3</a> of [<a href="#RFC6749" class="cite xref">RFC6749</a>]</span>).<a href="#section-4.10.2-5" class="pilcrow">¶</a></p>
<p id="section-4.10.2-6">Instead of the URL, it is also possible to utilize the fingerprint of
the resource server's X.509 certificate as the audience value. This
variant would also allow detection of an attempt to spoof the legitimate
resource server's URL by using a valid TLS certificate obtained from a
different CA. It might also be considered a privacy benefit to hide
the resource server URL from the authorization server.<a href="#section-4.10.2-6" class="pilcrow">¶</a></p>
<p id="section-4.10.2-7">Audience restriction may seem easier to use since it does not require
any cryptography on the client side. Still, since every access token is
bound to a specific resource server, the client also needs to obtain a
single resource server-specific access token when accessing several resource
servers. (Resource indicators, as specified in
<span>[<a href="#RFC8707" class="cite xref">RFC8707</a>]</span>, can help to achieve this.)
<span>[<a href="#I-D.ietf-oauth-token-binding" class="cite xref">TOKEN-BINDING</a>]</span> had the same property since different
token-binding IDs must be associated with the access token. Using
mutual TLS for OAuth 2.0 <span>[<a href="#RFC8705" class="cite xref">RFC8705</a>]</span>, on the other hand, allows a client to use the
access token at multiple resource servers.<a href="#section-4.10.2-7" class="pilcrow">¶</a></p>
<p id="section-4.10.2-8">It should be noted that audience restrictions -- or, generally speaking, an
indication by the client to the authorization server where it wants to
use the access token -- have additional benefits beyond the scope of
token leakage prevention. They allow the authorization server to create
a different access token whose format and content are specifically minted
for the respective server. This has huge functional and privacy
advantages in deployments using structured access tokens.<a href="#section-4.10.2-8" class="pilcrow">¶</a></p>
</section>
</div>
<div id="discussion-preventing-leakage-via-metadata">
<section id="section-4.10.3">
          <h4 id="name-discussion-preventing-leaka">
<a href="#section-4.10.3" class="section-number selfRef">4.10.3. </a><a href="#name-discussion-preventing-leaka" class="section-name selfRef">Discussion: Preventing Leakage via Metadata</a>
          </h4>
<p id="section-4.10.3-1">An authorization server could provide the client with additional
information about the locations where it is safe to use its access
tokens. This approach, and why it is not recommended, is discussed in
the following.<a href="#section-4.10.3-1" class="pilcrow">¶</a></p>
<p id="section-4.10.3-2">In the simplest form, this would require the authorization server to publish a list of
its known resource servers, illustrated in the following example using
a non-standard Authorization Server Metadata parameter <code>resource_servers</code>:<a href="#section-4.10.3-2" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-4.10.3-3">
<pre>
HTTP/1.1 200 OK
Content-Type: application/json

{
  "issuer":"https://server.somesite.example",
  "authorization_endpoint":
    "https://server.somesite.example/authorize",
  "resource_servers":[
    "email.somesite.example",
    "storage.somesite.example",
    "video.somesite.example"
  ]
  ...
}
</pre><a href="#section-4.10.3-3" class="pilcrow">¶</a>
</div>
<p id="section-4.10.3-4">The authorization server could also return the URL(s) an access token is good for in the
token response, illustrated by the example and non-standard return
parameter <code>access_token_resource_server</code>:<a href="#section-4.10.3-4" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-4.10.3-5">
<pre>
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
  "access_token":"2YotnFZFEjr1zCsicMWpAA",
  "access_token_resource_server":
    "https://hostedresource.somesite.example/path1",
...
}
</pre><a href="#section-4.10.3-5" class="pilcrow">¶</a>
</div>
<p id="section-4.10.3-6">This mitigation strategy would rely on the client to enforce the
security policy and to only send access tokens to legitimate
destinations. Results of OAuth-related security research (see, for
example, <span>[<a href="#research.ubc" class="cite xref">research.ubc</a>]</span> and <span>[<a href="#research.cmu" class="cite xref">research.cmu</a>]</span>) indicate a
large portion of client implementations do not or fail to properly
implement security controls, like <code>state</code> checks. So, relying on
clients to prevent access token phishing is likely to fail as well.
   Moreover, given the ratio of clients to authorization and resource servers, 
   it is considered the more viable approach to move as much as possible
   security-related logic to those servers.
Clearly, the client
has to contribute to the overall security. However, there are alternative
countermeasures, as described in Sections <a href="#pop_tokens" class="auto internal xref">4.10.1</a> and <a href="#aud_restriction" class="auto internal xref">4.10.2</a>, that provide a
better balance between the involved parties.<a href="#section-4.10.3-6" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="open_redirection">
<section id="section-4.11">
        <h3 id="name-open-redirection">
<a href="#section-4.11" class="section-number selfRef">4.11. </a><a href="#name-open-redirection" class="section-name selfRef">Open Redirection</a>
        </h3>
<p id="section-4.11-1">The following attacks can occur when an authorization server or client has an open redirector. Such endpoints are sometimes implemented,
for example, to show a message before a user is then redirected to an external
website, or to redirect users back to a URL they were intending to visit before
being interrupted, e.g., by a login prompt.<a href="#section-4.11-1" class="pilcrow">¶</a></p>
<div id="open_redirector_on_client">
<section id="section-4.11.1">
          <h4 id="name-client-as-open-redirector">
<a href="#section-4.11.1" class="section-number selfRef">4.11.1. </a><a href="#name-client-as-open-redirector" class="section-name selfRef">Client as Open Redirector</a>
          </h4>
<p id="section-4.11.1-1">Clients <span class="bcp14">MUST NOT</span> expose open redirectors. Attackers may use open
redirectors to produce URLs pointing to the client and utilize them to
exfiltrate authorization codes and access tokens, as described in
<a href="#redir_uri_open_redir" class="auto internal xref">Section 4.1.2</a>. Another abuse case is to produce URLs that
appear to point to the client. This might trick users into trusting the URL
and following it in their browser. This can be abused for phishing.<a href="#section-4.11.1-1" class="pilcrow">¶</a></p>
<p id="section-4.11.1-2">In order to prevent open redirection, clients should only redirect if
the target URLs are allowed or if the origin and integrity of a
request can be authenticated. Countermeasures against open redirection
are described by OWASP <span>[<a href="#owasp.redir" class="cite xref">owasp.redir</a>]</span>.<a href="#section-4.11.1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="authorization-server-as-open-redirector">
<section id="section-4.11.2">
          <h4 id="name-authorization-server-as-ope">
<a href="#section-4.11.2" class="section-number selfRef">4.11.2. </a><a href="#name-authorization-server-as-ope" class="section-name selfRef">Authorization Server as Open Redirector</a>
          </h4>
<p id="section-4.11.2-1">Just as with clients, attackers could try to utilize a user's trust in
the authorization server (and its URL in particular) for performing
phishing attacks. OAuth authorization servers regularly redirect users
to other websites (the clients), but they must do so safely.<a href="#section-4.11.2-1" class="pilcrow">¶</a></p>
<p id="section-4.11.2-2"><span><a href="https://rfc-editor.org/rfc/rfc6749#section-4.1.2.1" class="relref">Section 4.1.2.1</a> of [<a href="#RFC6749" class="cite xref">RFC6749</a>]</span> already prevents open redirects by
stating that the authorization server <span class="bcp14">MUST NOT</span> automatically redirect the user agent in case
of an invalid combination of <code>client_id</code> and <code>redirect_uri</code>.<a href="#section-4.11.2-2" class="pilcrow">¶</a></p>
<p id="section-4.11.2-3">However, an attacker could also utilize a correctly registered
redirection URI to perform phishing attacks. The attacker could, for
example, register a client via dynamic client registration <span>[<a href="#RFC7591" class="cite xref">RFC7591</a>]</span>
and execute one of the following attacks:<a href="#section-4.11.2-3" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="compact type-1" id="section-4.11.2-4">
<li id="section-4.11.2-4.1">Intentionally send an erroneous authorization request, e.g., by using an
invalid scope value, thus instructing the authorization server to redirect
the user agent to its phishing site.<a href="#section-4.11.2-4.1" class="pilcrow">¶</a>
</li>
            <li id="section-4.11.2-4.2">Intentionally send a valid authorization request with <code>client_id</code> and
<code>redirect_uri</code> controlled by the attacker. After the user authenticates, the
authorization server prompts the user to provide consent to the request. If
the user notices an issue with the request and declines the request, the
authorization server still redirects the user agent to the phishing site. In
this case, the user agent will be redirected to the phishing site regardless
of the action taken by the user.<a href="#section-4.11.2-4.2" class="pilcrow">¶</a>
</li>
            <li id="section-4.11.2-4.3">Intentionally send a valid silent authentication request (<code>prompt=none</code>)
with <code>client_id</code> and <code>redirect_uri</code> controlled by the attacker. In this
case, the authorization server will automatically redirect the user agent to
the phishing site.<a href="#section-4.11.2-4.3" class="pilcrow">¶</a>
</li>
          </ol>
<p id="section-4.11.2-5">The authorization server <span class="bcp14">MUST</span> take precautions to prevent these threats. The authorization server <span class="bcp14">MUST</span> always
authenticate the user first and, with the exception of the silent authentication
use case, prompt the user for credentials when needed, before redirecting the
user. Based on its risk assessment, the authorization server needs to decide whether or not it can trust
the redirection URI. It could take into account  URI analytics done
internally or through some external service to evaluate the credibility and
trustworthiness of content behind the URI, and the source of the redirection URI and
other client data.<a href="#section-4.11.2-5" class="pilcrow">¶</a></p>
<p id="section-4.11.2-6">The authorization server <span class="bcp14">SHOULD</span> only automatically redirect the user agent if it trusts the
redirection URI.  If the URI is not trusted, the authorization server <span class="bcp14">MAY</span> inform the user and rely on
the user to make the correct decision.<a href="#section-4.11.2-6" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="redirect_307">
<section id="section-4.12">
        <h3 id="name-307-redirect">
<a href="#section-4.12" class="section-number selfRef">4.12. </a><a href="#name-307-redirect" class="section-name selfRef">307 Redirect</a>
        </h3>
<p id="section-4.12-1">At the authorization endpoint, a typical protocol flow is that the authorization server
prompts the user to enter their credentials in a form that is then
submitted (using the HTTP POST method) back to the authorization
server. The authorization server checks the credentials and, if successful, redirects
the user agent to the client's redirection endpoint.<a href="#section-4.12-1" class="pilcrow">¶</a></p>
<p id="section-4.12-2">In <span>[<a href="#RFC6749" class="cite xref">RFC6749</a>]</span>, the HTTP status code 302 (Found) is used for this purpose, but
"any other method available via the user-agent to accomplish this
redirection is allowed". When the status code 307 is used for
redirection instead, the user agent will send the user's credentials via
HTTP POST to the client.<a href="#section-4.12-2" class="pilcrow">¶</a></p>
<p id="section-4.12-3">This discloses the sensitive credentials to the client. If the client
is malicious, it can use the credentials to impersonate the user
at the authorization server.<a href="#section-4.12-3" class="pilcrow">¶</a></p>
<p id="section-4.12-4">The behavior might be unexpected for developers but is defined in
<span><a href="https://rfc-editor.org/rfc/rfc9110#section-15.4.8" class="relref">Section 15.4.8</a> of [<a href="#RFC9110" class="cite xref">RFC9110</a>]</span>. This status code (307) does not require the user
agent to rewrite the POST request to a GET request and thereby drop
the form data in the POST request body.<a href="#section-4.12-4" class="pilcrow">¶</a></p>
<p id="section-4.12-5">In the HTTP standard <span>[<a href="#RFC9110" class="cite xref">RFC9110</a>]</span>, only the status code 303
unambiguously enforces rewriting the HTTP POST request to an HTTP GET
request. 

For all other status codes, including the popular 302, user
agents can opt not to rewrite POST to GET requests, thereby
causing the user's credentials to be revealed to the client. (In practice, however, most
user agents will only show this behavior for 307 redirects.)<a href="#section-4.12-5" class="pilcrow">¶</a></p>
<p id="section-4.12-6">Authorization servers that redirect a request that potentially contains the user's credentials
therefore <span class="bcp14">MUST NOT</span> use the HTTP 307 status code for redirection. If an
HTTP redirection (and not, for example, JavaScript) is used for such a
request, the authorization server <span class="bcp14">SHOULD</span> use HTTP status code 303 (See Other).<a href="#section-4.12-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="tls_terminating">
<section id="section-4.13">
        <h3 id="name-tls-terminating-reverse-pro">
<a href="#section-4.13" class="section-number selfRef">4.13. </a><a href="#name-tls-terminating-reverse-pro" class="section-name selfRef">TLS Terminating Reverse Proxies</a>
        </h3>
<p id="section-4.13-1">A common deployment architecture for HTTP applications is to hide the
application server behind a reverse proxy that terminates the TLS
connection and dispatches the incoming requests to the respective
application server nodes.<a href="#section-4.13-1" class="pilcrow">¶</a></p>
<p id="section-4.13-2">This section highlights some attack angles of this deployment
architecture with relevance to OAuth and gives recommendations for
security controls.<a href="#section-4.13-2" class="pilcrow">¶</a></p>
<p id="section-4.13-3">In some situations, the reverse proxy needs to pass security-related
data to the upstream application servers for further processing.
Examples include the IP address of the request originator, token-binding
IDs, and authenticated TLS client certificates. This data is usually
passed in HTTP headers added to the upstream request. While the headers
are often custom, application-specific headers, standardized header
fields for client certificates and client certificate chains are defined
in <span>[<a href="#RFC9440" class="cite xref">RFC9440</a>]</span>.<a href="#section-4.13-3" class="pilcrow">¶</a></p>
<p id="section-4.13-4">If the reverse proxy passes through any header sent from the
outside, an attacker could try to directly send the faked header
values through the proxy to the application server in order to
circumvent security controls that way. For example, it is standard
practice of reverse proxies to accept <code>X-Forwarded-For</code> headers and just
add the origin of the inbound request (making it a list). Depending on
the logic performed in the application server, the attacker could
simply add an allowed IP address to the header and render the protection useless.<a href="#section-4.13-4" class="pilcrow">¶</a></p>
<p id="section-4.13-5">A reverse proxy <span class="bcp14">MUST</span> therefore sanitize any inbound requests to ensure
the authenticity and integrity of all header values relevant for the
security of the application servers.<a href="#section-4.13-5" class="pilcrow">¶</a></p>
<p id="section-4.13-6">If an attacker were able to get access to the internal network between
the proxy and application server, the attacker could also try to
circumvent security controls in place. Therefore, it is essential to
ensure the authenticity of the communicating entities. Furthermore,
the communication link between the reverse proxy and application server
<span class="bcp14">MUST</span> be protected against eavesdropping, injection, and replay of
messages.<a href="#section-4.13-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="refresh_token_protection">
<section id="section-4.14">
        <h3 id="name-refresh-token-protection">
<a href="#section-4.14" class="section-number selfRef">4.14. </a><a href="#name-refresh-token-protection" class="section-name selfRef">Refresh Token Protection</a>
        </h3>
<p id="section-4.14-1">Refresh tokens are a convenient and user-friendly way to obtain new access
tokens. They also add
to the security of OAuth, since they allow the authorization server to issue
access tokens with a short lifetime and reduced scope, thus reducing the
potential impact of access token leakage.<a href="#section-4.14-1" class="pilcrow">¶</a></p>
<div id="discussion-1">
<section id="section-4.14.1">
          <h4 id="name-discussion-2">
<a href="#section-4.14.1" class="section-number selfRef">4.14.1. </a><a href="#name-discussion-2" class="section-name selfRef">Discussion</a>
          </h4>
<p id="section-4.14.1-1">
   Refresh tokens are an attractive target for attackers because they
   represent the full scope of access granted to 
   a certain client, and they are not further constrained to a specific
   resource. 
If an attacker is able to exfiltrate and successfully replay a
refresh token, the attacker will be able to mint access tokens and use
them to access resource servers on behalf of the resource owner.<a href="#section-4.14.1-1" class="pilcrow">¶</a></p>
<p id="section-4.14.1-2"><span>[<a href="#RFC6749" class="cite xref">RFC6749</a>]</span> already provides robust baseline protection by requiring<a href="#section-4.14.1-2" class="pilcrow">¶</a></p>
<ul class="compact">
<li class="compact" id="section-4.14.1-3.1">confidentiality of the refresh tokens in transit and storage,<a href="#section-4.14.1-3.1" class="pilcrow">¶</a>
</li>
            <li class="compact" id="section-4.14.1-3.2">the transmission of refresh tokens over TLS-protected connections between
authorization server and client,<a href="#section-4.14.1-3.2" class="pilcrow">¶</a>
</li>
            <li class="compact" id="section-4.14.1-3.3">the authorization server to maintain and check the binding of a refresh token
to a certain client and authentication of this client during token refresh,
if possible, and<a href="#section-4.14.1-3.3" class="pilcrow">¶</a>
</li>
            <li class="compact" id="section-4.14.1-3.4">that refresh tokens cannot be generated, modified, or guessed.<a href="#section-4.14.1-3.4" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-4.14.1-4"><span>[<a href="#RFC6749" class="cite xref">RFC6749</a>]</span> also lays the foundation for further
(implementation-specific) security measures, such as refresh token expiration and
revocation as well as refresh token rotation by defining respective
error codes and response behaviors.<a href="#section-4.14.1-4" class="pilcrow">¶</a></p>
<p id="section-4.14.1-5">This specification gives recommendations beyond the scope of
<span>[<a href="#RFC6749" class="cite xref">RFC6749</a>]</span> and clarifications.<a href="#section-4.14.1-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="recommendations-1">
<section id="section-4.14.2">
          <h4 id="name-recommendations">
<a href="#section-4.14.2" class="section-number selfRef">4.14.2. </a><a href="#name-recommendations" class="section-name selfRef">Recommendations</a>
          </h4>
<p id="section-4.14.2-1">Authorization servers <span class="bcp14">MUST</span> determine, based on a risk assessment,
whether to issue refresh tokens to a certain client. If the
authorization server decides not to issue refresh tokens, the client
<span class="bcp14">MAY</span> obtain a new access token by utilizing other grant types, such as the
authorization code grant type. In such a case, the authorization
server may utilize cookies and persistent grants to optimize the user
experience.<a href="#section-4.14.2-1" class="pilcrow">¶</a></p>
<p id="section-4.14.2-2">If refresh tokens are issued, those refresh tokens <span class="bcp14">MUST</span> be bound to
the scope and resource servers as consented by the resource owner.
This is to prevent privilege escalation by the legitimate client and reduce
the impact of refresh token leakage.<a href="#section-4.14.2-2" class="pilcrow">¶</a></p>
<p id="section-4.14.2-3">For confidential clients, <span>[<a href="#RFC6749" class="cite xref">RFC6749</a>]</span> already requires that refresh
tokens can only be used by the client for which they were issued.<a href="#section-4.14.2-3" class="pilcrow">¶</a></p>
<p id="section-4.14.2-4">Authorization servers <span class="bcp14">MUST</span> utilize one of these methods to
detect refresh token replay by malicious actors for public clients:<a href="#section-4.14.2-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.14.2-5.1">
              <strong>Sender-constrained refresh tokens:</strong> the authorization server
cryptographically binds the refresh token to a certain client
instance, e.g., by utilizing <span>[<a href="#RFC8705" class="cite xref">RFC8705</a>]</span> or <span>[<a href="#RFC9449" class="cite xref">RFC9449</a>]</span>.<a href="#section-4.14.2-5.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.14.2-5.2">
              <p id="section-4.14.2-5.2.1"><strong>Refresh token rotation:</strong> the authorization server issues a new
refresh token with every access token refresh response. The
previous refresh token is invalidated, but information about the
relationship is retained by the authorization server. If a refresh
token is compromised and subsequently used by both the attacker
and the legitimate client, one of them will present an invalidated
refresh token, which will inform the authorization server of the
breach. The authorization server cannot determine which party
submitted the invalid refresh token, but it will revoke the
active refresh token. This stops the attack at the cost of forcing
the legitimate client to obtain a fresh authorization grant.<a href="#section-4.14.2-5.2.1" class="pilcrow">¶</a></p>
<p id="section-4.14.2-5.2.2">Implementation note: The grant to which a refresh token belongs
may be encoded into the refresh token itself. This can enable an
authorization server to efficiently determine the grant to which a
refresh token belongs, and by extension, all refresh tokens that
need to be revoked. Authorization servers <span class="bcp14">MUST</span> ensure the
integrity of the refresh token value in this case, for example,
using signatures.<a href="#section-4.14.2-5.2.2" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-4.14.2-6">Authorization servers <span class="bcp14">MAY</span> revoke refresh tokens automatically in case
of a security event, such as:<a href="#section-4.14.2-6" class="pilcrow">¶</a></p>
<ul class="compact">
<li class="compact" id="section-4.14.2-7.1">password change or<a href="#section-4.14.2-7.1" class="pilcrow">¶</a>
</li>
            <li class="compact" id="section-4.14.2-7.2">logout at the authorization server.<a href="#section-4.14.2-7.2" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-4.14.2-8">Refresh tokens <span class="bcp14">SHOULD</span> expire if the client has been inactive for some
time, i.e., the refresh token has not been used to obtain fresh access
tokens for some time. The expiration time is at the discretion of the
authorization server. It might be a global value or determined based
on the client policy or the grant associated with the refresh token
(and its sensitivity).<a href="#section-4.14.2-8" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="client_impersonating">
<section id="section-4.15">
        <h3 id="name-client-impersonating-resour">
<a href="#section-4.15" class="section-number selfRef">4.15. </a><a href="#name-client-impersonating-resour" class="section-name selfRef">Client Impersonating Resource Owner</a>
        </h3>
<p id="section-4.15-1">Resource servers may make access control decisions based on the identity of a
resource owner for which an access token was issued, or based on the identity of
a client in the client credentials grant. For example, <span>[<a href="#RFC9068" class="cite xref">RFC9068</a>]</span> (JSON Web
Token (JWT) Profile for OAuth 2.0 Access Tokens) describes a data structure for
access tokens containing a <code>sub</code> claim defined as follows:<a href="#section-4.15-1" class="pilcrow">¶</a></p>
<blockquote id="section-4.15-2">
          <p id="section-4.15-2.1">
      In cases                        
      of access tokens obtained through grants where a resource owner is
      involved, such as the authorization code grant, the value of "sub"
      <span class="bcp14">SHOULD</span> correspond to the subject identifier of the resource owner.
      In cases of access tokens obtained through grants where no
      resource owner is involved, such as the client credentials grant,
      the value of "sub" <span class="bcp14">SHOULD</span> correspond to an identifier the
      authorization server uses to indicate the client application.<a href="#section-4.15-2.1" class="pilcrow">¶</a></p>
</blockquote>
<p id="section-4.15-3">If both options are possible, a resource server may mistake a client's identity
for the identity of a resource owner. For example, if a client is able to choose
its own <code>client_id</code> during registration with the authorization server, a
malicious client may set it to a value identifying a resource owner (e.g., a
<code>sub</code> value if OpenID Connect is used). If the resource server cannot properly
distinguish between access tokens obtained with involvement of the resource
owner and those without, the client may accidentally be able to access resources
belonging to the resource owner.<a href="#section-4.15-3" class="pilcrow">¶</a></p>
<p id="section-4.15-4">This attack potentially affects not only implementations using <span>[<a href="#RFC9068" class="cite xref">RFC9068</a>]</span>, but
also similar, bespoke solutions.<a href="#section-4.15-4" class="pilcrow">¶</a></p>
<div id="client_impersonating_countermeasures">
<section id="section-4.15.1">
          <h4 id="name-countermeasures-9">
<a href="#section-4.15.1" class="section-number selfRef">4.15.1. </a><a href="#name-countermeasures-9" class="section-name selfRef">Countermeasures</a>
          </h4>
<p id="section-4.15.1-1">Authorization servers <span class="bcp14">SHOULD NOT</span> allow clients to influence their <code>client_id</code> or
any other claim that could cause confusion with a genuine resource owner if a common
namespace for client IDs and user identifiers exists, such as in the <code>sub</code> claim
example from <span>[<a href="#RFC9068" class="cite xref">RFC9068</a>]</span> shown in <a href="#client_impersonating" class="auto internal xref">Section 4.15</a> above. Where this cannot be avoided, authorization servers <span class="bcp14">MUST</span> provide
other means for the resource server to distinguish between the two types of
access tokens.<a href="#section-4.15.1-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="clickjacking">
<section id="section-4.16">
        <h3 id="name-clickjacking">
<a href="#section-4.16" class="section-number selfRef">4.16. </a><a href="#name-clickjacking" class="section-name selfRef">Clickjacking</a>
        </h3>
<p id="section-4.16-1">As described in <span><a href="https://rfc-editor.org/rfc/rfc6819#section-4.4.1.9" class="relref">Section 4.4.1.9</a> of [<a href="#RFC6819" class="cite xref">RFC6819</a>]</span>, the authorization request is
susceptible to clickjacking attacks, also called user interface redressing. In
such an attack, an attacker embeds the authorization endpoint user interface in
an innocuous context. A user believing to interact with that context, for
example, by clicking on buttons, inadvertently interacts with the authorization
endpoint user interface instead. The opposite can be achieved as well: A user
believing to interact with the authorization endpoint might inadvertently type a
password into an attacker-provided input field overlaid over the original user
interface. Clickjacking attacks can be designed such that users can hardly
notice the attack, for example, using almost invisible iframes overlaid on top of
other elements.<a href="#section-4.16-1" class="pilcrow">¶</a></p>
<p id="section-4.16-2">An attacker can use this vector to obtain the user's authentication credentials,
change the scope of access granted to the client, and potentially access the
user's resources.<a href="#section-4.16-2" class="pilcrow">¶</a></p>
<p id="section-4.16-3">Authorization servers <span class="bcp14">MUST</span> prevent clickjacking attacks. Multiple
countermeasures are described in <span>[<a href="#RFC6819" class="cite xref">RFC6819</a>]</span>, including the use of the
X-Frame-Options HTTP response header field and frame-busting
JavaScript. In addition to those, authorization servers <span class="bcp14">SHOULD</span> also
use Content Security Policy (CSP) level 2 <span>[<a href="#W3C.CSP-2" class="cite xref">W3C.CSP-2</a>]</span> or greater.<a href="#section-4.16-3" class="pilcrow">¶</a></p>
<p id="section-4.16-4">To be effective, CSP must be used on the authorization endpoint and,
if applicable, other endpoints used to authenticate the user and
authorize the client (e.g., the device authorization endpoint, login
pages, error pages, etc.). This prevents framing by unauthorized
origins in user agents that support CSP. The client <span class="bcp14">MAY</span> permit being
framed by some other origin than the one used in its redirection
endpoint. For this reason, authorization servers <span class="bcp14">SHOULD</span> allow
administrators to configure allowed origins for particular clients
and/or for clients to register these dynamically.<a href="#section-4.16-4" class="pilcrow">¶</a></p>
<p id="section-4.16-5">Using CSP allows authorization servers to specify multiple origins in
a single response header field and to constrain these using flexible
patterns (see <span>[<a href="#W3C.CSP-2" class="cite xref">W3C.CSP-2</a>]</span> for details). Level 2 of CSP provides
a robust mechanism for protecting against clickjacking by using
policies that restrict the origin of frames (by using <code>frame-ancestors</code>)
together with those that restrict the sources of scripts allowed to
execute on an HTML page (by using <code>script-src</code>). A non-normative
example of such a policy is shown in the following listing:<a href="#section-4.16-5" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-4.16-6">
<pre>
HTTP/1.1 200 OK
Content-Security-Policy: frame-ancestors https://ext.example.org:8000
Content-Security-Policy: script-src 'self'
X-Frame-Options: ALLOW-FROM https://ext.example.org:8000
...
</pre><a href="#section-4.16-6" class="pilcrow">¶</a>
</div>
<p id="section-4.16-7">Because some user agents do not support <span>[<a href="#W3C.CSP-2" class="cite xref">W3C.CSP-2</a>]</span>, this technique
<span class="bcp14">SHOULD</span> be combined with others, including those described in
<span>[<a href="#RFC6819" class="cite xref">RFC6819</a>]</span>, unless such legacy user agents are explicitly unsupported
by the authorization server. Even in such cases, additional
countermeasures <span class="bcp14">SHOULD</span> still be employed.<a href="#section-4.16-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="rec_ibc">
<section id="section-4.17">
        <h3 id="name-attacks-on-in-browser-commu">
<a href="#section-4.17" class="section-number selfRef">4.17. </a><a href="#name-attacks-on-in-browser-commu" class="section-name selfRef">Attacks on In-Browser Communication Flows</a>
        </h3>
<p id="section-4.17-1">If the authorization response is sent with in-browser communication techniques
like postMessage <span>[<a href="#WHATWG.postmessage_api" class="cite xref">WHATWG.postmessage_api</a>]</span> instead of HTTP redirects, messages may
inadvertently be sent to malicious origins or injected from malicious origins.<a href="#section-4.17-1" class="pilcrow">¶</a></p>
<div id="examples">
<section id="section-4.17.1">
          <h4 id="name-examples">
<a href="#section-4.17.1" class="section-number selfRef">4.17.1. </a><a href="#name-examples" class="section-name selfRef">Examples</a>
          </h4>
<p id="section-4.17.1-1">The following non-normative pseudocode examples of attacks using in-browser
communication are described in <span>[<a href="#research.rub" class="cite xref">research.rub</a>]</span>.<a href="#section-4.17.1-1" class="pilcrow">¶</a></p>
<div id="insufficient-limitation-of-receiver-origins">
<section id="section-4.17.1.1">
            <h5 id="name-insufficient-limitation-of-">
<a href="#section-4.17.1.1" class="section-number selfRef">4.17.1.1. </a><a href="#name-insufficient-limitation-of-" class="section-name selfRef">Insufficient Limitation of Receiver Origins</a>
            </h5>
<p id="section-4.17.1.1-1">When sending the authorization response or token response via
postMessage, the authorization server sends the response to the wildcard
origin "*" instead of the client's origin. When the window to which the
response is sent is controlled by an attacker, the attacker can read the
response.<a href="#section-4.17.1.1-1" class="pilcrow">¶</a></p>
<div class="lang-javascript sourcecode" id="section-4.17.1.1-2">
<pre>
window.opener.postMessage(
  {
    code: "ABC",
    state: "123"
  },
  "*" // any website in the opener window can receive the message
)
</pre><a href="#section-4.17.1.1-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="insufficient-uri-validation">
<section id="section-4.17.1.2">
            <h5 id="name-insufficient-uri-validation">
<a href="#section-4.17.1.2" class="section-number selfRef">4.17.1.2. </a><a href="#name-insufficient-uri-validation" class="section-name selfRef">Insufficient URI Validation</a>
            </h5>
<p id="section-4.17.1.2-1">When sending the authorization response or token response via
postMessage, the authorization server may not check the
receiver origin against the redirection URI and instead, for example, may send
the response to an origin provided by an attacker. This is analogous to
the attack described in <a href="#insufficient_uri_validation" class="auto internal xref">Section 4.1</a>.<a href="#section-4.17.1.2-1" class="pilcrow">¶</a></p>
<div class="lang-javascript sourcecode" id="section-4.17.1.2-2">
<pre>
window.opener.postMessage(
  {
    code: "ABC",
    state: "123"
  },
  "https://attacker.example" // attacker-provided value
)
</pre><a href="#section-4.17.1.2-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="injection-after-insufficient-validation-of-sender-origin">
<section id="section-4.17.1.3">
            <h5 id="name-injection-after-insufficien">
<a href="#section-4.17.1.3" class="section-number selfRef">4.17.1.3. </a><a href="#name-injection-after-insufficien" class="section-name selfRef">Injection after Insufficient Validation of Sender Origin</a>
            </h5>
<p id="section-4.17.1.3-1">A client that expects the authorization response or token response via
postMessage may not validate the sender origin of the message. This
may allow an attacker to inject an authorization response or token response
into the client.<a href="#section-4.17.1.3-1" class="pilcrow">¶</a></p>
<p id="section-4.17.1.3-2">In the case of a maliciously injected authorization response, the attack
is a variant of the CSRF attacks described in <a href="#csrf" class="auto internal xref">Section 4.7</a>. The
countermeasures described in <a href="#csrf" class="auto internal xref">Section 4.7</a> apply to this attack as well.<a href="#section-4.17.1.3-2" class="pilcrow">¶</a></p>
<p id="section-4.17.1.3-3">In the case of a maliciously injected token response, sender-constrained
access tokens as described in <a href="#pop_tokens" class="auto internal xref">Section 4.10.1</a> may prevent the attack under
some circumstances, but additional countermeasures as described in <a href="#recommendations-1-1" class="auto internal xref">Section 4.17.2</a> are
generally required.<a href="#section-4.17.1.3-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="recommendations-1-1">
<section id="section-4.17.2">
          <h4 id="name-recommendations-2">
<a href="#section-4.17.2" class="section-number selfRef">4.17.2. </a><a href="#name-recommendations-2" class="section-name selfRef">Recommendations</a>
          </h4>
<p id="section-4.17.2-1">When comparing client receiver origins against pre-registered origins,
authorization servers <span class="bcp14">MUST</span> utilize exact string matching as described in
<a href="#iuv_countermeasures" class="auto internal xref">Section 4.1.3</a>. Authorization servers <span class="bcp14">MUST</span> send postMessages to
trusted client receiver origins, as shown in the following, non-normative example:<a href="#section-4.17.2-1" class="pilcrow">¶</a></p>
<div class="lang-javascript sourcecode" id="section-4.17.2-2">
<pre>
window.opener.postMessage(
  {
    code: "ABC",
    state: "123"
  },
  "https://client.example" // use explicit client origin
)
</pre><a href="#section-4.17.2-2" class="pilcrow">¶</a>
</div>
<p id="section-4.17.2-3">Wildcard origins like "*" in postMessage <span class="bcp14">MUST NOT</span> be used, as attackers can use them
to leak a victim's in-browser message to malicious origins.
Both measures contribute to the prevention of leakage of authorization codes and
access tokens (see <a href="#insufficient_uri_validation" class="auto internal xref">Section 4.1</a>).<a href="#section-4.17.2-3" class="pilcrow">¶</a></p>
<p id="section-4.17.2-4">Clients <span class="bcp14">MUST</span> prevent injection of in-browser messages on the client
receiver endpoint. Clients <span class="bcp14">MUST</span> utilize exact string matching to compare
the initiator origin of an in-browser message with the authorization
server origin, as shown in the following, non-normative example:<a href="#section-4.17.2-4" class="pilcrow">¶</a></p>
<div class="lang-javascript sourcecode" id="section-4.17.2-5">
<pre>
window.addEventListener("message", (e) =&gt; {
  // validate exact authorization server origin
  if (e.origin === "https://honest.as.example") {
    // process e.data.code and e.data.state
  }
})
</pre><a href="#section-4.17.2-5" class="pilcrow">¶</a>
</div>
<p id="section-4.17.2-6">Since in-browser communication flows only apply a different communication
technique (i.e., postMessage instead of HTTP redirect), all measures protecting
the authorization response listed in <a href="#rec_redirect" class="auto internal xref">Section 2.1</a> <span class="bcp14">MUST</span> be applied equally.<a href="#section-4.17.2-6" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="IANA">
<section id="section-5">
      <h2 id="name-iana-considerations">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-iana-considerations" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-5-1">This document has no IANA actions.<a href="#section-5-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="Security">
<section id="section-6">
      <h2 id="name-security-considerations">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-security-considerations" class="section-name selfRef">Security Considerations</a>
      </h2>
<p id="section-6-1">Security considerations are described in Sections <a href="#recommendations" class="auto internal xref">2</a>, <a href="#secmodel" class="auto internal xref">3</a>, and <a href="#attacks_and_mitigations" class="auto internal xref">4</a>.<a href="#section-6-1" class="pilcrow">¶</a></p>
</section>
</div>
<section id="section-7">
      <h2 id="name-references">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-references" class="section-name selfRef">References</a>
      </h2>
<section id="section-7.1">
        <h3 id="name-normative-references">
<a href="#section-7.1" class="section-number selfRef">7.1. </a><a href="#name-normative-references" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="BCP195">[BCP195]</dt>
        <dd>
<div class="refInstance">Best Current Practice 195, <span>&lt;<a href="https://www.rfc-editor.org/info/bcp195">https://www.rfc-editor.org/info/bcp195</a>&gt;</span>.<br><span>At the time of writing, this BCP comprises the following:</span>
</div>
<div class="refInstance" id="RFC8996">
            <span class="refAuthor">Moriarty, K.</span> and <span class="refAuthor">S. Farrell</span>, <span class="refTitle">"Deprecating TLS 1.0 and TLS 1.1"</span>, <span class="seriesInfo">BCP 195</span>, <span class="seriesInfo">RFC 8996</span>, <span class="seriesInfo">DOI 10.17487/RFC8996</span>, <time datetime="2021-03" class="refDate">March 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8996">https://www.rfc-editor.org/info/rfc8996</a>&gt;</span>. </div>
<div class="refInstance" id="RFC9325">
            <span class="refAuthor">Sheffer, Y.</span>, <span class="refAuthor">Saint-Andre, P.</span>, and <span class="refAuthor">T. Fossati</span>, <span class="refTitle">"Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)"</span>, <span class="seriesInfo">BCP 195</span>, <span class="seriesInfo">RFC 9325</span>, <span class="seriesInfo">DOI 10.17487/RFC9325</span>, <time datetime="2022-11" class="refDate">November 2022</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9325">https://www.rfc-editor.org/info/rfc9325</a>&gt;</span>. </div>
</dd>
<dd class="break"></dd>
<dt id="RFC3986">[RFC3986]</dt>
        <dd>
<span class="refAuthor">Berners-Lee, T.</span>, <span class="refAuthor">Fielding, R.</span>, and <span class="refAuthor">L. Masinter</span>, <span class="refTitle">"Uniform Resource Identifier (URI): Generic Syntax"</span>, <span class="seriesInfo">STD 66</span>, <span class="seriesInfo">RFC 3986</span>, <span class="seriesInfo">DOI 10.17487/RFC3986</span>, <time datetime="2005-01" class="refDate">January 2005</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3986">https://www.rfc-editor.org/info/rfc3986</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6749">[RFC6749]</dt>
        <dd>
<span class="refAuthor">Hardt, D., Ed.</span>, <span class="refTitle">"The OAuth 2.0 Authorization Framework"</span>, <span class="seriesInfo">RFC 6749</span>, <span class="seriesInfo">DOI 10.17487/RFC6749</span>, <time datetime="2012-10" class="refDate">October 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6749">https://www.rfc-editor.org/info/rfc6749</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6750">[RFC6750]</dt>
        <dd>
<span class="refAuthor">Jones, M.</span> and <span class="refAuthor">D. Hardt</span>, <span class="refTitle">"The OAuth 2.0 Authorization Framework: Bearer Token Usage"</span>, <span class="seriesInfo">RFC 6750</span>, <span class="seriesInfo">DOI 10.17487/RFC6750</span>, <time datetime="2012-10" class="refDate">October 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6750">https://www.rfc-editor.org/info/rfc6750</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6819">[RFC6819]</dt>
        <dd>
<span class="refAuthor">Lodderstedt, T., Ed.</span>, <span class="refAuthor">McGloin, M.</span>, and <span class="refAuthor">P. Hunt</span>, <span class="refTitle">"OAuth 2.0 Threat Model and Security Considerations"</span>, <span class="seriesInfo">RFC 6819</span>, <span class="seriesInfo">DOI 10.17487/RFC6819</span>, <time datetime="2013-01" class="refDate">January 2013</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6819">https://www.rfc-editor.org/info/rfc6819</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7521">[RFC7521]</dt>
        <dd>
<span class="refAuthor">Campbell, B.</span>, <span class="refAuthor">Mortimore, C.</span>, <span class="refAuthor">Jones, M.</span>, and <span class="refAuthor">Y. Goland</span>, <span class="refTitle">"Assertion Framework for OAuth 2.0 Client Authentication and Authorization Grants"</span>, <span class="seriesInfo">RFC 7521</span>, <span class="seriesInfo">DOI 10.17487/RFC7521</span>, <time datetime="2015-05" class="refDate">May 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7521">https://www.rfc-editor.org/info/rfc7521</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7523">[RFC7523]</dt>
        <dd>
<span class="refAuthor">Jones, M.</span>, <span class="refAuthor">Campbell, B.</span>, and <span class="refAuthor">C. Mortimore</span>, <span class="refTitle">"JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants"</span>, <span class="seriesInfo">RFC 7523</span>, <span class="seriesInfo">DOI 10.17487/RFC7523</span>, <time datetime="2015-05" class="refDate">May 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7523">https://www.rfc-editor.org/info/rfc7523</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8252">[RFC8252]</dt>
        <dd>
<span class="refAuthor">Denniss, W.</span> and <span class="refAuthor">J. Bradley</span>, <span class="refTitle">"OAuth 2.0 for Native Apps"</span>, <span class="seriesInfo">BCP 212</span>, <span class="seriesInfo">RFC 8252</span>, <span class="seriesInfo">DOI 10.17487/RFC8252</span>, <time datetime="2017-10" class="refDate">October 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8252">https://www.rfc-editor.org/info/rfc8252</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8414">[RFC8414]</dt>
        <dd>
<span class="refAuthor">Jones, M.</span>, <span class="refAuthor">Sakimura, N.</span>, and <span class="refAuthor">J. Bradley</span>, <span class="refTitle">"OAuth 2.0 Authorization Server Metadata"</span>, <span class="seriesInfo">RFC 8414</span>, <span class="seriesInfo">DOI 10.17487/RFC8414</span>, <time datetime="2018-06" class="refDate">June 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8414">https://www.rfc-editor.org/info/rfc8414</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8705">[RFC8705]</dt>
        <dd>
<span class="refAuthor">Campbell, B.</span>, <span class="refAuthor">Bradley, J.</span>, <span class="refAuthor">Sakimura, N.</span>, and <span class="refAuthor">T. Lodderstedt</span>, <span class="refTitle">"OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens"</span>, <span class="seriesInfo">RFC 8705</span>, <span class="seriesInfo">DOI 10.17487/RFC8705</span>, <time datetime="2020-02" class="refDate">February 2020</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8705">https://www.rfc-editor.org/info/rfc8705</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9068">[RFC9068]</dt>
      <dd>
<span class="refAuthor">Bertocci, V.</span>, <span class="refTitle">"JSON Web Token (JWT) Profile for OAuth 2.0 Access Tokens"</span>, <span class="seriesInfo">RFC 9068</span>, <span class="seriesInfo">DOI 10.17487/RFC9068</span>, <time datetime="2021-10" class="refDate">October 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9068">https://www.rfc-editor.org/info/rfc9068</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
<section id="section-7.2">
        <h3 id="name-informative-references">
<a href="#section-7.2" class="section-number selfRef">7.2. </a><a href="#name-informative-references" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="arXiv.1508.04324v2">[arXiv.1508.04324v2]</dt>
        <dd>
<span class="refAuthor">Mladenov, V.</span>, <span class="refAuthor">Mainka, C.</span>, and <span class="refAuthor">J. Schwenk</span>, <span class="refTitle">"On the security of modern Single Sign-On Protocols: Second-Order Vulnerabilities in OpenID Connect"</span>, <span class="refContent">arXiv:1508.04324v2</span>, <span class="seriesInfo">DOI 10.48550/arXiv.1508.04324</span>, <time datetime="2016-01-07" class="refDate">7 January 2016</time>, <span>&lt;<a href="https://arxiv.org/abs/1508.04324v2/">https://arxiv.org/abs/1508.04324v2/</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="arXiv.1601.01229">[arXiv.1601.01229]</dt>
        <dd>
<span class="refAuthor">Fett, D.</span>, <span class="refAuthor">Küsters, R.</span>, and <span class="refAuthor">G. Schmitz</span>, <span class="refTitle">"A Comprehensive Formal Security Analysis of OAuth 2.0"</span>, <span class="refContent">arXiv:1601.01229</span>, <span class="seriesInfo">DOI 10.48550/arXiv.1601.01229</span>, <time datetime="2016-01-06" class="refDate">6 January 2016</time>, <span>&lt;<a href="https://arxiv.org/abs/1601.01229/">https://arxiv.org/abs/1601.01229/</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="arXiv.1704.08539">[arXiv.1704.08539]</dt>
        <dd>
<span class="refAuthor">Fett, D.</span>, <span class="refAuthor">Küsters, R.</span>, and <span class="refAuthor">G. Schmitz</span>, <span class="refTitle">"The Web SSO Standard OpenID Connect: In-Depth Formal Security Analysis and Security Guidelines"</span>, <span class="refContent">arXiv:1704.08539</span>, <span class="seriesInfo">DOI 10.48550/arXiv.1704.08539</span>, <time datetime="2017-04-27" class="refDate">27 April 2017</time>, <span>&lt;<a href="https://arxiv.org/abs/1704.08539/">https://arxiv.org/abs/1704.08539/</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="arXiv.1901.11520">[arXiv.1901.11520]</dt>
        <dd>
<span class="refAuthor">Fett, D.</span>, <span class="refAuthor">Hosseyni, P.</span>, and <span class="refAuthor">R. Küsters</span>, <span class="refTitle">"An Extensive Formal Security Analysis of the OpenID Financial-grade API"</span>, <span class="refContent">arXiv:1901.11520</span>, <span class="seriesInfo">DOI 10.48550/arXiv.1901.11520</span>, <time datetime="2019-01-31" class="refDate">31 January 2019</time>, <span>&lt;<a href="https://arxiv.org/abs/1901.11520/">https://arxiv.org/abs/1901.11520/</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="bug.chromium">[bug.chromium]</dt>
        <dd>
<span class="refTitle">"Referer header includes URL fragment when opening link using New Tab"</span>, <span class="refContent">Chromium Issue Tracker, Issue ID: 40076763</span>, <span>&lt;<a href="https://issues.chromium.org/issues/40076763">https://issues.chromium.org/issues/40076763</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.bradley-oauth-jwt-encoded-state">[JWT-ENCODED-STATE]</dt>
        <dd>
<span class="refAuthor">Bradley, J.</span>, <span class="refAuthor">Lodderstedt, T.</span>, and <span class="refAuthor">H. Zandbelt</span>, <span class="refTitle">"Encoding claims in the OAuth 2 state parameter using a JWT"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-bradley-oauth-jwt-encoded-state-09</span>, <time datetime="2018-11-04" class="refDate">4 November 2018</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-bradley-oauth-jwt-encoded-state-09">https://datatracker.ietf.org/doc/html/draft-bradley-oauth-jwt-encoded-state-09</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-oauth-v2-1">[OAUTH-V2.1]</dt>
        <dd>
<span class="refAuthor">Hardt, D.</span>, <span class="refAuthor">Parecki, A.</span>, and <span class="refAuthor">T. Lodderstedt</span>, <span class="refTitle">"The OAuth 2.1 Authorization Framework"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-oauth-v2-1-12</span>, <time datetime="2024-11-15" class="refDate">15 November 2024</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12">https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="OAuth.Post">[OAuth.Post]</dt>
        <dd>
<span class="refAuthor">Jones, M.</span> and <span class="refAuthor">B. Campbell</span>, <span class="refTitle">"OAuth 2.0 Form Post Response Mode"</span>, <span class="refContent">The OpenID Foundation</span>, <time datetime="2015-04-27" class="refDate">27 April 2015</time>, <span>&lt;<a href="https://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html">https://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="OAuth.Responses">[OAuth.Responses]</dt>
        <dd>
<span class="refAuthor">de Medeiros, B., Ed.</span>, <span class="refAuthor">Scurtescu, M.</span>, <span class="refAuthor">Tarjan, P.</span>, and <span class="refAuthor">M. Jones</span>, <span class="refTitle">"OAuth 2.0 Multiple Response Type Encoding Practices"</span>, <span class="refContent">The OpenID Foundation</span>, <time datetime="2014-02-25" class="refDate">25 February 2014</time>, <span>&lt;<a href="https://openid.net/specs/oauth-v2-multiple-response-types-1_0.html">https://openid.net/specs/oauth-v2-multiple-response-types-1_0.html</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="OpenID.Core">[OpenID.Core]</dt>
        <dd>
<span class="refAuthor">Sakimura, N.</span>, <span class="refAuthor">Bradley, J.</span>, <span class="refAuthor">Jones, M.</span>, <span class="refAuthor">de Medeiros, B.</span>, and <span class="refAuthor">C. Mortimore</span>, <span class="refTitle">"OpenID Connect Core 1.0 incorporating errata set 2"</span>, <span class="refContent">The OpenID Foundation</span>, <time datetime="2023-12-15" class="refDate">15 December 2023</time>, <span>&lt;<a href="https://openid.net/specs/openid-connect-core-1_0.html">https://openid.net/specs/openid-connect-core-1_0.html</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="OpenID.Discovery">[OpenID.Discovery]</dt>
        <dd>
<span class="refAuthor">Sakimura, N.</span>, <span class="refAuthor">Bradley, J.</span>, <span class="refAuthor">Jones, M.</span>, and <span class="refAuthor">E. Jay</span>, <span class="refTitle">"OpenID Connect Discovery 1.0 incorporating errata set 2"</span>, <span class="refContent">The OpenID Foundation</span>, <time datetime="2023-12-15" class="refDate">15 December 2023</time>, <span>&lt;<a href="https://openid.net/specs/openid-connect-discovery-1_0.html">https://openid.net/specs/openid-connect-discovery-1_0.html</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="OpenID.JARM">[OpenID.JARM]</dt>
        <dd>
<span class="refAuthor">Lodderstedt, T.</span> and <span class="refAuthor">B. Campbell</span>, <span class="refTitle">"Financial-grade API: JWT Secured Authorization Response Mode for OAuth 2.0 (JARM)"</span>, <span class="refContent">The OpenID Foundation</span>, <time datetime="2018-10-17" class="refDate">17 October 2018</time>, <span>&lt;<a href="https://openid.net/specs/openid-financial-api-jarm.html">https://openid.net/specs/openid-financial-api-jarm.html</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="owasp.redir">[owasp.redir]</dt>
        <dd>
<span class="refAuthor">OWASP Foundation</span>, <span class="refTitle">"Unvalidated Redirects and Forwards Cheat Sheet"</span>, <span class="refContent">OWASP Cheat Sheet Series</span>, <span>&lt;<a href="https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="research.cmu">[research.cmu]</dt>
        <dd>
<span class="refAuthor">Chen, E.</span>, <span class="refAuthor">Pei, Y.</span>, <span class="refAuthor">Chen, S.</span>, <span class="refAuthor">Tian, Y.</span>, <span class="refAuthor">Kotcher, R.</span>, and <span class="refAuthor">P. Tague</span>, <span class="refTitle">"OAuth Demystified for Mobile Application Developers"</span>, <span class="refContent">CCS '14: Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security, pp. 892-903</span>, <span class="seriesInfo">DOI 10.1145/2660267.2660323</span>, <time datetime="2014-11" class="refDate">November 2014</time>, <span>&lt;<a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/OAuthDemystified.pdf">https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/OAuthDemystified.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="research.jcs_14">[research.jcs_14]</dt>
        <dd>
<span class="refAuthor">Bansal, C.</span>, <span class="refAuthor">Bhargavan, K.</span>, <span class="refAuthor">Delignat-Lavaud, A.</span>, and <span class="refAuthor">S. Maffeis</span>, <span class="refTitle">"Discovering concrete attacks on website authorization by formal analysis"</span>, <span class="refContent">Journal of Computer Security, vol. 22, no. 4, pp. 601-657</span>, <span class="seriesInfo">DOI 10.3233/JCS-140503</span>, <time datetime="2014-04-23" class="refDate">23 April 2014</time>, <span>&lt;<a href="https://www.doc.ic.ac.uk/~maffeis/papers/jcs14.pdf">https://www.doc.ic.ac.uk/~maffeis/papers/jcs14.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="research.rub">[research.rub]</dt>
        <dd>
<span class="refAuthor">Jannett, L.</span>, <span class="refAuthor">Mladenov, V.</span>, <span class="refAuthor">Mainka, C.</span>, and <span class="refAuthor">J. Schwenk</span>, <span class="refTitle">"DISTINCT: Identity Theft using In-Browser Communications in Dual-Window Single Sign-On"</span>, <span class="refContent">CCS '22: Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security</span>, <span class="seriesInfo">DOI 10.1145/3548606.3560692</span>, <time datetime="2022-11-07" class="refDate">7 November 2022</time>, <span>&lt;<a href="https://dl.acm.org/doi/pdf/10.1145/3548606.3560692">https://dl.acm.org/doi/pdf/10.1145/3548606.3560692</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="research.rub2">[research.rub2]</dt>
        <dd>
<span class="refAuthor">Fries, C.</span>, <span class="refTitle">"Security Analysis of Real-Life OpenID Connect Implementations"</span>, <span class="refContent">Master's thesis, Ruhr-Universität Bochum (RUB)</span>, <time datetime="2020-12-20" class="refDate">20 December 2020</time>, <span>&lt;<a href="https://www.nds.rub.de/media/ei/arbeiten/2021/05/03/masterthesis.pdf">https://www.nds.rub.de/media/ei/arbeiten/2021/05/03/masterthesis.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="research.ubc">[research.ubc]</dt>
        <dd>
<span class="refAuthor">Sun, S.-T.</span> and <span class="refAuthor">K. Beznosov</span>, <span class="refTitle">"The Devil is in the (Implementation) Details: An Empirical Analysis of OAuth SSO Systems"</span>, <span class="refContent">Proceedings of the 2012 ACM conference on Computer and communications security (CCS '12), pp. 378-390</span>, <span class="seriesInfo">DOI 10.1145/2382196.2382238</span>, <time datetime="2012-10" class="refDate">October 2012</time>, <span>&lt;<a href="https://css.csail.mit.edu/6.858/2012/readings/oauth-sso.pdf">https://css.csail.mit.edu/6.858/2012/readings/oauth-sso.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="research.udel">[research.udel]</dt>
        <dd>
<span class="refAuthor">Liu, D.</span>, <span class="refAuthor">Hao, S.</span>, and <span class="refAuthor">H. Wang</span>, <span class="refTitle">"All Your DNS Records Point to Us: Understanding the Security Threats of Dangling DNS Records"</span>, <span class="refContent">CCS '16: Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, pp. 1414-1425</span>, <span class="seriesInfo">DOI 10.1145/2976749.2978387</span>, <time datetime="2016-10-24" class="refDate">24 October 2016</time>, <span>&lt;<a href="https://dl.acm.org/doi/pdf/10.1145/2976749.2978387">https://dl.acm.org/doi/pdf/10.1145/2976749.2978387</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC2119">[RFC2119]</dt>
        <dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03" class="refDate">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7591">[RFC7591]</dt>
        <dd>
<span class="refAuthor">Richer, J., Ed.</span>, <span class="refAuthor">Jones, M.</span>, <span class="refAuthor">Bradley, J.</span>, <span class="refAuthor">Machulak, M.</span>, and <span class="refAuthor">P. Hunt</span>, <span class="refTitle">"OAuth 2.0 Dynamic Client Registration Protocol"</span>, <span class="seriesInfo">RFC 7591</span>, <span class="seriesInfo">DOI 10.17487/RFC7591</span>, <time datetime="2015-07" class="refDate">July 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7591">https://www.rfc-editor.org/info/rfc7591</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7636">[RFC7636]</dt>
        <dd>
<span class="refAuthor">Sakimura, N., Ed.</span>, <span class="refAuthor">Bradley, J.</span>, and <span class="refAuthor">N. Agarwal</span>, <span class="refTitle">"Proof Key for Code Exchange by OAuth Public Clients"</span>, <span class="seriesInfo">RFC 7636</span>, <span class="seriesInfo">DOI 10.17487/RFC7636</span>, <time datetime="2015-09" class="refDate">September 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7636">https://www.rfc-editor.org/info/rfc7636</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8174">[RFC8174]</dt>
        <dd>
<span class="refAuthor">Leiba, B.</span>, <span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time datetime="2017-05" class="refDate">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8707">[RFC8707]</dt>
        <dd>
<span class="refAuthor">Campbell, B.</span>, <span class="refAuthor">Bradley, J.</span>, and <span class="refAuthor">H. Tschofenig</span>, <span class="refTitle">"Resource Indicators for OAuth 2.0"</span>, <span class="seriesInfo">RFC 8707</span>, <span class="seriesInfo">DOI 10.17487/RFC8707</span>, <time datetime="2020-02" class="refDate">February 2020</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8707">https://www.rfc-editor.org/info/rfc8707</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9101">[RFC9101]</dt>
        <dd>
<span class="refAuthor">Sakimura, N.</span>, <span class="refAuthor">Bradley, J.</span>, and <span class="refAuthor">M. Jones</span>, <span class="refTitle">"The OAuth 2.0 Authorization Framework: JWT-Secured Authorization Request (JAR)"</span>, <span class="seriesInfo">RFC 9101</span>, <span class="seriesInfo">DOI 10.17487/RFC9101</span>, <time datetime="2021-08" class="refDate">August 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9101">https://www.rfc-editor.org/info/rfc9101</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9110">[RFC9110]</dt>
        <dd>
<span class="refAuthor">Fielding, R., Ed.</span>, <span class="refAuthor">Nottingham, M., Ed.</span>, and <span class="refAuthor">J. Reschke, Ed.</span>, <span class="refTitle">"HTTP Semantics"</span>, <span class="seriesInfo">STD 97</span>, <span class="seriesInfo">RFC 9110</span>, <span class="seriesInfo">DOI 10.17487/RFC9110</span>, <time datetime="2022-06" class="refDate">June 2022</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9110">https://www.rfc-editor.org/info/rfc9110</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9126">[RFC9126]</dt>
        <dd>
<span class="refAuthor">Lodderstedt, T.</span>, <span class="refAuthor">Campbell, B.</span>, <span class="refAuthor">Sakimura, N.</span>, <span class="refAuthor">Tonge, D.</span>, and <span class="refAuthor">F. Skokan</span>, <span class="refTitle">"OAuth 2.0 Pushed Authorization Requests"</span>, <span class="seriesInfo">RFC 9126</span>, <span class="seriesInfo">DOI 10.17487/RFC9126</span>, <time datetime="2021-09" class="refDate">September 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9126">https://www.rfc-editor.org/info/rfc9126</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9207">[RFC9207]</dt>
        <dd>
<span class="refAuthor">Meyer zu Selhausen, K.</span> and <span class="refAuthor">D. Fett</span>, <span class="refTitle">"OAuth 2.0 Authorization Server Issuer Identification"</span>, <span class="seriesInfo">RFC 9207</span>, <span class="seriesInfo">DOI 10.17487/RFC9207</span>, <time datetime="2022-03" class="refDate">March 2022</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9207">https://www.rfc-editor.org/info/rfc9207</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9396">[RFC9396]</dt>
        <dd>
<span class="refAuthor">Lodderstedt, T.</span>, <span class="refAuthor">Richer, J.</span>, and <span class="refAuthor">B. Campbell</span>, <span class="refTitle">"OAuth 2.0 Rich Authorization Requests"</span>, <span class="seriesInfo">RFC 9396</span>, <span class="seriesInfo">DOI 10.17487/RFC9396</span>, <time datetime="2023-05" class="refDate">May 2023</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9396">https://www.rfc-editor.org/info/rfc9396</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9440">[RFC9440]</dt>
        <dd>
<span class="refAuthor">Campbell, B.</span> and <span class="refAuthor">M. Bishop</span>, <span class="refTitle">"Client-Cert HTTP Header Field"</span>, <span class="seriesInfo">RFC 9440</span>, <span class="seriesInfo">DOI 10.17487/RFC9440</span>, <time datetime="2023-07" class="refDate">July 2023</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9440">https://www.rfc-editor.org/info/rfc9440</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9449">[RFC9449]</dt>
        <dd>
<span class="refAuthor">Fett, D.</span>, <span class="refAuthor">Campbell, B.</span>, <span class="refAuthor">Bradley, J.</span>, <span class="refAuthor">Lodderstedt, T.</span>, <span class="refAuthor">Jones, M.</span>, and <span class="refAuthor">D. Waite</span>, <span class="refTitle">"OAuth 2.0 Demonstrating Proof of Possession (DPoP)"</span>, <span class="seriesInfo">RFC 9449</span>, <span class="seriesInfo">DOI 10.17487/RFC9449</span>, <time datetime="2023-09" class="refDate">September 2023</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9449">https://www.rfc-editor.org/info/rfc9449</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-oauth-token-binding">[TOKEN-BINDING]</dt>
        <dd>
<span class="refAuthor">Jones, M.</span>, <span class="refAuthor">Campbell, B.</span>, <span class="refAuthor">Bradley, J.</span>, and <span class="refAuthor">W. Denniss</span>, <span class="refTitle">"OAuth 2.0 Token Binding"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-oauth-token-binding-08</span>, <time datetime="2018-10-19" class="refDate">19 October 2018</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-oauth-token-binding-08">https://datatracker.ietf.org/doc/html/draft-ietf-oauth-token-binding-08</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="W3C.CSP-2">[W3C.CSP-2]</dt>
        <dd>
<span class="refAuthor">West, M.</span>, <span class="refAuthor">Barth, A.</span>, and <span class="refAuthor">D. Veditz</span>, <span class="refTitle">"Content Security Policy Level 2"</span>, <span class="refContent">W3C Recommendation</span>, <time datetime="2016-12" class="refDate">December 2016</time>, <span>&lt;<a href="https://www.w3.org/TR/2016/REC-CSP2-20161215/">https://www.w3.org/TR/2016/REC-CSP2-20161215/</a>&gt;</span>. <span class="annotation">Latest version available at <span>&lt;<a href="https://www.w3.org/TR/CSP2/">https://www.w3.org/TR/CSP2/</a>&gt;</span>.</span>
        </dd>
<dd class="break"></dd>
<dt id="W3C.webappsec-referrer-policy">[W3C.webappsec-referrer-policy]</dt>
        <dd>
<span class="refAuthor">Eisinger, J.</span> and <span class="refAuthor">E. Stark</span>, <span class="refTitle">"Referrer Policy"</span>, <time datetime="2017-01-26" class="refDate">26 January 2017</time>, <span>&lt;<a href="https://www.w3.org/TR/2017/CR-referrer-policy-20170126/">https://www.w3.org/TR/2017/CR-referrer-policy-20170126/</a>&gt;</span>. <span class="annotation">Latest version available at <span>&lt;<a href="https://www.w3.org/TR/referrer-policy/">https://www.w3.org/TR/referrer-policy/</a>&gt;</span>.</span>
        </dd>
<dd class="break"></dd>
<dt id="W3C.WebAuthn">[W3C.WebAuthn]</dt>
        <dd>
<span class="refAuthor">Hodges, J.</span>, <span class="refAuthor">Jones, J.C.</span>, <span class="refAuthor">Jones, M.B.</span>, <span class="refAuthor">Kumar, A.</span>, and <span class="refAuthor">E. Lundberg</span>, <span class="refTitle">"Web Authentication: An API for accessing Public Key Credentials Level 2"</span>, <span class="refContent">W3C Recommendation</span>, <time datetime="2021-04-08" class="refDate">8 April 2021</time>, <span>&lt;<a href="https://www.w3.org/TR/2021/REC-webauthn-2-20210408/">https://www.w3.org/TR/2021/REC-webauthn-2-20210408/</a>&gt;</span>. <span class="annotation">Latest version available at <span>&lt;<a href="https://www.w3.org/TR/webauthn-2/">https://www.w3.org/TR/webauthn-2/</a>&gt;</span>.</span>
        </dd>
<dd class="break"></dd>
<dt id="W3C.WebCrypto">[W3C.WebCrypto]</dt>
        <dd>
<span class="refAuthor">Watson, M., Ed.</span>, <span class="refTitle">"Web Cryptography API"</span>, <span class="refContent">W3C Recommendation</span>, <time datetime="2017-01-26" class="refDate">26 January 2017</time>, <span>&lt;<a href="https://www.w3.org/TR/2017/REC-WebCryptoAPI-20170126/">https://www.w3.org/TR/2017/REC-WebCryptoAPI-20170126/</a>&gt;</span>. <span class="annotation">Latest version available at <span>&lt;<a href="https://www.w3.org/TR/WebCryptoAPI/">https://www.w3.org/TR/WebCryptoAPI/</a>&gt;</span>.</span>
        </dd>
<dd class="break"></dd>
<dt id="WHATWG.CORS">[WHATWG.CORS]</dt>
        <dd>
<span class="refAuthor">WHATWG</span>, <span class="refTitle">"CORS protocol"</span>, <span class="refContent">Fetch: Living Standard, Section 3.2</span>, <time datetime="2024-06-17" class="refDate">17 June 2024</time>, <span>&lt;<a href="https://fetch.spec.whatwg.org/#http-cors-protocol">https://fetch.spec.whatwg.org/#http-cors-protocol</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="WHATWG.postmessage_api">[WHATWG.postmessage_api]</dt>
      <dd>
<span class="refAuthor">WHATWG</span>, <span class="refTitle">"Cross-document messaging"</span>, <span class="refContent">HTML: Living Standard, Section 9.3</span>, <time datetime="2024-08-19" class="refDate">19 August 2024</time>, <span>&lt;<a href="https://html.spec.whatwg.org/multipage/web-messaging.html#web-messaging">https://html.spec.whatwg.org/multipage/web-messaging.html#web-messaging</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</section>
<div id="Acknowledgements">
<section id="appendix-A">
      <h2 id="name-acknowledgements">
<a href="#name-acknowledgements" class="section-name selfRef">Acknowledgements</a>
      </h2>
<p id="appendix-A-1">We would like to thank
<span class="contact-name">Brock Allen</span>,
<span class="contact-name">Annabelle Richard Backman</span>,
<span class="contact-name">Dominick Baier</span>,
<span class="contact-name">Vittorio Bertocci</span>,
<span class="contact-name">Brian Campbell</span>,
<span class="contact-name">Bruno Crispo</span>,
<span class="contact-name">William Dennis</span>,
<span class="contact-name">George Fletcher</span>,
<span class="contact-name">Matteo Golinelli</span>,
<span class="contact-name">Dick Hardt</span>,
<span class="contact-name">Joseph Heenan</span>,
<span class="contact-name">Pedram Hosseyni</span>,
<span class="contact-name">Phil Hunt</span>,
<span class="contact-name">Tommaso Innocenti</span>,
<span class="contact-name">Louis Jannett</span>,
<span class="contact-name">Jared Jennings</span>,
<span class="contact-name">Michael B. Jones</span>,
<span class="contact-name">Engin Kirda</span>,
<span class="contact-name">Konstantin Lapine</span>,
<span class="contact-name">Neil Madden</span>,
<span class="contact-name">Christian Mainka</span>,
<span class="contact-name">Jim Manico</span>,
<span class="contact-name">Nov Matake</span>,
<span class="contact-name">Doug McDorman</span>,
<span class="contact-name">Karsten Meyer zu Selhausen</span>,
<span class="contact-name">Ali Mirheidari</span>,
<span class="contact-name">Vladislav Mladenov</span>,
<span class="contact-name">Kaan Onarioglu</span>,
<span class="contact-name">Aaron Parecki</span>,
<span class="contact-name">Michael Peck</span>,
<span class="contact-name">Johan Peeters</span>,
<span class="contact-name">Nat Sakimura</span>,
<span class="contact-name">Guido Schmitz</span>,
<span class="contact-name">Jörg Schwenk</span>,
<span class="contact-name">Rifaat Shekh-Yusef</span>,
<span class="contact-name">Travis Spencer</span>,
<span class="contact-name">Petteri Stenius</span>,
<span class="contact-name">Tomek Stojecki</span>,
<span class="contact-name">David Waite</span>,
<span class="contact-name">Tim Würtele</span>, and
<span class="contact-name">Hans Zandbelt</span>
for their valuable feedback.<a href="#appendix-A-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="authors-addresses">
<section id="appendix-B">
      <h2 id="name-authors-addresses">
<a href="#name-authors-addresses" class="section-name selfRef">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Torsten Lodderstedt</span></div>
<div dir="auto" class="left"><span class="org">SPRIND</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:torsten@lodderstedt.net" class="email">torsten@lodderstedt.net</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">John Bradley</span></div>
<div dir="auto" class="left"><span class="org">Yubico</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:ve7jtb@ve7jtb.com" class="email">ve7jtb@ve7jtb.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Andrey Labunets</span></div>
<div dir="auto" class="left"><span class="org">Independent Researcher</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:isciurus@gmail.com" class="email">isciurus@gmail.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Daniel Fett</span></div>
<div dir="auto" class="left"><span class="org">Authlete</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:mail@danielfett.de" class="email">mail@danielfett.de</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
